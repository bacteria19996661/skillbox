#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Часть 2. Модуль 14. Практическая работа. Задача 5. Кэширование для ускорения вычислений
#
# Создайте декоратор, который кэширует результаты вызова функции и, при повторном вызове
# с теми же аргументами, возвращает сохранённый результат.
# Примените его к рекурсивной функции вычисления чисел Фибоначчи.
#
# В итоге декоратор должен проверять аргументы, с которыми вызывается функция, и,
# если такие аргументы уже использовались, должен вернуть сохранённый результат вместо запуска расчёта.
#
# Советы
#
# Для хранения результатов удобно использовать словарь, так как поиск элементов внутри
# словаря будет иметь сложность, равную в среднем O(1).
# При этом не стоит хранить все вычисления в одном словаре, созданном снаружи функций
# (в глобальной области видимости). Лучше создавать отдельные словари для каждой декорируемой функции.

# from functools import lru_cache
# from functools import total_ordering
# from functools import cached_property

# Декоратор @lru_cache имеет параметр maxsize, который определяет максимальное количество
# результатов для хранения в кэше. Когда кэш заполнен и необходимо сохранить новый результат,
# наименее использованный результат вытесняется из кэша, чтобы освободить место для нового.
# Это называется стратегией наименее использованного результата (LRU).
# По умолчанию maxsize установлен на 128. Если оно установлено в None, функции LRU отключены,
# и кэш может расти без ограничений.

# Благодаря декоратору @total_ordering результаты сравнений между
# различными экземплярами касса будут правильными.

# Декоратор @cached_property может превратить метод класса в свойство,
# значение которого вычисляется один раз, а затем кэшируется как обычный атрибут
# на протяжении всего существования экземпляра.


from typing import Callable, Any
import functools
import time


def timer(func: Callable) -> Callable:
    """ Декоратор. Выводит время работы функции """

    @functools.wraps(func)
    # декоратор wraps, которому передаем оборачиваемую функцию для избежания проблем декораторов
    def wrapped_func(*args, **kwargs) -> Any:
        start_time = time.time()
        res = func(*args, **kwargs)
        end_time = time.time()
        run_time = round(end_time - start_time, 10)
        print('Время работы кода: {} сек.'.format(run_time))

        return res

    return wrapped_func


def caching(func: Callable) -> Callable:
    """
    Декоратор, который кэширует результаты вызова функции и, при повторном вызове
    с теми же аргументами, возвращает сохранённый результат.
    """
    cache_dict = dict()

    @functools.wraps(func)
    def wrapper(*args) -> Any:
        if args not in cache_dict:
            cache_dict[args] = func(*args)
        return cache_dict[args]
    return wrapper


@caching
@timer
def fibonacci(number):
    if number <= 1:
        return number
    else:
        return fibonacci(number - 1) + fibonacci(number - 2)


result = fibonacci(99)
print(result)
