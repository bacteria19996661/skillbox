#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Часть 2. Модуль 14. Практическая работа. Задача 3. Логирование
#
# Реализуйте декоратор logging, который будет отвечать за логирование функций.
# На экран выводится название функции и её документация. Если во время выполнения
# декорируемой функции возникла ошибка, то в
# файл function_errors.log записываются название функции и ошибки.
#
# Также постарайтесь сделать так, чтобы программа не завершалась после
# обнаружения первой же ошибки, а обрабатывала все декорируемые функции
# и сразу записывала все ошибки в файл.
#
# Дополнительно: запишите дату и время возникновения ошибки, используя модуль datetime.
#
# Что оценивается
# Результат вычислений корректен.
# Сообщения о процессе получения результата осмыслены и понятны для пользователя.
# Переменные, функции и собственные методы классов имеют значащие имена (не a, b, c, d).
# Классы и методы/функции имеют прописанную документацию.
# Есть аннотация типов для методов/функций и их аргументов (кроме args и kwargs).
# Если функция/метод ничего не возвращает, то используется None.
# Во всех декораторах используется functools.wraps().
#



from datetime import datetime    # Модуль для работы с дтами и временем.
import random
from typing import Callable, Any    # Модуль для аннотации объектов.
import functools    # Модуль с инструментами для избежания проблем декораторов
# при работе с магическими методами оборачиваемых функций (получение информации о функции)


def logging(func: Callable) -> Callable:    # ЛОГИРОВАНИЕ ФУНКЦИИ
    """ Декоратор, логирующий работу кода """

    @functools.wraps(func)
    # Декоратор, которому передаем оборачиваемую функцию для избежания проблем декораторов.
    def wrapped_func(*args, **kwargs) -> Any:
        try:

            print(f'{func.__name__} - {func.__doc__}')
            result = func(*args, **kwargs)

            return result

        except (Exception, TypeError) as e:
            err = f'{datetime.now().strftime("%d.%m.%Y %H:%M:%S")} - {func.__name__} - {e}'
            with open('function_errors.log', 'a+', encoding='utf-8') as log_file:
                log_file.write(f'{err}\n')

    return wrapped_func

@logging
def generate_number(number: int) -> float:
    """
    Функция проверки логирования.
    :param number (int): делимое
    x (real): рандомный делитель
    :return (real): частное
    """
    x = random.randint(0, 2)
    if x == 1:
        raise Exception("Вызвано исключение!")
    return number / x


result = generate_number(1)
print(f"Результат работы функции: {result}")




# Определить индивидуальный менеджер контекста для каких-то особых требований
# from contextlib import contextmanager
# @contextmanager
