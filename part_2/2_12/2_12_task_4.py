#!/usr/bin/python
# -*- coding: utf-8 -*-
# Часть 2. Модуль 12. Практическая работа. Задача 4. RPG-игра
#
# Разработать искусственный интеллект (заменить ИИ смекалкой и набором if/else-условий)
# для союзников, которые сражаются бок о бок с реальными игроками.
#
# Код, описывающий монстров - monsters.py (изменять нельзя).
# В файле heroes.py вы найдёте заготовки системы классов:
# базовый класс hero, который нельзя изменять;
# наследники класса tank/healer/attacker — их надо изменять.
# Помимо этого, в main.py есть код, который:
# запускает один год сражений — изменять нельзя;
# создаёт команду для сражения с монстрами — изменять можно, но с условиями;
# запускает 20 раз один год сражений и подсчитывает количество побед — изменять нельзя.
# Ваша задача:
#
# Дописать код в классы tank/healer/attacker в файле heroes.py.
# Сформировать команду в main.py.
# Проверить, что с выбранной вами стратегией герои побеждают монстров как минимум
# в половине случаев (>= 10 побед из 20).
# Цель: из 20 сражений нужно побеждать как минимум в 10.
# В сражениях много случайностей, поэтому убедитесь, что в нескольких разных запусках
# ваша команда набирает нужное количество очков.
#
# Советы и рекомендации
# Внимательно изучите код поведения монстров. Изменять его нельзя, но изучать не запрещено.
# При помощи команды print выводите информацию о том, кто и что делает каждый день.
# Особое внимание уделите информации, которая идёт в последние дни перед поражением героев.
# На основе полученной информации попробуйте изменять приоритеты действий. Обратите внимание,
# что вы можете не только выбирать действие для выполнения, но также выбрать цель для действия.
# Иногда может быть выгоднее атаковать монстров конкретного класса, чтобы уменьшить урон по вашей команде.
#
# Что оценивается
# Как минимум в трёх запусках из пяти команда героев побеждает 10+ раз.
# Модели реализованы в стиле ООП, основной функционал описан в методах классов и отдельных функциях.
# Модели реализованы согласно инструкциям.
# При написании классов соблюдаются основные принципы ООП: инкапсуляция, наследование и полиморфизм.
# Для получения и установки значений у приватных атрибутов используются сеттеры и геттеры.
# Для создания нового класса на основе уже существующего используется наследование.
# Сообщения о процессе получения результата осмысленны и понятны пользователю.
# Переменные, функции и собственные методы классов имеют значащие имена, а не a, b, c, d.
# Классы и методы/функции имеют прописанную документацию.