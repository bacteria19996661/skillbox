# Соберите информацию об операционной системе и версии Python.

import platform
import sys

info = 'OS info is \n{}\n\nPython version is {} {}'.format(
    platform.uname(),
    sys.version,
    platform.architecture(),
)
print(info)

with open('os_info.txt', 'w', encoding='utf8') as file:
    file.write(info)


********************************************************************************

# Часть 1. Модуль 1. Задача 2. Приветствие
#
# Напишите программу, которая выводит такое «окно» на экран.
# Размер окна может быть любым, вместо слова «друг» можете написать своё имя.
# Постарайтесь добиться результата из третьего варианта.
#
# Что оценивается
# Результат вывода корректен и соответствует картинке.
# Отсутствуют пробелы после print и перед скобками: “print ()” — неверно, “print()” — верно.
# Нет пробелов и внутри скобок.

for row in range(8):
    if row == 0 or row == 7:
        print('=' * 30)
    elif row == 3:
        print('||', ' ' * 8, 'Привет', ' ' * 8, '||')
    elif row == 4:
        print('||', ' ' * 8, 'друг!', ' ' * 9, '||')
    else:
        print('||', ' ' * 24, '||')


********************************************************************************

# Часть 1. Модуль 2. Задача 1. Пропавшая переменная
#
# Найдите в программе необъявленную переменную и объявите её, присвоив ей значение ‘Кот’.
# client = ‘Петя’
# print(client)
# print(‘ и ’)
# print(pet)
#
# Что оценивается
# Результат вывода корректен, нет ошибок. Присвоено значение переменной pet.
# Отсутствуют пробелы после print и перед скобками: “print ()” — неверно, “print()” — верно.
# Нет пробелов и внутри скобок.
# Знак равенства выделен пробелами с двух сторон: “client = ‘Петя’” — верно, “client=‘Петя’” — неверно.

client = 'Петя'
print(client)
print(' и ')
pet = 'Кот'
print(pet)


********************************************************************************

# Часть 1. Модуль 2. Задача 2. Цвета
#
# Исправьте программу так, чтобы в результате её выполнения на экран в одну строку выводился текст:
# Red Blue Green RedGreenBlue Blue GreenBlue.
# r = 'Red'
# g = 'Green'
# b = 'Blue'
# print(b, r, g, b, g + b, b + b + g, b)
#
# Что оценивается
# Результат вывода соответствует картинке (тексту).
# После запятой стоит пробел, перед запятой пробела нет.
# Знак конкатенации (+) выделен пробелами с двух сторон.

r = 'Red'
g = 'Green'
b = 'Blue'
print(r, b, g, r + g + b, b, g + b)


********************************************************************************

# Часть 1. Модуль 2. Задача 3. Животные
#
# Создайте две переменные с именами «Первое животное» и «Второе животное» на английском языке.
# Запишите в первую переменную слово «Заяц», а во вторую — «Черепаха».
# Используя эти переменные, выведите на экран текст «Заяц спит, Черепаха идёт» в одну строку.
#
# Что оценивается
# input содержит корректное приглашение для ввода: “input()” — неверно;
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3);
# после запятой стоит пробел, перед запятой пробела нет;
# отсутствие пробелов после print и перед скобками: “print ()” — неверно, “print()” — верно.

hare = 'Заяц'
turtle = 'Черепаха'
print(hare, 'спит,' ,turtle, 'идет')


********************************************************************************

# Часть 1. Модуль 2. Задача 4. Информация о пользователе
#
# Напишите программу, которая запрашивает некоторые данные у пользователя,
# затем выведите их на экран, как показано ниже. Данные должны лежать в разных переменных.
# Вариант 1. Запросите имя и фамилию и выведите их на экран построчно.
# Результат должен быть таким (с вашим именем и фамилией, конечно):
#
# Вариант 2. Запросите имя, фамилию и город проживания, затем выведите их на экран в две строки:
# первая — «Вас зовут» и далее имя и фамилия, вторая — «Вы живёте в городе» и далее город.
# Для красоты отделите в консоли ввод и вывод данных, как в примере.
#
# Что оценивается
# input содержит корректное приглашение для ввода: “input()” — неверно;
# результат вывода соответствует примеру;
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3);
# пробелы после запятых, пробелы при бинарных операциях;
# после запятой стоит пробел, перед запятой пробела нет;
# отсутствие пробелов после print и перед скобками: “print ()” — неверно, “print()” — верно;
# отсутствуют пробелы внутри скобок.

first_name = input('Введите имя пользователя: ')
if first_name == 'Роман' :
    greeting = 'Привет, '
    print(greeting, first_name)
    intro = "К сожалению, у Вас нет доступа к системе."
    info = "Пожалуйста, обратитесь к системному администратору."
    print(intro)
    print(info)
else:
    error = 'Вы не Роман!'
    print(error)


********************************************************************************

# Часть 1. Модуль 2. Задача 5. Вход в систему
#
# Исправьте программу и допишите необходимые команды для получения нужного результата.
# Будьте внимательны при исправлении и помните о правилах названия переменных.
# Программа:
# first name = input('Введите имя пользователя: ')
# grииting = 'Утро доброе'
# print(greeting, first name)
# intro = "К сожалению, у Вас нет доступа к системе."
# info == "Пожалуйста, обратитесь к системному администратору."
#
# Что оценивается
# Результат вывода соответствует картинке.
# Переменные имеют значащие имена, не только a, b, c, d (видео 2.3).
# Нет смешения символов из разных алфавитов в именах переменных.
# Пробелы после запятых, пробелы при бинарных операциях.
# После запятой стоит пробел, перед запятой пробела нет.
# Отсутствуют пробелы после print и перед скобками: “print ()” — неверно, “print()” — верно.
# Нет пробелов и внутри скобок.

start_position = input('Введите город вылета: ')
end_position = input('Введите город прилета: ')
print(start_position + ' - ' + end_position)


********************************************************************************

# Часть 1. Модуль 2. Задача 6. Полёт
#
# Напишите программу для сервиса заказа билетов, которая запрашивает
# у пользователя город вылета и город прилёта. Затем выведите их в одну строку
# через тире. Обратите внимание на свои переменные: названия должны отражать содержимое.
#
# Что оценивается
# input содержит корректное приглашение для ввода: “input()” — неверно;
# результат вывода соответствует заданию;
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3);
# пробелы после запятых, пробелы при бинарных операциях (конкатенация в данной задаче);
# после запятой стоит пробел, перед запятой пробела нет;
# отсутствуют пробелы после print и перед скобками: “print ()” — неверно, “print()” — верно;
# нет пробелов и внутри скобок.

start_position = input('Введите город вылета: ')
end_position = input('Введите город прилета: ')
print(start_position + ' - ' + end_position)


********************************************************************************

# Часть 1. Модуль 2. Задача 7. Путь к файлу
#
# К каждому файлу на компьютере можно узнать путь. Выглядит он примерно так:
# 'C:/user/docs/folder/new_file.txt'
# Напишите программу, которая запрашивает у пользователя его имя и имя файла (переменные user и new_file соответственно). Используя операцию конкатенации, выведите путь к файлу на экран. Пример результата:
#
# Что оценивается
# результат вывода соответствует картинке;
# input содержит корректное приглашение для ввода: “input()” — неверно;
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3);
# пробелы после запятых, пробелы при бинарных операциях (конкатенация в данной задаче);
# после запятой стоит пробел, перед запятой пробела нет;
# отсутствуют пробелы после print и перед скобками: “print ()” — неверно, “print()” — верно;
# нет пробелов и внутри скобок.

user_name = input('Введите имя пользователя: ')
file_name = input('Введите название файла: ')
print('C:/' + user_name + '/docs/folder/' + file_name + '.txt')


********************************************************************************

# Часть 1. Модуль 2. Задача 8. По желанию. Обмен значений двух переменных
#
# Дана программа, которая запрашивает у пользователя два слова,
# а затем выводит их на экран два раза. Скопируйте эту программу в редактор и проверьте.
# a = input('Введите первое слово: ')
# b = input('Введите второе слово: ')
# print(a, b)
# # стереть эту строчку и вставить свой код здесь
# print(a, b)
# Задача: поменять значения переменных a и b местами.
# Изменять, удалять, менять местами 1-ю, 2-ю, 3-ю и последнюю строчки нельзя.
# Но в 4-ю строку можно вставлять сколько угодно кода, не трогая последний принт.
#
# Что оценивается
# Результат вычислений и вывода корректен. Строки с print остались неизменными,
# не изменён порядок вывода переменных.

a = input('Введите первое слово: ')
b = input('Введите второе слово: ')
print(a, b)
a, b = b, a
print(a, b)


********************************************************************************

# Часть 1. Модуль 3. Задача 1. Язык математики
#
# В первый же день на сайте отвалилась формула по расчёту рекламной метрики,
# и только Вася может её поправить. Часть программы с вводными данными представлена ниже,
# отдельно записана формула на математическом языке.
#
# Дана программа:
# a = 8
# b = 10
# c = 12
# d = 18
#
# Продолжите программу:
# переведите выражение с математического языка на язык Python,
# запишите его в переменную res и выведите результат.
#
# Советы и рекомендации
# Порядок действий не всегда очевиден, но при помощи скобок его можно изменять и упрощать.
#
# Что оценивается
# Результат вычисления корректен.
# Правильно употреблены пробелы после запятых и при бинарных операциях.

a = 8
b = 10
c = 12
d = 18
res = ((-3 + a ** 2) * b - 2 ** 3) / (c - 2 * d)
print(res)


********************************************************************************

# Часть 1. Модуль 3. Задача 2. Финансовый отчёт
#
# Васе пришло очередное задание — автоматизация финансовой отчётности.
# Звучит сложно, а на деле нужно просто написать код, который будет считать нужные
# для отчёта вычисления автоматически. Вычисления, которые нужно реализовать в программе:
# сумму дохода первых двух кварталов поделить на сумму последних двух кварталов,
# чтобы понять динамику роста или падения дохода.
#
# Алгоритм действий в программе:
# Запросить у пользователя четыре числа.
# Отдельно сложить два первых и два вторых.
# Разделить первую сумму на вторую.
# Вывести результат на экран.
#
# Что оценивается
# В input содержится корректное приглашение для ввода.
# Результат вычислений корректен.
# Переменные имеют значащие имена: не только a, b, c, d (видео 2.3).
# Есть пробелы после запятых и при бинарных операциях.


quarter1 = int(input('Введите доход за первый квартал: '))
quarter2 = int(input('Введите доход за второй квартал: '))
quarter3 = int(input('Введите доход за третий квартал: '))
quarter4 = int(input('Введите доход за четвертый квартал: '))
dinamika = (quarter1 + quarter2) / (quarter3 + quarter4)
print('Динамика роста:', dinamika)


********************************************************************************

# Часть 1. Модуль 3. Задача 3. Следующее и предыдущее числа
#
# Напишите программу, которая получает от пользователя число и выводит на экран
# два ответа — следующее и предыдущее числа.
#
# Что оценивается
# В input содержится корректное приглашение для ввода.
# Вывод соответствует заданию.
# Нет простых print(a), print(a − 1).
# Есть пробелы после запятых в print.

number = int(input('Введите число: '))
print('После числа', number, 'идет число', number + 1)
print('До числа', number, 'идет число', number - 1)


********************************************************************************

# Часть 1. Модуль 3. Задача 4. Площадь треугольника
#
# Напишите программу, которая запрашивает у пользователя длины двух катетов
# в прямоугольном треугольнике и выводит его площадь.
#
# Советы и рекомендации
# Не стоит применять целочисленное деление, это не совсем корректно.
# Обратите внимание на написание переменной S: её нужно писать как s, со строчной.
#
# Что оценивается
# Вычисления корректны, применены правильные операции.
# В input содержится корректное приглашение для ввода.
# Есть пробелы после запятых и при бинарных операциях.

katet1 = int(input('Введите длину первого катета: '))
katet2 = int(input('Введите длину второго катета: '))
print('Площадь прямоугольного треугольника равна', (katet1 * katet2) / 2)


********************************************************************************

# Часть 1. Модуль 3. Задача 5. Часы
#
# Напишите программу, которая получает на вход число n (количество минут),
# затем считает, сколько это будет в часах и сколько минут останется,
# и выводит на экран эти два результата.
#
# Советы и рекомендации
# В реальной практике приходится вникать в контекст задачи (даже если это совсем не ваша область знаний), чтобы понять, как решить её при помощи кода. Ответы на следующие вопросы станут подсказками к шагам решения:
# Сколько градусов в полном круге? Сколько часов в полном обороте часовой стрелки?
# Сколько оборотов делает минутная стрелка за час? Сколько градусов проходит минутная стрелка за полный час? За половину часа?
# Какую часть от полного количества часов на циферблате проходит часовая стрелка за час?
# Какую часть круга проходит часовая стрелка за час?
#
# Что оценивается
# Результат вычислений корректен.
# В input содержится корректное приглашение для ввода.
# Переменные имеют значащие названия.
# Есть пробелы после запятых и при бинарных операциях.

min = int(input('Введите кол-во минут: '))
print('Часов в минутах', min // 60)
print('Минут останется', min % 60)


********************************************************************************

# Часть 1. Модуль 3. Задача 6. Проверяем бухгалтера
#
# Невнимательный бухгалтер Антон складывает числа быстро, но иногда забывает
# о двух последних разрядах. Чтобы помочь Антону, напишите программу, которая бы
# складывала только два последних разряда.
# Реализуйте программу, которая запрашивает два числа у пользователя.
# После этого у каждого числа возьмите две последние цифры.
# Получившиеся два числа сложите и выведите на экран.
#
# Что оценивается
# Результат вычислений корректен.
# В input содержится корректное приглашение для ввода.
# Переменные имеют значащие названия.
# Есть пробелы после запятых и при бинарных операциях.

num1 = int(input('1-е число: '))
num2 = int(input('2-е число: '))
last1 = num1 % 100
last2 = num2 % 100
answer = last1 + last2
print(("1-й остаток: "), last1)
print(("2-й остаток: "), last2)
print(("Ответ: "), answer)
num1 = str(num1)
a = num1[0]
b = num1[1]
c = num1[2]
d = num1[3]
print(f"Строка из цифр: {d + c + b + a}")
print(f"Сумма цифр: {int(a) + int(b) + int(c) + int(d)}")


********************************************************************************

# Часть 1. Модуль 3. Задача 7. Режем число на части
#
# Реализуйте программу, которая получает на вход четырёхзначное число
# и выводит на экран каждую его цифру отдельно
# (в одну строчку либо каждую цифру в новой строчке).
# Само число при этом изменять нельзя, то есть нужно обойтись без переприсваивания.
# Однако можно использовать сколько угодно переменных.
#
# Что оценивается
# Результат вычислений корректен.
# В input содержится корректное приглашение для ввода.
# Есть пробелы после запятых и при бинарных операциях.

number = (input('Введите четырехзначное число: '))
for i in range(len(number)):
    print(number[i])


********************************************************************************

# Часть 1. Модуль 3. Задача 8. Поменять местами: не всё так просто! (необязательная, повышенной сложности)
#
# Вы уже умеете менять местами строковые переменные и знаете,
# что в переменных кроме строк можно хранить и числа. Напишите программу,
# которая меняла бы значения двух переменных местами, но без использования
# третьей переменной и синтаксического сахара, который мы разбирали, а именно:
# без конструкции a, b = b, a. В переменные будут вводиться только числа.
#
# a = int(input('Введите первое число: '))
# b = int(input('Введите второе число: '))
# print(a, b)
# # стереть эту строчку и вставить свой код здесь
# print(a, b)
#
# Изменять, удалять, менять местами первую, вторую, третью и последнюю строчки нельзя.
# В четвёртую строку можно вставлять сколько угодно кода, не трогая последний print.
#
# Что оценивается
# Результат вычислений корректен.
# Не используются swap и третья переменная.
# Не изменён вывод.
# В input содержится корректное приглашение для ввода.

a = int(input('Введите первое число: '))
b = int(input('Введите второе число: '))
print(a, b)
a = a + b
b = a - b
a = a - b
print(a, b)


********************************************************************************

# Часть 1. Модуль 4. Задача 1. Датчик погоды
#
# За окном квартиры стоит датчик погоды, который определяет, идёт ли дождь.
# Если идёт, датчик оповещает сообщением: «Пошёл дождь. Возьмите зонтик!»
#
# Напишите программу, которая получает на вход число 0 или 1.
# Единица означает, что дождь идёт. В таком случае выводите на экран сообщение:
# «Пошёл дождь. Возьмите зонтик!». Ноль означает, что дождя нет,
# в этом случае надо вывести сообщение «Дождя нет!»
#
# Пример 1:
# На улице идёт дождь? 1
# Пошёл дождь. Возьмите зонтик!
#
# Пример 2:
# На улице идёт дождь? 0
# Дождя нет!
#
# Что оценивается
# результат вывода корректен;
# input содержит корректное приглашение для ввода;
# переменные имеют значащие имена, а не только a, b, c, d (видео 2.3);
# правильное употребление пробелов после запятых и при бинарных операциях.

rain = int(input('На улице идёт дождь? Если да, введите 1: '))
if rain == 1:
    print('Пошёл дождь. Возьмите зонтик!')
else:
    print('Дождя нет!')


********************************************************************************

# Часть 1. Модуль 4. Задача 2. Поступление
#
# Напишите программу, которая запрашивает у пользователя результаты ЕГЭ по трём экзаменам,
# и проверяет, поступил ли он на бюджет. Проходной балл равняется 270.
# Выведите соответствующее сообщение.
#
# Пример 1:
# Введите количество баллов по русскому языку: 90
# Введите количество баллов по математике: 90
# Введите количество баллов по информатике: 90
# Поздравляю, ты поступил на бюджет!
#
# Пример 2:
# Введите количество баллов по русскому языку: 100
# Введите количество баллов по математике: 50
# Введите количество баллов по информатике: 70
# К сожалению, ты не прошёл на бюджет.
#
# Что оценивается
# input содержит корректное приглашение для ввода;
# результат вывода корректен;
# переменные имеют значащие имена, а не только a, b, c, d (видео 2.3);
# правильное употребление пробелов после запятых и при бинарных операциях.

discipline1 = int(input('Введите количество баллов по русскому языку: '))
discipline2 = int(input('Введите количество баллов по математике: '))
discipline3 = int(input('Введите количество баллов по информатике: '))
passing_grade = 120
if discipline1 + discipline2 + discipline3 >= passing_grade:
    print('Поздравляю, ты поступил на бюджет!')
else:
    print('К сожалению, ты не прошёл на бюджет.')


********************************************************************************

# Часть 1. Модуль 4. Задача 3. Следим за расписанием
#
# Напишите программу, которая проверяет, чётное ли число ввёл пользователь,
# и выводит соответствующее сообщение.
# Подсказка: для проверки чётности используйте оператор %.
#
# Что оценивается
# input содержит корректное приглашение для ввода;
# результат вывода корректен;
# переменные имеют значащие имена, а не только a, b, c, d (видео 2.3);
# правильное употребление пробелов после запятых и при бинарных операциях.

num = int(input('Какое сегодня число? '))
if (num % 2) == 0:
    print('Вася, надо работать!')
else:
    print('Вася, надо отдыхать!')


********************************************************************************

# Часть 1. Модуль 4. Задача 4. Калькулятор скидки
#
# Напишите программу, которая запрашивает три стоимости товара и вычисляет сумму чека.
# Если сумма чека превышает 10 000 руб., нужно вычесть из этой суммы скидку 10%
# (умножить на 10, разделить на 100). Итоговая сумма должна выводиться на экран.
#
# Что оценивается
# корректность вычислений и применения операций;
# input содержит корректное приглашение для ввода;
# переменные имеют значащие имена, а не только a, b, c, d (видео 2.3);
# правильное употребление пробелов после запятых и при бинарных операциях.

chair1 = int(input('Введите стоимость первого стула: '))
chair2 = int(input('Введите стоимость второго стула: '))
chair3 = int(input('Введите стоимость третьего стула: '))
sum = (chair1 + chair2 + chair3)
print (sum)
min = 10000
if sum >= min:
    sale = sum * 10 / 100
    print ('Размер скидки: ', sale)
else:
    print ('Сумма покупки для скидки недостаточная! Докупите еще на', min - sum)


********************************************************************************

# Часть 1. Модуль 4. Задача 5. Модуль числа
#
# Создайте программу, которая найдёт модуль очередного числа x.
# Если число x отрицательное, то она должна перевести его в положительное,
# а в конце на экране должен быть модуль введённого числа.
#
# Пример:
# Ввели 5, ответ 5
# Ввели −7, ответ 7
# Подсказка: в некоторых случаях достаточно переприсвоить переменную со знаком минус.
#
# Что оценивается
# результат вычислений корректен;
# input содержит корректное приглашение для ввода;
# формат вывода соответствует примеру (не выведено одно число без описания);
# переменные имеют значащие имена, а не только a, b, c, d (видео 2.3);
# правильное употребление пробелов после запятых и при бинарных операциях.

num = int(input('Введите число: '))
if num < 0:
    num = -num
print('Модуль числа:', num)


********************************************************************************

# Часть 1. Модуль 4. Задача 6. Игра в кубики
#
# Напишите программу: на вход в неё подаётся два числа.
# Если первое число больше или равно второму, то нужно вывести на экран
# их разность и отдельной строкой: «Игрок платит». В противном случае,
# вывести их сумму и отдельной строкой: «Владелец платит».
# Последней строкой на экран должна быть выведена фраза: «Игра окончена».
#
# Пример:
# Кубик Кости: 3
# Кубик владельца: 4
# Сумма: 7
# Владелец платит
# Игра окончена
#
# Рекомендация
# Обратите внимание на разный выигрыш, который получит игрок при разных исходах.
#
# Что оценивается
# результат вычислений корректен;
# input содержит корректное приглашение для ввода;
# формат вывода соответствует примеру (не выведено одно число без описания);
# переменные имеют значащие имена, а не только a, b, c, d (видео 2.3);
# правильное употребление пробелов после запятых и при бинарных операциях.

num1 = int(input('Введите баллы владельца: '))
num2 = int(input('Введите баллы игрока: '))
if num1 >= num2:
    print('Разница в баллах:', num1 - num2)
    print('Игрок платит')
else:
    print('Разница в баллах:', num2 - num1)
    print('Владелец платит')
print('Игра окончена!')


********************************************************************************

# Часть 1. Модуль 4. Задача 7. Хватит ли зарплаты
#
# Напишите программу, которая запрашивает у пользователя три числа:
# количество отработанных часов, остаток по кредиту и количество денег на еду.
# После этого рассчитывается зарплата по формуле.
# Если зарплата больше или равна сумме, которая требуется на кредит и еду,
# то выводится сообщение: «Часов хватает. Можно отдохнуть».
# В противном случае: «Часов не хватает. Придётся работать больше!»
#
# Пример:
# Введите отработанные часы: 80
# Введите остаток по кредиту: 1000
# Введите траты на еду: 5000
# Часов не хватает. Придётся работать больше!
#
# Что оценивается
# результат вычислений корректен;
# input содержит корректное приглашение для ввода;
# формат вывода соответствует примеру (не выведено одно число без описания);
# переменные имеют значащие имена, а не только a, b, c, d (видео 2.3);
# пробелы после запятых, пробелы при бинарных операциях.

hours = int(input('Количество отработанных часов: '))
credit = int(input('Остаток по кредиту: '))
eat = int(input('Сколько нужно денег на еду: '))
salary = 200 * hours / 2**3 + hours
print(f"Ваша зарплата: {salary}")
if salary >= (credit + eat):
    print('Часов хватает. Можно отдохнуть')
else:
    print('Часов не хватает. Придётся работать еще', round(((credit + eat) - salary) * hours / salary) + 1, 'часов')


********************************************************************************

# Часть 1. Модуль 4. Задача 8. Максимальное число (по желанию)
#
# Пользователь вводит три числа. Напишите программу,
# которая выводит на экран максимальное из этих трёх чисел (все числа разные).
# Используйте дополнительные переменные, если нужно.
#
# Что оценивается
# результат вычислений корректен;
# input содержит корректное приглашение для ввода;
# правильное употребление пробелов после запятых и при бинарных операциях.

num1 = int(input('Введите первое число: '))
num2 = int(input('Введите второе число: '))
num3 = int(input('Введите третье число: '))
if num1 > num2 and num1 > num3:
    print('Максимальное число: ', num1)
elif num2 > num1 and num2 > num3:
    print('Максимальное число: ',num2)
else:
    print('Максимальное число: ',num3)


********************************************************************************

# Часть 1. Модуль 5. Задача 1. Калькулятор опыта
#
# Напишите программу, которая определяет уровень персонажа в компьютерной игре.
# Пользователь вводит число «очков опыта», а программа вычисляет уровень.
# Новый уровень даётся при достижении 1000, 2500 и 5000 «очков опыта».
# Начальный уровень равен единице.
#
# Пример:
# Введите количество опыта: 6000
# Ваш уровень: 4
# Пример 2:
# Введите количество опыта: 2000
# Ваш уровень: 2
#
# Советы и рекомендации
# По возможности уделите внимание сокращению кода.
# Постарайтесь не проверять условия, которые уже проверены:
# если вы проверили условие condition, то не следует проверять not condition.
#
# Что оценивается
# результат вывода корректен, особое внимание уделено границам диапазонов;
# input содержит корректное приглашение для ввода;
# переменные имеют значащие имена, а не только a, b, c, d (видео 2.3);
# правильное употребление пробелов после запятых и при бинарных операциях;
# правильно оформлены блоки if-elif-else, отступы одинаковы во всех блоках одного уровня.


experience = int(input('Введите кол-вол очков опыта: '))
if (experience >= 1000) and (experience < 2500):
    level = 2
elif (experience >= 2500) and (experience < 5000):
    level = 3
elif (experience >= 5000):
    level = 4
else:
    level = 1
print('Уровень персонажа', level)


********************************************************************************

# Часть 1. Модуль 5. Задача 2. Функция
#
# Напишите программу, которая получает от пользователя число X
# и вычисляет значение функции Y по следующей схеме:
# y= {x −12, x>0, 5,  x=0 x2,  x<0
#
# Напомним, как это работает:
# для X > 0, Y = X − 12
# для X = 0,  Y = 5
# для X < 0, Y = X2
#
# Пример:
# Введите икс: 0
# Игрек равен 5
#
# Пример 2:
# Введите икс: −6
# Игрек равен 36
#
# Советы и рекомендации
# По возможности уделите внимание сокращению кода.
# Избегайте проверки условий, которые уже проверены:
# если вы проверили условие condition, то не следует проверять not condition.
#
# Что оценивается
# результат вывода корректен;
# input содержит корректное приглашение для ввода;
# переменные имеют значащие имена, а не только a, b, c, d (видео 2.3);
# правильное употребление пробелов после запятых при бинарных и логических операциях;
# правильно оформлены блоки if-elif-else, отступы одинаковы во всех блоках одного уровня.

x = int(input('Введите значение аргумента х:'))
if x > 0:
    y = x - 12
elif x < 0:
    y = x ** 2
else:
    y = 5
print('Значение функции y(х) =', y)


********************************************************************************

# Часть 1. Модуль 5. Задача 3. Поступление
#
# Напишите программу, которая получает на вход место студента в списке и его балл,
# а затем выводит соответствующие сообщения о поступлении и получении стипендии.
#
# Пример 1:
# Введите место в списке поступающих: 3
# Введите количество баллов за экзамены: 295
# Поздравляем, вы поступили!
# Бонусом вам будет начисляться стипендия.
#
# Пример 2:
# Введите место в списке поступающих: 3
# Введите количество баллов за экзамены: 270
# Поздравляем, вы поступили!
# Но вам не хватило баллов для стипендии.
#
# Пример 3:
# Введите место в списке поступающих: 11
# К сожалению, вы не поступили.
#
# Что оценивается
# результат вывода корректен и соответствует примеру;
# input содержит корректное приглашение для ввода;
# переменные имеют значащие имена, а не только a, b, c, d (видео 2.3);
# правильное употребление пробелов после запятых при бинарных и логических операциях;
# правильно оформлены блоки if-elif-else, отступы одинаковы во всех блоках одного уровня.

num = int(input('Введите место студента в списке: '))
if (num <= 10):
    print('Студент поступил')
    point = int(input('Введите кол-во его баллов: '))
    if point >= 290:
        print('Студент будет получать стипендию')
    else:
        print('Студент не будет получать стипендию')
else:
    print('Студент не поступил.')


********************************************************************************

# Часть 1. Модуль 5. Задача 4. Опять двойка
#
# Папа-программист настолько обленился, что вместо того, чтобы спросить у сына,
# какую оценку тот получил в школе, он написал программу:
#
# rating = int(input('Что получил по математике? '))
# if rating == 2:
#    print('Плохо. Марш учиться!')
# if rating == 3:
#    print('Плохо. Марш учиться!')
# if rating == 4:
#    print('Молодец! Можешь отдохнуть.')
# if rating == 5:
#    print('Молодец! Можешь отдохнуть.')
# Сын посмотрел на код программы и понял, что её можно улучшить.
# Он даже рассказал папе, как это сделать, за что получил безграничное уважение отца.
#
# Скопируйте программу в редактор и оптимизируйте:
#
# При плохой оценке (2 или 3) выводится сообщение: «Плохо. Марш учиться!»
# При хорошей оценке (4 или 5) выводится сообщение: «Молодец! Можешь отдохнуть».
# В программе не должно быть повторяющихся строк.
#
# Что оценивается
# В программе отсутствуют повторяющиеся строки.

rating = int(input('Что получил по математике? '))
if (rating == 2) or (rating == 3):
    print('Плохо. Марш учиться!')
elif (rating == 4) or (rating == 5):
    print('Молодец! Можешь отдохнуть.')
else:
    print('Такой оценки не бывает!')


********************************************************************************

# Часть 1. Модуль 5. Задача 5. Вася хочет выигрывать
#
# Вася вдохновился фильмом «Двадцать одно» и решил изучить математику игровых автоматов.
# Для анализа данных ему нужна информация о том, как часто в автомате выпадает три или две
# одинаковых картинки. Для сбора данных нужна программа, проверяющая это равенство.
#
# Даны три целых числа. Определите, сколько среди них совпадающих.
# Программа должна вывести одно из чисел: 3 (если все совпадают),
# 2 (если два совпадают) или 0 (если все числа разные).
#
# Советы и рекомендации
# По возможности уделите внимание сокращению кода.
# Избегайте проверки условий, которые уже проверены:
# если вы проверили условие condition, то не следует проверять not condition.
#
# Что оценивается
# input содержит корректное приглашение для ввода;
# в выводе может быть указано только число, но хорошим стилем считается описание вывода;
# правильное употребление пробелов после запятых при бинарных и логических операциях;
# правильно оформлены блоки if-elif-else, отступы одинаковы во всех блоках одного уровня.

num1 = int(input('Введите 1-е число: '))
num2 = int(input('Введите 2-е число: '))
num3 = int(input('Введите 3-е число: '))
if (num1 == num2) and (num1 == num3):
    print('3')
elif (num1 == num2) or (num1 == num3) or (num2 == num3):
    print('2')
else:
    print('0')


********************************************************************************

# Часть 1. Модуль 5. Задача 6. Новоселье
#
# Есть два варианта:
# Выбрать квартиру попросторнее (не менее 100 м2), но стоимостью не более 10 млн.
# Немного расширить круг поиска, то есть выбрать квартиру поменьше (от 80 м2),
# но и стоимостью не более 7 млн.
# Напишите программу, которая получает на вход стоимость квартиры и
# её площадь и выводит сообщение, подходит ли она.
#
# Что оценивается
# результат вычислений корректен;
# input содержит корректное приглашение для ввода;
# в выводе программы указано, подходит ли данный параметр;
# переменные имеют значащие имена, а не только a, b, c, d (видео 2.3);
# правильное употребление пробелов после запятых и при бинарных операциях.

price = int(input('Введите стоимость квартиры, млн. руб: '))
square = int(input('Введите площадь квартиры, м^2: '))
if (square >= 100 and price <= 10) or (square >= 80 and price <= 7):
    print('Квартира подходит.')
else:
    print('Квартира не подходит.')


********************************************************************************

# Сравнивает результаты двух альтернативных решений одной задачи:

num1 = int(input('Введите 1-е число: '))
num2 = int(input('Введите 2-е число: '))
num3 = int(input('Введите 3-е число: '))

all_equal, some_equal, not_equal = 3, 2, 0

def var1() -> int:
    is_equal_12 = (num1 == num2)
    is_equal_13 = (num1 == num3)
    is_equal_23 = (num2 == num3)

    if is_equal_12 and is_equal_13:
        return all_equal
    elif is_equal_12 or is_equal_13 or is_equal_23:
        return some_equal
    else:
        return not_equal

def var2(inputs: list[int]) -> int:
    set_inputs = set(inputs)

    if len(set_inputs) == 1:
        return all_equal
    elif len(set_inputs) == 3:
        return not_equal
    else:
        return some_equal


if __name__ == '__main__':
    result_var1 = var1()
    result_var2 = var2([num1, num2, num3])

    print(result_var1)
    print(result_var2)
    assert result_var1 == result_var2


********************************************************************************

# Часть 1. Модуль 5. Задача 7. Почта
#
# Почтовое отделение открывается в 08:00 и закрывается в 22:00.
# С 14:00 до 15:00 все сотрудники уходят на обед, а в 10:00 и 18:00
# приезжают машины с посылками, и все сотрудники на два часа заняты их разгрузкой.
# Во время обеда и разгрузки машин  посылки никто не выдаёт.
#
# Напишите программу, которая получает на вход время в часах —
# число от 0 до 23 — и пишет, можно ли в этот час получить посылку.
# спользуйте только один условный оператор if-else, без elif и прочих.
# Решите задание двумя способами:
#
# При выполнении условия выводится сообщение: «Можно получить посылку».
# При выполнении условия выводится сообщение: «Посылку получить нельзя».
# Советы и рекомендации
# Обратите внимание на количество условий и постарайтесь сократить их.
# Не используйте перечисление конкретных часов вида a == 1 and a == 2...
#
# Что оценивается
# результат вычислений корректен;
# input содержит корректное приглашение для ввода;
# переменные имеют значащие имена, а не только a, b, c, d (видео 2.3);
# правильное употребление пробелов после запятых и при бинарных операциях.

time = int(input('Введите время, ч: '))

def task_5_7():
    if (8 >= time < 10) or (12 >= time < 14) or (15 >= time < 18) or (20 >= time < 22):
        print('Можно получить посылку.')
    else:
        print('Посылку получить нельзя.')

def task_5_7_2():
    if not (8 <= time < 22) or (10 <= time <= 12) or (14 <= time <= 15) or (18 <= time <= 20):
       print('Посылку получить нельзя.')
    else:
       print('Можно получить посылку.')

task_5_7()
task_5_7_2()


********************************************************************************

# Альтернативное решение. Часть 1. Модуль 5. Задача 7. Почта
#
# Получает на вход время в часах — число от 0 до 23 — и пишет, можно ли в этот час получить посылку.

hour = int(input("Введите время в часах: "))

work_hours = (8, 22)
start_work = 8
end_work = 22
lunch_break_hours = [14, 15, 10, 18]

def chat_options():
    print("chat version")
    if hour < 8 or hour >= 22:
        print('Посылку получить нельзя')
    elif hour == 14:
        print('Посылку получить нельзя')
    elif hour == 15:
        print('Посылку получить нельзя')
    elif hour == 10:
        print('Посылку получить нельзя')
    elif hour == 18:
        print('Посылку получить нельзя')
    else:
        print("Можно получить посылку")

def first_option():
    print("first version")   
    if hour >= 8 and hour < 18 and hour != 10 and hour != 11 and hour != 12 and hour != 14 and hour != 15:
      print('Можно получить посылку.')
    else:
      print('Посылку получить нельзя.')
    print()

def other_option():
    print("other version")      
    is_too_late = hour >= end_work
    is_too_early = hour < start_work

    if is_too_early or is_too_late:
        print('Посылку получить нельзя')
    elif hour in lunch_break_hours:
        print('Посылку получить нельзя')
    else:
        print('Можно получить посылку')


if __name__ == '__main__':
    chat_options()
    first_option()
    other_option()


********************************************************************************

# Часть 1. Модуль 6. Задача 1. Кубы чисел
#
# Напишите программу, которая возводит в третью степень каждое число
# от 1 до N и выводит результат на экран.
#
# Что оценивается
# Результат вывода корректен, решение использует цикл while.
# Input содержит корректное приглашение для ввода.
# Переменные имеют значащие имена, не только a, b, c, d (видео 2.3).
# Правильное употребление пробелов после запятых и при бинарных операциях.

N = int(input('Введите N: '))
count = 1
while count <= N:
    print(count, '^3 = ', count ** 3)
    count += 1


********************************************************************************

# Часть 1. Модуль 6. Задача 2. Коллекторы
#
# Напишите робота для коллекторов.
# В самом начале он спрашивает имя должника и сумму долга,
# а затем начинает требовать у него погашения до тех пор,
# пока должник не введёт нужную сумму (равную сумме долга или больше).
# После погашения долга робот сообщает об этом пользователю и благодарит его.
#
# Пример
# Василий, ваша задолженность составляет 100 рублей.
# Сколько рублей вы внесёте прямо сейчас, чтобы её погасить? 50
# Маловато, Василий. Давайте ещё раз.
# Сколько рублей вы внесёте прямо сейчас, чтобы её погасить? 90
# Маловато, Василий. Давайте ещё раз.
# Сколько рублей вы внесёте прямо сейчас, чтобы её погасить? 110
# Отлично, Василий! Вы погасили долг. Спасибо!
#
# Рекомендация
# Обратите внимание: считать сумму внесённых средств не нужно, это не соответствует условию задачи.
#
# Что оценивается
# Input содержит корректное приглашение для ввода.
# Результат вывода корректен.
# Переменные имеют значащие имена, не только a, b, c, d (видео 2.3).
# Правильное употребление пробелов после запятых и при бинарных операциях.

debtor = input('Введите имя должника: ')
indebted = int(input('Введите сумму долга: '))
print(debtor, ', ваша задолженность составляет', indebted, 'рублей.')
balance = int(0)
while balance < indebted:
    balance = int(input('Сколько рублей вы внесёте прямо сейчас, чтобы её погасить?: '))
    if balance < indebted:
        print('Маловато,', debtor, '. Давайте ещё раз.')
    else:
        print('Отлично,', debtor, ', Вы погасили долг. Спасибо!')


********************************************************************************

# Часть 1. Модуль 6. Задача 3. Слишком большие числа
#
# У неудачливого бухгалтера всё опять идёт наперекосяк:
# ему приносят такие большие счета, что числа не помещаются на бумаге.
# Напишите программу, которая считала бы для него, сколько цифр во вводимом числе.
# Обратите внимание, что число 0 имеет одну цифру.
#
# Что оценивается
# Input содержит корректное приглашение для ввода.
# Результат вывода корректен, правильно подсчитано количество цифр в числе.
# Переменные имеют значащие имена, не только a, b, c, d (видео 2.3).
# Правильное употребление пробелов после запятых и при бинарных операциях.
# Используется цикл while.
# Решение не использует работу со строками и операции над ними.

number = int(input('Введите число: '))
remnant = 0
count = 0
n = 10
while remnant != number:
    remnant = number % n
    n = n * 10
    count += 1
print('Цифр в числе:', count)


********************************************************************************

# Часть 1. Модуль 6. Задача 4. Поставьте оценку!
#
# Напишите программу, которая находит количество положительных и
# количество отрицательных чисел в последовательности.
# Последовательность заканчивается на числе 0.
#
# Пример
# Введите число: −4
# Введите число: −90
# Введите число: 6
# Введите число: 0
# Кол-во положительных чисел: 1
# Кол-во отрицательных чисел: 2
#
# Что оценивается:
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Input содержит корректное приглашение для ввода.
# Ввод чисел осуществляется внутри цикла.
# При вводе 0 происходит выход из цикла и производится вывод подсчитанных положительных и отрицательных чисел.
# Переменные имеют значащие имена, не только a, b, c, d (видео 2.3).
# Правильное употребление пробелов после запятых и при бинарных операциях.

count1 = 0
count2 = 0

while True:
    num = int(input('Введите число от -100 до 100 (для выхода намите 0): '))
    if num == 0:
        break
    elif num > 0:
        count1 += 1
    else:
        count2 += 1

print('Кол-во положительных чисел: ', count1)
print('Кол-во отрицательных чисел: ', count2)


********************************************************************************

# Часть 1. Модуль 6. Задача 5. Обычный день на работе
#
# Максим программирует целый день на работе и вечером идёт домой. Каждый час начальство кидает ему несколько задач, которые нужно решить до следующего рабочего часа. Вдобавок каждый час Максиму звонит супруга. Он знает, что если он возьмёт трубку, то жена попросит зайти вечером в магазин.
#
# Напишите программу, в которой считается, сколько задач выполнил Максим за день (восемь часов). Если он хотя бы раз взял трубку, то в конце дополнительно выводите сообщение: «Нужно зайти в магазин».
#
# Пример
# Начался восьмичасовой рабочий день.
# 1-й час
# Сколько задач решит Максим? 1
# Звонит жена. Взять трубку? (1 — да, 0 — нет): 0
#
# 2-й час
# Сколько задач решит Максим? 2
# Звонит жена. Взять трубку? (1 — да, 0 — нет): 0
#
# 3-й час
# Сколько задач решит Максим? 3
# Звонит жена. Взять трубку? (1 — да, 0 — нет): 0
#
# 4-й час
# Сколько задач решит Максим? 4
# Звонит жена. Взять трубку? (1 — да, 0 — нет): 1
#
# 5-й час
# Сколько задач решит Максим? 5
# Звонит жена. Взять трубку? (1 — да, 0 — нет): 0
#
# 6-й час
# Сколько задач решит Максим? 1
# Звонит жена. Взять трубку? (1 — да, 0 — нет): 0
#
# 7-й час
# Сколько задач решит Максим? 2
# Звонит жена. Взять трубку? (1 — да, 0 — нет): 1
#
# 8-й час
# Сколько задач решит Максим? 3
# Звонит жена. Взять трубку? (1 — да, 0 — нет): 0
# Рабочий день закончился. Всего выполнено задач: 21
# Нужно зайти в магазин.
#
# Что оценивается
# Input содержит корректное приглашение для ввода.
# Формат вывода соответствует примеру.
# Число итераций не превосходит число рабочих часов.
# Используется флаг для учёта факта звонка жены.
# Переменные имеют значащие имена, не только a, b, c, d (видео 2.3).
# Правильное употребление пробелов после запятых и при бинарных операциях.

count = 0
call_check = False
print('Начался рабочий день.')

i = 0
while i < 8:
    i += 1
    print(i, '-й час.')
    task = int(input('Сколько задач решит Максим? '))
    count += task
    call = int(input('Звонит жена. Взять трубку? (1 — да, 0 — нет): '))
    if call == 1:
        call_check = True

print('Рабочий день закончился. Всего выполнено задач: ', count)

if call_check == True:
    print('Нужно зайти в магазин.')
else:
    print('Максим, перезвоните жене!')


********************************************************************************

# Часть 1. Модуль 6. Задача 6. Вклады
#
# Вклад в банке составляет X рублей. Ежегодно он увеличивается на P процентов,
# после чего дробная часть копеек отбрасывается.
# Определите, через сколько лет вклад составит не менее Y рублей.
#
# Напишите программу, которая по данным числам X, Y, P определяет,
# сколько лет пройдёт, прежде чем сумма достигнет значения Y.
#
# Что оценивается:
# Результат вычислений корректен.
# Input содержит корректное приглашение для ввода.
# Переменные имеют значащие имена, не только a, b, c, d (видео 2.3).
# Правильное употребление пробелов после запятых и при бинарных операциях.

contribution_start = int(input('Введите сумму вклада: '))
contribution_final = int(input('Введите желаемую сумму: '))

if contribution_final < contribution_start:
    print('Вам нужно снять деньги в размере', contribution_start - contribution_final)
else:
    percent = int(input('Введите годовой процент по вкладу от 0 до 100: '))
    count = 1
    while contribution_start <= contribution_final:
        contribution_start = contribution_start + contribution_start * percent / 100
        contribution_start = contribution_start // 1
        print('Через', count, 'лет у вас будет: ', contribution_start)
        count += 1
    print('Нужная сумма в размере', contribution_final, 'руб. наберется через', count - 1, 'лет.')


********************************************************************************

# Часть 1. Модуль 6. Задача 7. Игра «Угадай число»
#
# Напишите программу-игру, которая запрашивает у пользователя число
# до тех пор, пока он его не отгадает.
# Выводите сообщения в соответствии с примером.
#
# Пример (загадали число 7)
# Введите число: 3
# Число меньше, чем нужно. Попробуйте ещё раз!
# Введите число: 10
# Число больше, чем нужно. Попробуйте ещё раз!
# Введите число: 8
# Число больше, чем нужно. Попробуйте ещё раз!
# Введите число: 7
# Вы угадали! Число попыток: 4
#
# Что оценивается
# Формат вывода соответствует заданию.
# Input содержит корректное приглашение для ввода.
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3).
# Правильное употребление пробелов после запятых и при бинарных операциях

hidden_number = 6
count = 0

while True:
    count += 1
    number = int(input('Введите число от 1 до 10: '))
    if number == hidden_number:
        print('Вы угадали! Число попыток: ', count)
        break
    elif number > hidden_number:
        print('Число больше, чем нужно. Попробуйте ещё раз!')
    else:
        print('Число меньше, чем нужно. Попробуйте ещё раз!')


********************************************************************************

# Часть 1. Модуль 6. Задача 8. Игра «Компьютер угадывает число»
#
# Напишите программу, которая с помощью цепочки таких вопросов и ответов мальчика угадывает число.
# Cделайте так, чтобы можно было гарантированно угадать число за семь попыток.
#
# Подсказка
# При желании найдите описание алгоритма бинарного поиска и попробуйте применить в этой задаче. Разбор подобного решения будет в следующем модуле.
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректное приглашение для ввода.
# Правильное употребление пробелов после запятых и при бинарных операциях.

# Решение 1:
def task_6_8_1():
    list_excess = []
    a, b, count = 1, 100, 0

    while True:
        count += 1
        N = (a + b) // 2
        list_excess.append(N)
        print()
        print('N =', N)
        answer = int(input('Твоё число равно(1), больше(2) или меньше(3) N?  '))
        if (answer == 2) and N == 99:
            N += 1
        if answer == 1:
            print()
            print('Я угадал! Это', N)
            print('Использовано попыток:', count)
            print(list_excess)
            break
        elif answer == 2:
            a = N + 1
        elif answer == 3:
            b = N - 1

# Решение 2:
def task_6_8_2():
    count = 0
    sec = int(input('Загадайте число: '))
    mn, mx = 1, 100
    tr, key = 0, 0
    
    while True:
        count += 1
        tr = (mx + mn) // 2
        print('Твое число: 1 - равно, 2 - больше или 3 - меньше, чем число', tr)
        key = int(input('Введите ответ: '))
        if key == 1:
            print('Угадал за', count, 'попыток')
            break
        elif key == 2:
            mn = tr
        elif key == 3:
            mx = tr

task_6_8_1()


********************************************************************************

# Альтернативное решение. Часть 1. Модуль 6. Задача 8. Игра «Компьютер угадывает число»
#
# Пользователь задумывает натуральное число от 1 до 100,
# компьютер угадывает его максимум за 7 попыток.

def guess_number():

    list_excess = []
    a, b, count = 1, 100, 0

    while True:
        count += 1
        N = (a + b) // 2
        list_excess.append(N)
        print()
        print('N =', N)
        answer = int(input('Твоё число равно(1), больше(2) или меньше(3) N? '))
        if (answer == 2) and N == 99:
            N += 1
        if answer == 1:
            print()
            print('Я угадал! Это', N)
            print('Использовано попыток:', count)
            print(list_excess)
            break
        elif answer == 2:
            a = N + 1
        elif answer == 3:
            b = N - 1
        else:
            print('Так не честно!')
            break
def main_menu():
    choice = input('\nЗагадайте число от 1 до 100. Спорим, я угадаю его за 7 попыток?\n'
                   'Если играем, введите - 1\nНет - 0\nВаш выбор: ')
    if choice == '1':
        guess_number()
    else:
        print('Жаль((( До следующей встечи!')

main_menu()


********************************************************************************

# Часть 1. Модуль 7. Задача 1. Должники
#
# Напишите программу, которая при вводе десяти чисел определяет,
# сколько из них являются одновременно чётными и положительными.
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# переменные имеют значащие имена, не только a, b, c, d;
# задача решена с помощью конструкции for

count = 0
for i in range(10):
    number = int(input('Введите число: '))
    if number % 2 == 0 and number > 0:
        count += 1
print('Четных и положительных чисел: ', count)


********************************************************************************

# Часть 1. Модуль 7. Задача 2. Посчитай чужую зарплату...
#
# Напишите программу, которая принимает от пользователя зарплату сотрудника
# за каждый из 12 месяцев и выводит на экран среднюю зарплату за год.
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# вывод содержит описание результата (не выведено одно число без описания);
# переменные имеют значащие имена, не только a, b, c, d;
# задача решена с помощью конструкции for

medium_salary = 0
for i in range(12):
    print('Введите зарплату за: ', i + 1, '-й месяц: ')
    salary = int(input())
    medium_salary += salary
medium_salary /= 12
print()
print('Средняя зарплата за 12 месяцев: ', medium_salary)


********************************************************************************

# Часть 1. Модуль 7. Задача 3. Факториал
#
# Мы всё ближе и ближе подбираемся к серьёзной математике.
# Одна из классических задач — задача на нахождение факториала числа.
# И в будущем мы с ней ещё встретимся.
# Дано натуральное число n. Напишите программу, которая находит n! (n-факториал).
# Запись n! означает следующее:
# n! = 1 * 2 * 3 * 4 * 5 * … * n
#
# Пример:
# Введите число: 5
# Факториал числа 5 равен 120
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# формат вывода соответствует примеру;
# вывод содержит описание, не только результат в виде числа;
# для решения используется цикл for, а не встроенные функции или рекурсия;
# переменные имеют значащие имена, не только a, b, c, d.

import math

my_factorial = 1
n = int(input('Введите число: '))

for i in range(1, n):
    my_factorial = n * my_factorial
    n -= 1

print('n! = ', my_factorial)

print('Проверка модулем: ', n, '! = ', math.factorial(n))


********************************************************************************

# Альтернативное решение. Часть 1. Модуль 7. Задача 3. Факториал

import math

def is_positive(number: int) -> bool:
    return number < 0

def is_float(number: int) -> bool:
    return isinstance(number, float)

def factorial_number(number: int):
    if is_positive(number):
        raise ValueError(f"Факториал вычисляется только от натурального числа, а это отрицательное!")
    elif is_float(number):
        raise ValueError(f"Факториал вычисляется только от натурального числа, а это дробное!")

    return math.factorial(number)


if __name__ == '__main__':
    test_cases = [
        (-1),
        (0),
        (1),
        (3),
        (1.5),
        (5)
    ]

    for number in test_cases:
        try:
            result_factorial = factorial_number(number)
            print(f"{number}! = {result_factorial}")
        except ValueError as e:
            print(e)


********************************************************************************

# Часть 1. Модуль 7. Задача 4. Успеваемость в классе
#
# В классе N человек. Каждый из них получил за урок по информатике оценку: 3, 4 или 5, двоек сегодня не было.
# Напишите программу, которая получает список оценок — N чисел — и выводит на экран
# сообщение о том, кого сегодня больше: отличников, хорошистов или троечников.
#
# Замечание: можно предположить, что количество отличников, хорошистов, троечников различно.
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# в выводе присутствует сообщение о том, кого больше;
# для решения используется цикл for, а не встроенные функции или рекурсия;
# переменные имеют значащие имена, не только a, b, c, d.

string_mark = input('Введите оценки учеников подряд без разделителей: ')

# Решение 1:
def task_7_4_1():

    list_mark = []
    flag = False
    
    for i in string_mark:
        i = int(i)
        list_mark.append(i)
        if i != 3 and i != 4 and i != 5:
            flag = True
    if flag is True:
        print('В классе не должно быть учеников с отметками, отличными от 3, 4 или 5. Поэтому их мы не засчитываем.')
   
    normal = list_mark.count(3)
    good = list_mark.count(4)
    excellent = list_mark.count(5)
    
    if normal > good and normal > excellent:
        print('Сегодня больше всего троешников, их', normal)
    elif good > normal and good > excellent:
        print('Сегодня больше всего хорошистов: их', good)
    elif excellent > normal and excellent > good:
        print('Сегодня больше всего отличников: их', excellent)
    elif normal == good and good == excellent:
        print('Сегодня всех по', normal)
    else:
        if normal == good:
            print('Троешников и хорошистов по', normal)
        elif normal == excellent:
            print('Троешников и отличников по', normal)
        else:
            print('Хорошистов и отличников по', good)
   
    print('Подробно:')
    print('Сегодня получили оценки n учеников.')
    list_mark.sort()
    print(list_mark)
    print('Троешников: ', list_mark.count(3))
    print('Хорошистов: ', list_mark.count(4))
    print('Отличников: ', list_mark.count(5))

# Решение 2:

def task_7_4_2():
    
    n = len(string_mark)
    list_mark = []
    flag = False
    
    for i in range (0,n):
        list_mark.insert(i, string_mark[i])
        if int(string_mark[i]) != 3 and int(string_mark[i]) != 4 and int(string_mark[i]) != 5:
            flag = True
    if flag is True:
        print('В классе не должно быть учеников с отметками, отличными от 3, 4 или 5.')
        
    normal = list_mark.count('3')
    good = list_mark.count('4')
    excellent = list_mark.count('5')
    
    if normal > good and normal > excellent:
        print('Сегодня больше всего троешников, их', normal)
    elif good > normal and good > excellent:
        print('Сегодня больше всего хорошистов: их', good)
    elif excellent > normal and excellent > good:
        print('Сегодня больше всего отличников: их', excellent)
    elif normal == good and good == excellent:
        print('Сегодня всех по', normal)
    else:
        if normal == good:
            print('Троешников и хорошистов по', normal)
        elif normal == excellent:
            print('Троешников и отличников по', normal)
        else:
            print('Хорошистов и отличников по', good)
            
    print('Подробно:')
    print('Сегодня получили оценки', n,'учеников.')
    list_mark.sort()
    print(list_mark)
    print('Троешников: ', list_mark.count('3'))
    print('Хорошистов: ', list_mark.count('4'))
    print('Отличников: ', list_mark.count('5'))

task_7_4_1()
# task_7_4_2()


********************************************************************************

# Часть 1. Модуль 7. Задача 5. Отрезок
#
# Напишите программу, которая считывает с клавиатуры два числа:
# a и b, — считает и выводит в консоль среднее арифметическое всех чисел
# из отрезка [a; b], кратных числу 3.
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# в выводе присутствует описание результата;
# для решения используется конструкция for.

a = int(input('Введите начало отрезка: '))
b = int(input('Введите конец отрезка: '))
multiple_three, count = 0, 0

for n in range(a, b + 1):
    if n % 3 == 0:
        multiple_three += n
        count += 1
print('Среднее арифметическое чисел, кратных трем на данном отрезке: ', multiple_three / count)


********************************************************************************

# Часть 1. Модуль 7. Задача 6. Замечательные числа
#
# Напишите программу, которая находит и выводит все двузначные числа,
# \равные утроенному произведению своих цифр. К таким относятся, например, 15 и 24.
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# допускается вывод без описания, достаточно вывести числа;
# переменные имеют значащие имена, не только a, b, c, d

for n in range(10, 100):
    if n == (n // 10) * (n % 10) * 3:
        print(n)


********************************************************************************

# Часть 1. Модуль 7. Задача 7. Пропавшая карточка
#
# Для настольной игры используются карточки с номерами от 1 до N.
# Одна карточка потерялась. Напишите программу, которая поможет найти потерянную карточку,
# если номера оставшихся известны. Найдите её, зная номера оставшихся карточек.
#
# Введите число карточек — N.
# Затем введите N − 1 номера оставшихся карточек. Они могут быть введены в любом порядке.
#
# Пример:
# Введите количество карточек: 5
# Введите номер оставшейся карточки: 1
# Введите номер оставшейся карточки: 4
# Введите номер оставшейся карточки: 5
# Введите номер оставшейся карточки: 3
# Номер пропавшей карточки: 2
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# input содержат корректные приглашения для ввода;
# переменные имеют значащие имена, не только a, b, c, d.

string_card = input('Введите через запятую без пробела номера оставшихся карточек: ')
sum_available_cards = int(0)
sum_all_card = int(0)
list_card = string_card.split(',')
available_cards = int(len(list_card))

for i in range(0, available_cards):
    i = int(i)
    sum_available_cards += int(list_card[i])
for i in range(1, available_cards + 2):
    sum_all_card += i

result = int(sum_all_card - sum_available_cards)
print('Потерянная карточка имеет номинал: ', result)


********************************************************************************

# Часть 1. Модуль 8. Задача 1. Космическая еда
#
# Ваш космический корабль потерпел крушение на пустынной планете.
# Еда здесь не растёт, но вы спасли из обломков 100-килограммовый мешок гречки.
# Из прошлого опыта вы знаете, что если будете экономно питаться, то у вас будет
# уходить по четыре килограмма гречки в месяц.
#
# Чтобы прикинуть гречневый бюджет, вы решили написать программу,
# которая выведет информацию о том, сколько килограммов гречки у вас должно быть в запасе
# через месяц, два и так далее, пока она не закончится. Используйте цикл for.
#
# Что оценивается
# Задача решена успешно, если:
# результат вывода соответствует условию;
# для решения использован цикл for и range c шагом;
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3).

buckwheat_start = int(input('Сколько у вас килограммов гречки на старте? '))
buckwheat_cons = int(input('Какой месячный расход гречки? '))
month = int(0)

for month_buckwheat_cons in range(
        buckwheat_start - buckwheat_cons, -1, -buckwheat_cons):
    month += 1
    print('Через', month, 'у вас останется', month_buckwheat_cons)
print()


********************************************************************************

# Часть 1. Модуль 8. Задача 2. Долги
#
# Напишите программу, которая получает данные о количестве должников,
# а затем спрашивает у каждого пятого (начиная с нуля) его долг.
# В конце выводится общая сумма долгов.
#
# Пример 1
# Введите количество должников: 13
# Должник с номером 0
# Сколько должны? 1000
# Должник с номером 5
# Сколько должны? 5000
# Должник с номером 10
# Сколько должны? 2000
# Общая сумма долга: 8000
#
# Пример 2
# Введите количество должников: 10
# Должник с номером 0
# Сколько должны? 1000
# Должник с номером 5
# Сколько должны? 5000
# Общая сумма долга: 6000
#
# Что оценивается
# Задача решена успешно, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# в выводе присутствует общая сумма долга;
# формат вывода соответствует примеру (не выведены числа без описания);
# для решения использован цикл for и range c шагом;
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3).

total_debtors = int(input('Сколько всего должников? '))
total_sum = 0

for debtors in range(0, total_debtors, 5):
    print(debtors)
    sum = int(input('Сообщите компьютеру сумму вашего долга: '))
    print()
    total_sum += sum

print('Сумма долга: ', total_sum)


********************************************************************************

# Часть 1. Модуль 8. Задача 3. Микроволновка
#
# Мы разрабатываем микропрограмму — таймер обратного отсчета для микроволновых печей.
# Некоторым пользователям не нравится пищащий звук.
#
# Есть задача убрать звук по готовности и заменить его сообщением на LED-экране.
# В нашем случае будем выводить в консоль сообщение с обратным отсчетом
# в секундах от “reverse_timer” до момента готовности, то есть «0» секунд,
# и спрашивать пользователя, готов ли он забрать еду.
#
# Пользователь в любой момент может прервать режим разогрева,
# введя «1» (то есть ответить «Да, еда готова»),
# тогда программа выводит на экран сообщение «Ваша еда готова,
# можете забрать» и показывает, на какой секунде был прерван таймер.
#
# Если пользователь отвечает «0», что равноценно «Нет», то таймер уменьшается.
# Когда он достигнет «0» секунд, выводим сообщение «Ваша еда готова, осторожно горячo!»
#
# В данном задании используем цикл for.
#
# “reverse_timer” – переменная счетчик, значение которой запрашиваем у пользователя через функцию ввода input.
#
# Задайте время до обнуления таймера.
# Используйте цикл for.
# На каждой итерации задавайте персонажу вопрос, хочет ли он сейчас остановить разогрев или нет.
#
# Что оценивается
# Задача решена успешно, если:
# результат вывода соответствует условию;
# вывод содержит обратный отсчёт до самого конца или до того момента, когда пользователь решит остановить разогрев;
# задача решена с помощью цикла for, возможно, с range и отрицательным шагом;
# input содержит корректное приглашение для ввода;
# последней секундой считается 1;
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3).

reverse_timer = int(input('Ввведите время разогрева: '))

pause = 0

for sec in range(reverse_timer, 0, -1):
    print('Микроволновка греет ', reverse_timer - sec)
    print('Осталось ', sec)
    pause = int(input('Если хотите остановить разогрев, введите 1: '))
    if pause == 1:
        print('Ваша еда готова, можете забрать. Прошло секунд: ', reverse_timer - sec)
        break
    if sec == 1:
        print('Микроволновка грела ', reverse_timer)
        print('Ваша еда готова, осторожно горячo!')


********************************************************************************

# Часть 1. Модуль 8. Задача 4. Среднее на отрезке
#
# Напишите программу, которая считывает с клавиатуры три числа a, b и c,
# считает и выводит на консоль среднее арифметическое всех чисел из отрезка [a; b], кратных числу c.
#
# Рекомендации
# Функция range(start, stop) не включает границу stop, останавливается, не доходя до неё.
#
# Что оценивается
# Задача решена успешно, если:
# результат вывода соответствует условию;
# вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием);
# input содержит корректное приглашение для ввода;
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3).
    
a = int(input('Введите начало отрезка a: '))
b = int(input('Введите конец отрезка b: '))
c = int(input('Введите число c для вычисления всех чисел на отрезке [a, b], кратных c: '))

sum, num, count = int(0), int(0), int(0)

for num in range(a, b):
    if num % c == 0:
        sum += num
        print('Кратное число', num)
        count += 1
        print('Счетчик: ', count)
        print('')
if b % c == 0:
    arithmetic_mean = int((sum + b) / (count + 1))
    print('Кратное число', b)
    print('Счетчик: ', count + 1)
else:
    arithmetic_mean = int(sum / count)

print(f"\nСреднее арифметическое чесел, кратных {c} на отрезке [{a};{b}]: {arithmetic_mean}")


********************************************************************************

# Часть 1. Модуль 8. Задача 5. Функция
#
# Напишите программу, которая получает на вход начало и конец отрезка,
# а также шаг (отрицательный), а затем высчитывает функцию y в каждой точке отрезка
# и выводит ответ на экран с нужным шагом, начиная с конца.
#
# Пример:
# Введите начало отрезка: −2
# Введите конец отрезка: 2
# Введите шаг: −1
# В точке 2 функция равна 9
# В точке 1 функция равна 0
# В точке 0 функция равна 1
# В точке −1 функция равна 6
# В точке −2 функция равна 9
#
# Рекомендации
# Функция range(start, stop) не включает границу stop, останавливается, не доходя до неё.
#
# Что оценивается
# Задача решена успешно, если:
# результат вывода соответствует условию;
# вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием);
# input содержит корректное приглашение для ввода;
# в программе происходит проверка границ перед созданием range и, возможно, их разворот, как и изменение знака шага;
# формат вывода соответствует примеру;
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3).

a = int(input('Введите начало отрезка a: '))
b = int(input('Введите конец отрезка b: '))
step = int(input('Введите шаг: '))

def f(a:int, b:int, step:int):
    num_list = []
    count = int(0)

    for x in range(b, a, -step):
        y = int(x ** 3 + 2 * x ** 2 - 4 * x + 1)
        print(f"f({x}) = {y}")
        num_list.append(x)
        count += 1

    n = len(num_list)

    if a in num_list or (a - step == num_list[n - 1]):
        y = int(a ** 3 + 2 * a ** 2 - 4 * a + 1)

    return y

y = f(a, b, step)
print(f"f({a}, {b}) = {y}")


********************************************************************************

# Часть 1. Модуль 8. Задача 6. Стипендия
#
# Ежемесячная стипендия студента составляет educational_grant рублей,
# а расходы на проживание превышают стипендию и составляют expenses рублей в месяц.
#
# Рост цен ежемесячно увеличивает расходы на 3%, кроме первого месяца.
# Обратите внимание, что каждый месяц цены увеличиваются на 3% относительного прошлого месяца.
#
# Составьте программу расчёта суммы денег, которую необходимо получить у родителей один раз в начале обучения,
# чтобы можно было прожить учебный год (десять месяцев), используя только эти деньги и стипендию.
#
# Пример:
# Введите стипендию: 10000
# Введите расходы на проживание: 12000
# месяц траты 12000 не хватает 2000
# месяц траты 12360.0 не хватает 4360.0
# месяц траты 12730.8 не хватает 7090.8
# месяц траты 13112.7 не хватает 10203.52
# месяц траты 13506.1 не хватает 13709.63
# месяц траты 13911.2 не хватает 17620.92
# месяц траты 14328.6не хватает 21949.55
# месяц траты 14758.4 не хватает 26708.03
# месяц траты 15201.2 не хватает 31909.27
# месяц траты 15657.2 не хватает 37566.55
# Нужно попросить у родителей 37566.55 рублей
#
# Что оценивается
# Задача решена успешно, если:
# результат вывода соответствует условию;
# вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием);
# input содержит корректное приглашение для ввода;
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3).

educational_grant = int(input('Введите размер стипендии: '))
expenses = int(input('Введите размер расходов: '))
months = int(input('Сколько месяцев длится учеба: '))
sum = int(0)

for i in range(0, months):
    sum += (expenses - educational_grant)
    expenses = expenses + expenses * 0.03

print('Чтобы хватило денег на жизнь во время обучения, возьмите у родителей: ', sum // 1, 'рублей.')


********************************************************************************

# Часть 1. Модуль 8. Задача 7. Сумма ряда
#
# Дано натуральное число N. Напишите программу для вычисления суммы N элементов последовательности по формуле  — порядковый номер элемента (расчёт начинается с нуля).
#
# Примеры расчётов:
#
# При N = 4 элементы выражения будут равны:
# n = 0
# elem = (−1) ** 0 * (½) ** 0 = 1
# n = 1
# elem = (−1) ** 1 * (½) ** 1 = (−½)
# n = 2
# elem = (−1) ** 2 * (½) ** 2 = ¼
# n = 3
# elem = (−1) ** 3 * (½) ** 3 = (−⅛)
# Сумма равна:
#
#
# При N = 6 элементы выражения будут равны:
# n = 0
# elem = (−1) ** 0 * (½) ** 0 = 1
# n = 1
# elem = (−1) ** 1 * (½) ** 1 = (−½)
# n = 2
# elem = (−1) ** 2 * (½) ** 2 = ¼
# n = 3
# elem = (−1) ** 3 * (½) ** 3 = (−⅛)
# n = 4
# elem = (−1) ** 4 * (½) ** 4 = (1/16)
# n = 5
# elem = (−1) ** 5 * (½) ** 5 = (−1/32)
#
# Сумма равна:
# s = 1 − ½ + ¼ − ⅛ + 1/16 − 1/32 = 21/32 = 0,65625
#
# P. S. Не стоит выполнять расчёты каждого элемента вручную, используйте цикл.
#
# Примеры вывода в консоль:
# Введите N: 4
# Ответ: 0,625
# Введите N: 6
# Ответ: 0,65625
#
# Рекомендации
# Так как n изменяется от нуля до N, эти изменения можно легко задать при помощи цикла и функции range.
#
# Подставляя переменную такого цикла в формулу, вы на каждой итерации будете получать один элемент последовательности, останется лишь добавить их суммирование.
# Что оценивается
# Задача решена успешно, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3);
# программа работает корректно при вводе разных значений числа N.
# Допускается вывод без описания, достаточно вывести сумму ряда

N = int(input('Введите N: '))
P = []
sumP = 0

for n in range(N):
    P.append((-1) ** n * (1 / 2 ** n))
    sumP = sumP + P[n]

print('Ряд', P)
print('Сумма ряда:', sumP)


********************************************************************************

# Часть 1. Модуль 8. Задача 8. Кинотеатр
#
# X мальчиков и Y девочек пошли в кинотеатр и купили билеты на идущие подряд места в одном ряду.
# Напишите программу, которая выдаст, как нужно сесть мальчикам и девочкам,
# чтобы рядом с каждым мальчиком сидела хотя бы одна девочка, а рядом с каждой девочкой — хотя бы один мальчик.
#
# На вход подаются два числа: количество мальчиков X и количество девочек Y.
# В ответе выведите какую-нибудь строку, в которой будет ровно X символов B,
# обозначающих мальчиков, и Y символов G, обозначающих девочек, удовлетворяющую условию задачи.
# Пробелы между символами выводить не нужно.
# Если рассадить мальчиков и девочек согласно условию задачи невозможно, выведите строку «Нет решения».
#
# Пример 1
# Введите количество мальчиков: 5
# Введите количество девочек: 5
# Ответ: BGBGBGBGBG
#
# Пример 2
# Введите количество мальчиков: 5
# Введите количество девочек: 3
# Ответ: BGBGBBGB
#
# Пример 3
# Введите количество мальчиков: 100
# Введите количество девочек: 1
# Ответ: Нет решения
#
# Что оценивается
# Задача решена успешно, если:
#
# результат вывода соответствует условию;
# формат вывода соответствует примеру (выведенные числа сопровождаются текстовым описанием);
# input содержит корректное приглашение для ввода;
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3).

# Решение 1:
def task_8_8_1():
    print('\nЗадача 8-8 - Кинотеатр (верный алгоритм).\n')
    
    boys = int(input('Введите кол-во мальчиков: '))
    girls = int(input('Введите кол-во девочек: '))
    answer = ''

    if (boys >= 2 * girls) or (girls > 2 * boys):
        print('Нет решения.')
    elif boys >= girls:
        k = boys - girls
        for bgb in range(k):
            answer += 'BGB'
        for bg in range(girls - k):
            answer += 'BG'
    else:
        k = girls - boys
        for gbg in range(k):
            answer += 'GBG'
        for gb in range(boys - k):
            answer += 'GB'
    print(answer)


# Решение 2:
def task_8_8_2():
    print('\nЗадача 8-8 - Кинотеатр (мой алгоритм)\n')
    X = int(input('Введите кол-во девочек: '))
    Y = int(input('Введите кол-во мальчиков: '))
    XY = []

    if (X > 2 * Y) or (Y > 2 * X):
        print('Решить задачу при данных условиях невозможно.')
    else:
        for i in range(X + Y):
            while X > 0 and Y > 0:
                if X > 0:
                    XY.append('X')
                    X -= 1
                if Y > 0:
                    XY.append('Y')
                    Y -= 1
                if X > Y:
                    XY.append('X')
                    X -= 1
                if Y > X:
                    XY.append('Y')
                    Y -= 1
    if XY[len(XY) - 2] == XY[len(XY) - 1]:
        last_item = XY.pop(len(XY) - 1)
        XY.insert(0, last_item)

    print('Последовательность списком: ', XY)
    XY_str = "".join(XY)
    print('Последовательность строкой: ', XY_str)
    print('Кол-во элементов: ', len(XY))

task_8_8_1()
# task_8_8_2()


********************************************************************************

# Альтернативное решение. Часть 1. Модуль 8. Задача 8. Кинотеатр

# Альтернативное решение
def no_solution(boys: int, girls: int) -> bool:
    if (boys > 2 * girls) or (girls > 2 * boys):
        return True

    return False

# def no_solution(boys: int, girls: int) -> bool:
    # return ((boys > 2 * girls) or (girls > 2 * boys))

def arrange_seats(boys: int, girls: int) -> str:
    if no_solution(boys, girls):
        return "Нет решения"

    answer = ''

    if boys >= girls:
        for bgb in range(boys - girls):
            answer += 'BGB'
        for bg in range(2 * girls - boys):
            answer += 'BG'

    if girls >= boys:
        for gbg in range(girls - boys):
            answer += 'GBG'
        for gb in range(2 * boys - girls):
            answer += 'GB'

    return "".join(answer)


if __name__ == '__main__':
    test_cases = [
        (50, 100),
        (100, 50),
        (5, 9),
        (5, 10),
        (6, 14),
        (10, 15)
    ]

    for boys, girls in test_cases:
        result = arrange_seats(boys, girls)
        print(f"Количество мальчиков: {boys}, Количество девочек: {girls}")
        print(f"Ответ: {result}\n")


********************************************************************************

# Часть 1. Модуль 9. Задание 1. «Я стал новым пиратом!»
#
# Пользователь вводит десять слов. Напишите программу, которая определяет,
# сколько из них совпадают со словом «Карамба».
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# программа игнорирует регистр первой буквы К;
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3).

need_word = 'Карамба'
count = 0

for yours_word in range(10):
    yours_word = input('Ваше слово: ')
    if yours_word == need_word:
        count += 1

print(f"\nКол-во верных ответов: {count} \n")


********************************************************************************

# Часть 1. Модуль 9. Задание 2. Кривой мессенджер
#
# Напишите программу, которая определяет порядковый номер звёздочки в строке.
#
# Пример:
# Введите текст: «Пр*ивет как дела».
# Символ «*» стоит на позиции 3.
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием);
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3).

need_symbol = '*'
word = input('Введите слово: ')

count = 1

for symbol in word:
    if symbol != need_symbol:
        count += 1
    else:
        print(f"\nСимвол «*» стоит на позиции {count} \n")
        break


********************************************************************************

# Часть 1. Модуль 9. Задание 3. Театр
#
# Напишите программу, которая получает на вход количество рядов,
# сидений и свободных метров между рядами, а затем выводит примерный макет театра на экран.
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# формат вывода соответствует примеру;
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3).
# Рекомендации по выполнению
# Можно воспользоваться синтаксическим сахаром: умножением строки на число
# и конкатенацией (объединением строк). Для начала получите одну строку.

rows = int(input('\nВведите кол-во рядов: '))
seats = int(input('Введите кол-во сидений: '))
distance = int(input('Введите расстояние между рядами в метрах: '))
print()

for i in range(rows):
    print('=' * seats, '*' * distance, '=' * seats)


********************************************************************************

# Часть 1. Модуль 9. Задание 4. Марсоход-2
#
# К роботу Валли отправили «коллегу» Билли. Это его первая высадка на Марс,
# поэтому его тестируют в прямоугольном помещении размером 15 × 20 м.
# Марсоход высаживается в центре комнаты (в точке 8, 10), затем управление им
# передаётся оператору, то есть пользователю вашей программы.
#
# Программа спрашивает, в какую сторону оператор хочет направить робота:
# север (клавиша W), юг (клавиша S), запад (клавиша A) или восток (клавиша D).
# Оператор делает выбор, марсоход перемещается в эту сторону на один метр,
# а программа сообщает новую позицию робота. Если марсоход упёрся в стену,
# он не должен пытаться переместиться в сторону стены — в этом случае его позиция не меняется.
#
# Создайте программу для управления роботом Билли.
#
# Пример:
# [Программа]: Марсоход находится на позиции 6, 19, введите команду:
# [Оператор]: A
# [Программа]: Марсоход находится на позиции 5, 19, введите команду:
# [Оператор]: W
# [Программа]: Марсоход находится на позиции 5, 20, введите команду:
# [Оператор]: W
# [Программа]: Марсоход находится на позиции 5, 20, введите команду:
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# формат вывода соответствует примеру;
# марсоход не двигается, если достигает границы участка;
# программа игнорирует регистр вводимых команд;
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3).
#
# Рекомендации по выполнению
# Обращайте внимание на границы.
# Попробуйте изменять положение марсохода только после проверки координат.
# Ввод команд происходит только в верхнем регистре, учитывать нижний не нужно.
# Старайтесь максимально уменьшать количество дублирований кода.
# Если действие выполняется независимо от условий - его не стоит дублировать в каждом условии.

dim_X, dim_Y = 15, 20
X, Y = 8, 10

print(f"Управление марсоходом:\n Cевер - W\n Юг - S\n Запад - A\n Восток - D\n \n")

while (X != 1) and (Y != 1) and (X != dim_X) and (Y != dim_Y):
    team = input(f"Марсоход находится на позиции ({X},{Y}) введите команду: ")
    if team == 'W' or team == 'w':
        Y += 1
    elif team == 'S' or team == 's':
        Y -= 1
    elif team == 'A' or team == 'a':
        X += 1
    elif team == 'D' or team == 'd':
        X -= 1
    else:
        print(f"Команда не распознана! Введите другую.")

print('Вы врезались в стену! Тест завершен.\n')


********************************************************************************

# Часть 1. Модуль 9. Задание 5. Великий и могучий
#
# Напишите программу, которая получает на вход текст и находит длину
# самого длинного слова в нём. Слова в тексте разделяются одним пробелом.
#
# Пример:
# Введите текст: Меня зовут Пётр.
# Самое длинное слово, букв: 5.
#
# Введите текст: Меня зовут Василий
# Самое длинное слово, 7 букв
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием);
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3).
# Рекомендации по выполнению
# При помощи функции print убедитесь, что счётчики обнуляются в нужный момент.
# Не забывайте, что не все условия можно собирать в один условный блок.
# Некоторые из них должны срабатывать независимо друг от друга.

text = (input('\nВведите текст:\n\n'))

sub_text = text.split(' ')
length_sub_text = []

for item in sub_text:
    length_sub_text.append(len(item))

result = sub_text[int(length_sub_text.index(max(length_sub_text)))]

print(f"\nСамое длинное слово в строке - {result}\n")


********************************************************************************

# Часть 1. Модуль 9. Задание 6. Коровы
#
# Напишите программу для подсчёта получаемого молока в коровнике.
# Важно учитывать следующее взаимодействие: пользователь вводит строку из десяти символов a и b.
# Необходимо определить, сколько в итоге будет произведено молока за день.
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием);
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3).

distribution = input('Распределите коров по 10 стойлам (a — свободное, b — занятое):\n')

# Решение 1:
def task_9_6_1():

    total_milks = 0

    for number, letter in enumerate(distribution):
        if letter == "b":
            total_milks += (number + 1) * 2
    print(f"\nВсего молока будет за день: {total_milks}\n")


# Решение 2 - альтернативное через список:
def task_9_6_2():

    if len(distribution) != 10:
        print(f"У вас 10 мест! Вы заполнили {len(distribution)} мест.")
    else:

        milks = []

        for milk in range(2, 21, 2):
            milks.append(milk)

        count = 0
        total_milks = 0

        for check in distribution:
            if check == 'b':
                total_milks += milks[count]
            count += 1

        print(f"\nВсего молока будет за день: {total_milks}\n")

task_9_6_1()
#task_9_6_2()


********************************************************************************

# Часть 1. Модуль 9. Задание 7. Метод бутерброда
#
# Напишите программу-дешифратор, которая расшифровала бы введённые «методом бутерброда» сообщения.
#
# Пример:
# Введите зашифрованное сообщение: shacnidw.
# Расшифрованное сообщение: sandwich.
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием);
# переменные имеют значащие имена, не только a, b, c, d (видео 2.3).
# в сложении строк можно менять слагаемыми местами, но такая перемена изменит результат:
# строка += “а” – так вы добавите символ в конец строки
# строка = “а” + строка – так вы добавите символ в начало строки (что позволит сложить строку задом наперед)

input_word = 'К.аакп ивти-дeнlоb,a tвu mлmиiт ехрыанлньандо йз иф оорнмьел ектоирчтюелжк сpиy tьhтoяnо т3с озса пыинсжылвоаде т)сsяt cвi dв(и дйее рпаовсоллесд оивчаютлекл ьрнеомситрип аэНл е.мйеиннтеочва нвз  кхрыумгеляынхе мсзкиоебнк атхе,у бве ртто  nвoрhеtмyяp  кхаыкр одтлояк  стпои с,кхоывн нхаадр ахкатреуртнкыу рктвса дхрыантьнлыеед.т оН евк оытмоирныеем иорспо биежненторсотки  —к охрытненжаедй :х аорнуит куупротрся дхоичгеунрыд  пво  eпlоpзuиtц иеяимн;а вtоuзpьlлeо пмсоИг у.тм ыхнрсаанпиотзье би  ис омдыемрежааттиьч  венеулторби  дсоекб яь тоаблъеедкст ыт юляюлбоывхз отпи п,оивм а(жие тдраожке  есыонснтаадванзы х,)ы;т ндаотсстнуопК  к. тэнлаетмсеннотка мь лпорро иаснх оидмиатт апдои дснмаекщ еинмиыюн,ь лаа ендеи  пьот ыкбл юмчиу ;т евя лроавмзкоапх  еэжткоайт  сьттрсуокмтеуярные мдзаиненны х—  оьптрсеоднеслаепноыз евБс е. аокпсеирпасц ииим,а тонсенноовпамнонкы ес  нмае чп р,иемеернтесныиби  осммоедщеевнаизя  я(ситнюдяенклсоипрыовв аинмиает,н есмреелзэ) ;х ик оср тиеижциа рпеопдод еурмжоитвэаоюпт  ,нмеоозгаррабнои чмеынбноосео  киотляимчаепс твв оя сутряонванрехй  ивжлеотжреонкн оисттсио;м екяонретмезжиие нх реанниячти рупк аозПа т.етлюиа тноаб адрр уегеирет соыббъ еикжтеыт,р оак  з—н аьчтисто риохк См о.жвноок спирпесд сттоа вхлия тььт,а чкиалкт ом аоснсдиовгыы вс стыелжоокм;  ,ойноир оппо з,вйоелжяеюттр оокч еонвьт спйроовсст оо тмэе ноянтнье ммие с—т аьмтис озмнеаячнеенмизяи едНв у:хт епветрое моегненны ха.н  Зяасчтеёмд йиаснп оалкьыззояв айтеьл ектоардтзеожс  вум е,сятсот есепмиусзкаар?  ,Тоенм ,, скотроп оувж ей ыунснпеевлт спеотзснеа кеонмлиотпьвс яо тсЭо  .сепшиьслкоабм ие жва дP yиt hеoоnм,а см оежже то тп оёксавз аьттьасляе дн ет уогчоемв иидкнсыимп сс м,ыисклс еичсиптоклаьфз оьвдаенВи я. йкеожрет'

correct = 0
if len(input_word) % 2 == 0:
    correct = 1

len_word = len(input_word)
result = input_word[0:len_word:2] + input_word[(len_word - 2 + correct):0:-2]

print(f"Зашифрованное слово: {result}")


********************************************************************************

# Часть 1. Модуль 9. Задание 8. Метод бутерброда - обратная задача
#
# Напишите программу-шифратор, которая шифровала бы введённые сообщения «методом бутерброда».

input_phrase = 'Как видно, в литеральной форме кортеж python 3 записывается в виде последовательности ' \
               'элементов в круглых скобках, в то время как для списков характерны квадратные. ' \
               'Некоторые особенности кортежей: они упорядочены по позициям; tuple могут хранить и содержать ' \
               'внутри себя объекты любых типов (и даже составных); доступ к элементам происходит по смещению, ' \
               'а не по ключу; в рамках этой структуры данных определены все операции, основанные на применении смещения ' \
               '(индексирование, срез); кортежи поддерживают неограниченное количество уровней вложенности; кортежи хранят ' \
               'указатели на другие объекты, а значит их можно представлять, как массивы ссылок; они позволяют ' \
               'очень просто менять местами значения двух переменных. Зачем использовать кортеж вместо списка? ' \
               'Тем, кто уже успел познакомиться со списками в Python, может показаться не очевидным смысл ' \
               'использования кортежей. Ведь фактически, списки могут делать всё то же самое и даже больше. ' \
               'Это вполне естественный вопрос, но, разумеется, у создателей языка найдётся на него ответ: ' \
               'Неизменяемость — именно это свойство кортежей, порой, может выгодно отличать их от списков. ' \
               'Скорость — кортежи быстрее работают. По причине неизменяемости кортежи хранятся в памяти особым образом, ' \
               'поэтому операции с их элементами выполняются заведомо быстрее, чем с компонентами списка. ' \
               'Безопасность — неизменяемость также позволяет им быть идеальными кандидатами на роль констант. ' \
               'Константы, заданные кортежами, позволяют сделать код более читаемым и безопасным. ' \
               'Использование tuple в других структурах данных — кортежи применимы в отдельных структурах данных, ' \
               'от которых python требует неизменяемых значений. Например ключи словарей (dicts) должны состоять ' \
               'исключительно из данных immutable-типа.'

res = ''

length_in = len(input_phrase)

for i in range(length_in // 2):
    res += input_phrase[i]
print(res)

tmp = ''

for i in range(length_in - 1, length_in // 2 - 1, - 1):
    tmp += input_phrase[i]
print(tmp, '\n')

output_phrase = ''
i = 1

for i in range(length_in // 2):
    output_phrase += res[i]
    output_phrase += tmp[i]
if length_in % 2:
    output_phrase += tmp[i + 1]

print(f"ШИФР:\n {output_phrase}", '\n')


********************************************************************************

# Часть 1. Модуль 9.

def task_9_1():
    print('\nЗадача 9-1 - «Я стал новым пиратом!» \n')

    need_word = 'Карамба'
    count = 0

    for yours_word in range(10):
        yours_word = input('Кричите: ')
        if yours_word == need_word:
            count += 1

    print(f"\nКол-во верных ответов: {count} \n")


def task_9_2():
    print('\nЗадача 9-2 - Кривой мессенджер (определяет порядковый номер звёздочки в строке).\n')

    need_symbol = '*'
    word = input('Введите слово: ')

    count = 1

    for symbol in word:
        if symbol != need_symbol:
            count += 1
        else:
            print(f"\nСимвол «*» стоит на позиции {count} \n")
            break


def task_9_3():
    print('\nЗадача 9-3 - Театр (получает на вход количество рядов, сидений и свободных метров между рядами, а затем выводит примерный макет театра на экран).\n')

    rows = int(input('\nВведите кол-во рядов: '))
    seats = int(input('Введите кол-во сидений: '))
    distance = int(input('Введите расстояние между рядами в метрах: '))
    print()

    for i in range(rows):
        print('=' * seats, '*' * distance, '=' * seats)


def task_9_4():
    print('\nЗадача 9-4 - Марсоход-2\n')

    dim_X, dim_Y = 15, 20
    X, Y = 8, 10

    print(f"Управление марсоходом:\n Cевер - W\n Юг - S\n Запад - A\n Восток - D\n \n")

    while (X != 1) and (Y != 1) and (X != dim_X) and (Y != dim_Y):
        team = input(f"Марсоход находится на позиции ({X},{Y}) введите команду: ")
        if team == 'W' or team == 'w':
            Y += 1
        elif team == 'S' or team == 's':
            Y -= 1
        elif team == 'A' or team == 'a':
            X += 1
        elif team == 'D' or team == 'd':
            X -= 1
        else:
            print(f"Команда не распознана! Введите другую.")

    print('Вы врезались в стену! Тест завершен.\n')


def task_9_5():
    print('\nЗадача 9-5 - Великий и могучий (получает на вход текст и находит длину самого длинного слова).\n')

    text = (input('\nВведите текст:\n\n'))

    sub_text = text.split(' ')
    length_sub_text = []

    for item in sub_text:
        length_sub_text.append(len(item))

    print(f"\nСамое длинное слово в строке - {sub_text[int(length_sub_text.index(max(length_sub_text)))]}\n")


def task_9_6():
    print('\nЗадача 9-6 - Коровы (пользователь вводит строку из десяти символов a и b. Определить, сколько будет молока за день?)\n')

    distribution = "abaabaaaba"
    total_milks = 0

    for number, letter in enumerate(distribution):
        if letter == "b":
            total_milks += (number + 1) * 2
    print(f"\nВсего молока будет за день: {total_milks}\n")


def task_9_6_2():
    print('Задача 9-6 - Коровы (альтернативное решение через список).\n')

    distribution = input('Распределите коров по 10 стойлам (a — свободное, b — занятое):\n')

    if len(distribution) != 10:
        print(f"У вас 10 мест! Вы заполнили {len(distribution)} мест.")
    else:

        milks = []

        for milk in range(2, 21, 2):
            milks.append(milk)

        count = 0
        total_milks = 0

        for check in distribution:
            if check == 'b':
                total_milks += milks[count]
            count += 1

        print(f"\nВсего молока будет за день: {total_milks}\n")


def task_9_7():
    print('Задача 9-7 - Метод бутерброда \n')
    input_word = 'В?иаккттоур ияяа,н тгадвео рмкодяо п'
    corrective = 0

    if len(input_word) % 2 == 0:
        corrective = 1

    print(f"Зашифрованное слово: {input_word[0:len(input_word):2] + input_word[len(input_word) - 2 + corrective:0:-2]}")


def task_9_8():
    print('Задача 9-8 - Метод бутерброда - обратная задача\n')
    input_phrase = 'Как видно, в литеральной форме кортеж python 3 записывается в виде последовательности ' \
                   'элементов в круглых скобках, в то время как для списков характерны квадратные. Некоторые ' \
                   'особенности кортежей: они упорядочены по позициям; tuple могут хранить и содержать внутри себя ' \
                   'объекты любых типов (и даже составных); доступ к элементам происходит по смещению, а не по ключу; ' \
                   'в рамках этой структуры данных определены все операции, основанные на применении смещения ' \
                   '(индексирование, срез); кортежи поддерживают неограниченное количество уровней вложенности; ' \
                   'кортежи хранят указатели на другие объекты, а значит их можно представлять, как массивы ссылок; ' \
                   'они позволяют очень просто менять местами значения двух переменных. Зачем использовать кортеж ' \
                   'вместо списка? Тем, кто уже успел познакомиться со списками в Python, может показаться не ' \
                   'очевидным смысл использования кортежей. Ведь фактически, списки могут делать всё то же самое ' \
                   'и даже больше. Это вполне естественный вопрос, но, разумеется, у создателей языка найдётся на ' \
                   'него ответ: Неизменяемость — именно это свойство кортежей, порой, может выгодно отличать их ' \
                   'от списков. Скорость — кортежи быстрее работают. По причине неизменяемости кортежи хранятся в ' \
                   'памяти особым образом, поэтому операции с их элементами выполняются заведомо быстрее, чем с ' \
                   'компонентами списка. Безопасность — неизменяемость также позволяет им быть идеальными кандидатами ' \
                   'на роль констант. Константы, заданные кортежами, позволяют сделать код более читаемым и безопасным. ' \
                   'Использование tuple в других структурах данных — кортежи применимы в отдельных структурах данных, ' \
                   'от которых python требует неизменяемых значений. Например ключи словарей (dicts) должны состоять ' \
                   'исключительно из данных immutable-типа.'
    res = ''
    length_in = len(input_phrase)
    
    for i in range(length_in // 2):
        res += input_phrase[i]
    print(res)

    tmp = ''
    
    for i in range(length_in - 1, length_in // 2 - 1, - 1):
        tmp += input_phrase[i]
    print(tmp, '\n')

    output_phrase = ''
    i = 1
    
    for i in range(length_in // 2):
        output_phrase += res[i]
        output_phrase += tmp[i]
    if length_in % 2:
        output_phrase += tmp[i + 1]

    print(f"ШИФР:\n {output_phrase}", '\n')

    corrective = 0
    length_out = len(output_phrase)
    
    if length_out % 2 == 0:
        corrective = 1

    result = output_phrase[0:length_out:2] + output_phrase[length_out - 2 + corrective:0:-2]
    print(f"Зашифрованное слово: {result}",'\n')


********************************************************************************

# Часть 1. Модуль 9. Задачи под видео 2.

def mod_9_video_2_2():
    print('\nЗадача m9-v2-2 - Начальник\n')
    answer = ''

    while answer != 'Да, конечно, сделал':
        print('Выполнена ли задача?')
        answer = input()


def mod_9_video_2_3():
    print('\nЗадача m9-v2-3 - Купи слона\n')
    user_name = input('Как тебя зовут? ')
    print(f"{user_name}, купи слона!")

    while True:
        some_phrase = input()
        print(f"Все говорят {some_phrase}, а ты купи слона!")


mod_9_video_2_2()
# mod_9_video_2_3()


********************************************************************************

# Часть 1. Модуль 9. Задачи под видео 3.

def mod_9_video_3_1():
    print('\nЗадача m9-v3-1 - Python!\n')
    word = 'Python!'
    count = 0

    for symbol in word:
        print(word[count] * 3)
        count += 1


def mod_9_video_3_3():
    print('\nЗадача m9-v3-3\n')
    phrase = input('Введите текст: \n')
    count_small_letters, count_big_letters = 0, 0

    for symbol in phrase:
        if symbol == 'ы':
            count_small_letters += 1
        elif symbol == 'Ы':
            count_big_letters += 1

    print(f"\nМаленьких букв ы - {count_small_letters}, больших букв Ы - {count_big_letters}.\n")


mod_9_video_3_1()
# mod_9_video_3_3()


********************************************************************************

# Часть 1. Модуль 9. Задачи под видео 4.

def mod_9_video_4_1():
    print('\nЗадача m9-v4-1 - Доска\n')
    print('-' * 12)
    for i in range(3):
        print('|', '0' * 8, '|')
    print('-' * 12)


def mod_9_video_4_2():
    print('\nЗадача m9-v4-2 - Локальная сеть\n')
    number = int(input('Введите число: '))
    step = int(input('Введите шаг: '))
    summ = 0

    for count in range(0, 3):
        summ += number
        print(number, end = '.')
        number += step
    print(summ)


def mod_9_video_4_3():
    print('\nЗадача m9-v4-3 - Табло\n')
    number = int(input('Введите число: '))

    for count in range(0, number + 10, 10):
        print('-=-', count, end=' ')
    print('-=-')


def mod_9_video_4_4():
    print('\nЗадача m9-v4-4\n')
    print('\nНаходит две одинаковые буквы подряд.\n')
    string = input('Введите строку: ')
    prev_sym = ''
    equal_sym = False
    for letter in string:
        if prev_sym == letter:
            equal_sym = True
            break
        else:
            prev_sym = letter

    if equal_sym:
        print('Есть две одинаковые буквы, идущие подряд.')
    else:
        print('Нет двух одинаковых букв, идущих подряд.')

mod_9_video_4_1()
# mod_9_video_4_2()
# mod_9_video_4_3()
# mod_9_video_4_4()


********************************************************************************

# Часть 1. Модуль 10. Задача 1. Тестовое задание
#
# Проанализировать таблицу, понять, как она строится, и написать программу для её вывода на экран.
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# задача решена с помощь циклов for или while;
# формат вывода соответствует примеру.

for row in range(6):
    for col in range(6):
        print(col * 2 + row, "\t", end='')
    print()

print()


********************************************************************************

# Часть 1. Модуль 10. Задача 2. Лестница
#
# Выводит «лестницу» из чисел, когда пользователь вводит число N.
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# может быть использована конструкция print и пустой input (видео 10.4);
# формат вывода соответствует примеру.

dim = int(input('Введите число: '))

count = 0

for row in range(dim + 1, 0, -1):
    for col in range(dim + 1, row, -1):
        print(count, "\t", end='')
    count += 1
    print()
print()


********************************************************************************

# Часть 1. Модуль 10. Задача 3. Рамка
#
# Напишите программу, которая рисует прямоугольную рамку с помощью символьной графики.
# Для вертикальных линий используйте символ вертикального штриха (|),
# а для горизонтальных — дефис (-). Пусть ширину и высоту рамки определяет пользователь.
#
# Что оценивается
# Задание считается успешно выполненным, если:
# input содержит корректное приглашение для ввода;
# формат вывода соответствует примеру;
# в качестве элементов горизонтальной линии можно использовать дефисы (-) или нижние подчёркивания (_).

dim_row = int(input('Введите высоту рамки: '))
dim_col = int(input('Введите ширину рамки: '))

for row in range(dim_row):
    for col in range(dim_col):
        if row == 0 or row == dim_row - 1:
            print('-', end='')
        elif col == 0 or col == dim_col - 1:
            print('|', end='')
        else:
            print(' ', end='')
    print()
print()


********************************************************************************

# Часть 1. Модуль 10. Задача 4. Простые числа
#
# Напишите программу, которая считает количество простых чисел в заданной последовательности
# и выводит ответ на экран.
#
# Простое число делится только на себя и на единицу.
# Последовательность задаётся при помощи вызова ввода (input) на каждой итерации цикла.
# Одна итерация — одно число.
#
# Пример:
# Введите количество чисел: 6.
# Введите число: 4.
# Введите число: 7.
# Введите число: 20.
# Введите число: 3.
# Введите число: 11.
# Введите число: 37.
# Количество простых чисел в последовательности: 4.
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).
#
# Рекомендации по выполнению
# Простое число имеет только два делителя, поэтому для проверки нужно перебрать все числа от одного до него.
# Если загаданное число делится без остатка на что-то, кроме единицы или себя, то это уже не простое число.
# 1 не является простым числом

quant_num = int(input('Введите количество чисел: '))
list_num = []
quant_simple_num = 0

for num in range(quant_num):
    num = int(input(f"Введите {num + 1}-е число: "))
    list_num.append(num)

temp_list_num = []
for i in range(0, quant_num):
    for j in range(2, list_num[i] + 1):
        for k in temp_list_num:
            if k > (j ** 0.5 + 1):
                temp_list_num.append(j)
                break
            if (j % k == 0):
                break
        else:
            temp_list_num.append(j)
    print(f"Простые числа в числе {list_num[i]}: {temp_list_num}")
    quant_simple_num += len(temp_list_num)
    temp_list_num.clear()
print(f"Количество простых чисел в последовательности: {quant_simple_num}")


********************************************************************************

# Часть 1. Модуль 10. Задание 5. Наибольшая сумма цифр
#
# Пользователь вводит N чисел. Среди натуральных чисел, которые он указал,
# найдите наибольшее по сумме цифр. Выведите на экран это число и сумму его цифр.
#
# Что оценивается
# Задание считается успешно выполненным, если:
# результат вывода соответствует условию;
# input содержит корректное приглашение для ввода;
# вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).

sequence = input('Введите последовательность чисел через запятую и/или пробел: ')
list_sequence = []

if sequence.find(', '):
    list_sequence = sequence.split(', ')
elif sequence.find(','):
    list_sequence = sequence.split(',')
elif sequence.find(' '):
    list_sequence = sequence.split(' ')

sum_elements = 0
list_sum_elements = []

for elem in list_sequence:
    elem = abs(int(elem))
    while elem > 0:
        sum_elements += elem % 10
        elem = elem // 10
        print(elem)
    list_sum_elements.append(sum_elements)
    sum_elements = 0

#print('Заданная последовательность: ', ListSequence)
#print('Последовательность сумм цифр', ListSumElements)
#print('Максимальная сумма цифр: ', max(ListSumElements))
#print('Индекс числа с максимальной суммой цифр: ', ListSumElements.index(max(ListSumElements)))
#print('Заданной число с этим индексом', ListSequence[ListSumElements.index(max(ListSumElements))])

result = list_sequence[list_sum_elements.index(max(list_sum_elements))]

print(f"Максимальная сумма цифр в последовательности чисел: {max(list_sum_elements)}, число: {result}")


********************************************************************************

# Часть 1. Модуль 10. Задача 6. Пирамидка
#
# Напишите программу, которая выводит на экран равнобедренный треугольник (пирамидку),
# заполненный символами хештега (#). Пусть высоту пирамиды определяет пользователь.
#
# Что оценивается
# Задание считается успешно выполненным, если:
# формат вывода соответствует примеру;
# input содержит корректное приглашение для ввода.
# Советы и рекомендации
# Вспомните, как выводился колонтитул вида -----!!!!!!-----.
# Не забывайте, что для нас пробел — это пустое место, а для Python — это такой же символ, как и любой другой. Если нужно добавить отступ, необходимо использовать пробел или символ табуляции (\t).

hight = int(input('Введите высоту пирамидки: '))
print()

for i in range(hight):
    for j in range(1, 2):
        print(' ' * (hight - i), '#' * (j + i * 2), ' ' * (hight - i), "\t", end = '')
    print()
print()


********************************************************************************

# Часть 1. Модуль 10. Задание 7. Пирамидка-2
#
# Напишите программу, которая получает на вход количество уровней пирамиды
# и выводит их на экран, заполняя нечётными числами:
#
# Что оценивается
# Задание считается успешно выполненным, если:
# формат вывода соответствует примеру;
# input содержит корректное приглашение для ввода.

# Решение 1:
def task_10_7_1(rows_pir: int) -> None:
    new_num = 1

    for line in range(rows_pir):
        for spase in range(rows_pir - line - 1, 0, -1):
            print(end = '   ')
        for number in range(line + 1):
            print(new_num, end = '    ')
            new_num += 2
        print()


# Решение 2 альтернативное:
def task_10_7_2(levels: int) -> None:
    current_number = 1

    for level in range(levels):
        spaces = " " * (levels - level - 1)
        row = ""
        for _ in range(level + 1):
            if current_number < 10:
                row += f" {current_number} "
            else:
                row += f"{current_number} "
            current_number += 2

        print(' ', spaces, row)

task_10_7_1(8)
# task_10_7_2(8)


********************************************************************************

# Альтернативное решение. Часть 1. Модуль 10. Задание 7. Пирамидка-2
#
# Альтернативное решение

def pyramid(levels: int) -> None:
    current_number = 1
    lines = []

    for level in range(levels):
        spaces = " " * (levels - level - 1)
        row = ""

        for _ in range(level + 1):
            if current_number < 10:
                row += f" {current_number} "
            else:
                row += f"{current_number} "
            current_number += 2

        lines.append(f"{' '}{spaces}{row}")

    return lines


if __name__ == '__main__':
    result_lines = pyramid(5)
    print("\n".join(result_lines))


********************************************************************************

# Часть 1. Модуль 10. Задание 8. Яма (генератор ландшафта)
#
# Напишите программу, которая получает на вход число N и выводит на экран числа в виде ямы:
#
# Что оценивается
# Задание считается успешно выполненным, если:
# формат вывода соответствует примеру;
# input содержит корректное приглашение для ввода.

# Моё решение:
def task_10_8_1(levels: int) -> None:

    row, new_row, rewerse_new_row = '', '', ''

    for level in range(levels, 0, -1):
        row += str(level)

    for level in range(levels):
        width = levels - level - 1
        new_row = row[0:level + 1] + '.' * width
        rewerse_new_row = new_row[::-1]
        print(new_row + rewerse_new_row)


# Верное решение:
def task_10_8_2():

    depth = int(input('Введите глубину ямы: '))

    for line in range(depth):
        for left_number in range(depth, depth - line - 1, -1):
            print(left_number, end='')
        point_count = 2 * (depth - line - 1)
        print('.' * point_count, end='')
        for rignt_number in range(depth - line, depth + 1):
            print(rignt_number, end='')
        print()

#task_10_8_1()
task_10_8_2()


********************************************************************************

# Альтернативное решение. Часть 1. Модуль 10. Задание 8. Яма (генератор ландшафта)
#
# Альтернативное решение

import time

# Медленный код:
start = time.perf_counter()
def landscape_generator_pit_1(levels: int) -> list[str]:
    lines = []
    row, new_row, rewerse_new_row = '', '', ''

    for number in range(levels, 0, -1):
        row += str(number)

    for level in range(levels):
        width = levels - level - 1
        new_row = row[0:level + 1] + '.' * width
        rewerse_new_row = new_row[::-1]
        lines.append(f"{new_row}{rewerse_new_row}")

    return lines

print(f"Запрос 1: {time.perf_counter() - start}")


# Быстрый код:
start2 = time.perf_counter()
def landscape_generator_pit_2(levels: int) -> list[str]:
    lines = []

    for level in range(1, levels + 1):
        row = ''
        for row_number in range(levels, levels - level, -1):
            row += str(row_number)

        ratio = 2
        points = '.' * ratio * (levels - level)
        reverse_row = row[::-1]
        lines.append(f"{row}{points}{reverse_row}")

    return lines

print(f"Запрос 2: {time.perf_counter() - start2}")

if __name__ == '__main__':
    result_lines = landscape_generator_pit_2(200)
    print("\n".join(result_lines))


********************************************************************************

# Часть 1. Модуль 10. Задачи под видео 1.

def mod_10_video_1_1():
    print('\nЗадача m10-v1-1 - Таблица умножения\n')

    for i in range(1, 10):
        for j in range(1, 10):
            print(i * j, "\t", end = '')
        print()


def mod_10_video_1_2():
    print('\nЗадача m10-v1-2 - Таблица суммы\n')
    number = int(input('Введите число: '))

    for i in range(1, number + 1):
        for j in range(1, number + 1):
            print(i * j, "\t", end = '')
        print()


def mod_10_video_1_3():
    print('\nЗадача m10-v1-3 - Анализ данных\n')

    for i in range(10, 0, -1):
        for j in range(10, 0, -1):
            print(j - i, "\t", end = '')
        print()


mod_10_video_1_1()
# mod_10_video_1_2()
# mod_10_video_1_3()


********************************************************************************

# Часть 1. Модуль 10. Задачи под видео 2.

def mod_10_video_2_1():
    print('\nЗадача m10-v2-1 - Квадратная матрица\n')

    n = int(input('Введите размерность матрицы: '))

    for row in range(1, n + 1):
        for col in range(1, n + 1):
            if row % 2 == 0:
                print(row, "\t", end = '')
            else:
                print(col, "\t", end = '')
        print()


def mod_10_video_2_2():
    print('\nЗадача m10-v2-2 - Чёрный ящик\n')

    n = int(input('Введите размерность матрицы: '))

    for row in range(1, n + 1):
        for col in range(1, n + 1):
            if col % 3 == 0:
                print(col, "\t", end = '')
            else:
                print(row, "\t", end = '')
        print()


def mod_10_video_2_3():
    print('\nЗадача m10-v2-3 - Координатные оси\n')

    for row in range(20):
        for col in range(50):
            if row == 9:
                print('-', end = '')
            elif col == 24:
                print('|', end = '')
            else:
                print(' ', end = '')
        print()


mod_10_video_2_1()
# mod_10_video_2_2()
# mod_10_video_2_3()


********************************************************************************

# Часть 1. Модуль 10. Задачи под видео 3.

def mod_10_video_3_1():
    print('\nЗадача m10-v3-1 - Врата\n')

    for row in range(20):
        for col in range(30):
            if row == 0:
                print('-', end = '')
            elif col == 0 or col == 29:
                print('|', end = '')
            else:
                print(' ', end = '')
        print()


def mod_10_video_3_2():
    print('\nЗадача m10-v3-2 - Дорога\n')

    for row in range(20):
        for col in range(50):
            if row == 9:
                print('-', end = '')
            elif col == 24:
                print('|', end = '')
            elif col == row + 29:
                print('\\', end = '')
            elif col == -row + 19:
                print('/', end = '')
            else:
                print(' ', end = '')
        print()


def mod_10_video_3_3():
    print('\nЗадача m10-v3-3 - Диагональная матрица\n')

    n = int(input('Введите размерность матрицы: '))

    for row in range(1, n + 1):
        for col in range(n, 0, -1):
            if row > col:
                print('2', "\t", end = '')
            elif row < col:
                print('0', "\t", end = '')
            else:
                print('1', "\t", end = '')
        print()


mod_10_video_3_1()
# mod_10_video_3_2()
# mod_10_video_3_3()


********************************************************************************

# Часть 1. Модуль 10. Задачи под видео 4.

def mod_10_video_4_1():
    print('\nЗадача m10-v4-1 - Электронная очередь\n')

    people = int(input('Введите кол-во людей в очереди: '))

    for hour in range(people):
        print('Час', hour, '-й: ')
        for number in range(hour, people):
            print('Номер в очереди: ', number)
        print()

    print('Обслуживание завершено!')


def mod_10_video_4_2():
    print('\nЗадача m10-v4-2 - Цифры больше пяти\n')

    sequence = input('Введите последовательность чисел: ')

    count = 0
    for number in sequence:
        if number == '6' or number == '7' or number == '8' or number == '9':
            count += 1

    print(f"Из них {count} - больше пяти.")


def mod_10_video_4_3():
    print('\nЗадача m10-v4-3 - Лестница чисел\n')

    number = int(input('Введите число: '))
    print()

    for row in range(0, number + 1):
        for col in range(row, number + 1):
            print(col, "\t", end = '')
        print()


mod_10_video_4_1()
# mod_10_video_4_2()
# mod_10_video_4_3()


********************************************************************************

# Часть 1. Модуль 11. Задача 1. Конвертация
#
# Напишите программу, которая получает на вход стоимость покупки в евро,
# а затем выводит ответ в рублях. Представим, что мы живём в альтернативной реальности,
# где 1 евро = 1.25 доллара, а 1 доллар = 60.87 руб.
#
# Что оценивается
# Результат вывода соответствует условию.
# Input содержит корректное приглашение для ввода.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).

def is_exist(price_euro: float) -> bool:
    return price_euro < 0

def currency_converter(price_euro: float) -> float:
    if is_exist(price_euro):
        raise ValueError(f"Отрицательной цены не существует.")

    price_euro = round(price_euro, 2)
    coef_ed = 1.25
    coef_dr = 60.87

    price_dollar = coef_ed * price_euro
    price_rub = coef_dr * price_dollar

    return round(price_rub, 2)


if __name__ == '__main__':
    test_cases = [
        (-1),
        (0),
        (1),
        (10),
        (2.5),
        (12.81)
    ]

    for price_euro in test_cases:
        try:
            result_price = currency_converter(price_euro)
            print(f"Стоимость товара в евро - {price_euro} EU, в рублях - {result_price} RUB.")
        except ValueError as e:
            print(e)


********************************************************************************

# Часть 1. Модуль 11. Задача 2. Грубая математика
#
# Напишите программу, которая выводит натуральный логарифм от числа,
# если оно положительное, и экспоненту в степени числа, если оно отрицательное.
#
# Пример:
# Введите кол-во чисел: 3
# Введите число: 1.3
# x = 2 log(x) = 0.6931471805599453
# Введите число: -2.1
# x = -3 exp(x) = 0.049787068367863944
# Введите число: -5.9
# x = -6 exp(x) = 0.0024787521766663585
#
# Что оценивается
# Результат вывода соответствует условию, применяются корректные функции,
# округление осуществляется в нужную сторону.
# Формат вывода соответствует примеру.
# Input содержит корректное приглашение для ввода.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).


import math


list_x = [-4, -3.7, 3.2, 0, 25.3, -1.5, 0.2, 1.678, -1000, -0.6, -0.2]

def logarithm_exponent(list_x: float):

    for x in list_x:
        if x > 0:
            x = math.ceil(x)
            print(f"ln({x}) = {math.log(x)}")

        if x <= 0:
            x = math.floor(x)
            print(f"{x}^e = {math.exp(x)}")

    return

logarithm_exponent(list_x)


********************************************************************************

# Часть 1. Модуль 11. Задача 3. Аналог Steam
#
# Напишите программу, принимающую на вход размер файла обновления
# в мегабайтах и скорость интернет-соединения в мегабайтах в секунду.
# Для каждой секунды программа должна рассчитывать и выводить на экран
# процент скачанного объёма до тех пор, пока скачивание не завершится.
# В конце программа должна показать, сколько секунд заняло скачивание обновления.
# Обеспечьте контроль ввода.
#
# Пример:
# Укажите размер файла для скачивания: 123
# Какова скорость вашего соединения: 27
# Прошло 1 сек. Скачано 27 из 123 Мб (22%)
# Прошло 2 сек. Скачано 54 из 123 Мб (44%)
# Прошло 3 сек. Скачано 81 из 123 Мб (66%)
# Прошло 4 сек. Скачано 108 из 123 Мб (88%)
# Прошло 5 сек. Скачано 123 из 123 Мб (100%)
#
# Что оценивается
# Результат вывода соответствует условию.
# Input содержит корректное приглашение для ввода.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).

import math


def is_exist(size: float, speed: float) -> bool:
    return (size <= 0)  or (speed <= 0)


def is_fust(size: float, speed: float) -> bool:
    return size < speed


def download_speed(size: float, speed: float):
    if is_exist(size, speed):
        raise ValueError(f"Объем файла и скорость скачивания должны быть положительными.")

    if is_fust(size, speed):
        raise ValueError(f"Скасивание завершено (менее чем за 1 секунду)!")

    all_time = math.ceil(size // speed)
    download_part = 0

    for time in range(1, all_time + 2):
        download_part += speed
        if download_part < size:
            print(f"Прошло {time} сек. Скачено {round(download_part, 2)} Мб из {size} Мб. Завершено {round(download_part * 100 / size)} %")
        else:
            print(f"Прошло {time} сек. Скачено {size} Мб из {size} Мб. Завершено 100 %")

        download_time = time

    return


if __name__ == '__main__':
    test_cases = [
        (123, 27),
        (-3, 0),
        (128, 0),
        (1269.467, 4.46),
        (12.8, 0.3)
    ]

    for size, speed in test_cases:
        try:
            result_download_time = download_speed(size, speed)
            print(f"Скачивание обновления заняло: {result_download_time} сек.\n")
        except ValueError as e:
            print(e)


********************************************************************************

# Часть 1. Модуль 11. Задача 4. Первая цифра
#
# Дано положительное действительное число X. Выведите его первую цифру после десятичной точки.
# При решении этой задачи нельзя пользоваться условной инструкцией, циклом или строками.
#
# Что оценивается
# Результат вывода соответствует условию.
# В вычислениях не используется for, if и работа со строками.
# Input содержит корректное приглашение для ввода.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).

def first_figure(number: float) -> int:

    # нельзя пользоваться условной инструкцией, циклом или строками.

    number = abs(number)
    figure = int(number * 10) % 10

    return figure


if __name__ == '__main__':
    test_cases = [
        (-6707567.432197408),
        (0.39555),
        (1),
        (108.102666),
        (2.5),
        (1982682.81432)
    ]

    for number in test_cases:
         result_figure = first_figure(number)
         print(f"Первая цифра вещественного числа {number} после точки: {result_figure}")


********************************************************************************

# Часть 1. Модуль 11. Задача 5. Вот это объемы!
#
# Есть формула для подсчета объема шара:
#
# где V — это объём, π — число пи, а R — радиус планеты.
#
# Напишите программу, которая получает на вход радиус случайной планеты
# и выводит на экран, во сколько раз планета Земля меньше или больше
# теоретически возможной планеты по объёму. Ответ округлите до трёх знаков после запятой.
#
# Пример 1:
# Введите радиус случайной планеты: 3389.5
# Объём планеты Земля больше в 6.641 раз
#
# Пример 2:
# Введите радиус теоретически возможной планеты: 7000
# Объём планеты Земля меньше в (1/0.754) = 1.326 раз
#
# Что оценивается
# Результат вывода соответствует условию.
# Формат вывода соответствует примеру.
# Input содержит корректное приглашение для ввода.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).

import math

lAND_V = 1.08321 * 10 ** 12
lAND_R = 6371.00604465
print(f"Радиус Земли: {lAND_R} \n")


def is_exist(planet_R: float) -> bool:
    return planet_R <= 0


def compare_volume_planets(planet_R: float) -> float:
    if is_exist(planet_R):
        raise ValueError(f"Нет решения.\n")

    planet_volume = 4 * math.pi / 3 * (planet_R ** 3)

    print(f"Объем Земли {lAND_V}, объем планеты: {planet_volume}")

    if planet_volume < lAND_V:
        compare_volume = lAND_V / planet_volume
    elif planet_volume > lAND_V:
        compare_volume = planet_volume / lAND_V
    else:
        pass

    return round(compare_volume, 3)



if __name__ == '__main__':
    test_cases = [
        (6371.00604465),
        (6569.925261403126),
        (6000),
        (7000),
        (16789),
        (5.43789 * 10 ** 12),
        (0),
        (0.08321),
        (10),
        (-16789)
    ]

    for planet_R in test_cases:
        try:
            result_compare = compare_volume_planets(planet_R)
            if lAND_R > planet_R:
                print(f"Земля больше потенциальной планеты радиуса {planet_R} в {result_compare} раз.\n")
            elif lAND_R < planet_R:
                print(f"Земля меньше потенциальной планеты радиуса {planet_R} в {result_compare} раз.\n")
            else:
                print(f"Объем Земли примерно равен объему потенциальной планеты радиуса {planet_R}.\n")
        except ValueError as e:
            print(e)

********************************************************************************

# Часть 1. Модуль 11. Задача 6. Ход конём
#
# В рамках разработки шахматного ИИ стоит новая задача: по заданным вещественным координатам коня
# и точки программа должна определить, может ли конь ходить в эту точку.
# Используйте как можно меньше конструкций if и логических операторов. Обеспечьте контроль ввода.
#
# Пример:
# Введите местоположение коня:
# 0.071
# 0.118
# Введите местоположение точки на доске:
# 0.213
# 0.068
# Конь в клетке (0, 1). Точка в клетке (2, 0).
# Да, конь может ходить в эту точку.
#
# Что оценивается
# Результат вывода соответствует условию.
# Формат вывода соответствует примеру.
# Input содержит корректное приглашение для ввода.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).

def is_exist(horse_x: float, horse_y: float, point_x: float, point_y: float) -> bool:
    return not(0 <= horse_x < 0.8 and 0 <= horse_y < 0.8 and 0 <= point_x < 0.8 and 0 <= point_y < 0.8)  # исключение


def location(horse_x: float, horse_y: float, point_x: float, point_y: float):
    if is_exist(horse_x, horse_y, point_x, point_y):
        raise ValueError(f"\nВы ввели несуществующие координаты.")

    cell_horse_x = int(horse_x * 10)
    cell_horse_y = int(horse_y * 10)

    cell_point_x = int(point_x * 10)
    cell_point_y = int(point_y * 10)

    print(f"\nКонь в клетке ({cell_horse_x}, {cell_horse_y}). Точка в клетке ({cell_point_x}, {cell_point_y}).")

    if ((cell_horse_x == cell_point_x + 1 and cell_horse_y == cell_point_y + 2) or (
        cell_horse_x == cell_point_x + 2 and cell_horse_y == cell_point_y + 1) or (
        cell_horse_x == cell_point_x + 1 and cell_horse_y == cell_point_y - 2) or (
        cell_horse_x == cell_point_x + 2 and cell_horse_y == cell_point_y - 1) or (
        cell_horse_x == cell_point_x - 1 and cell_horse_y == cell_point_y + 2) or (
        cell_horse_x == cell_point_x - 2 and cell_horse_y == cell_point_y + 1) or (
        cell_horse_x == cell_point_x - 1 and cell_horse_y == cell_point_y - 2) or (
        cell_horse_x == cell_point_x - 2 and cell_horse_y == cell_point_y - 1)):
        print('Да, конь может ходить в эту точку.')
    else:
        print('Конь не может ходить в эту точку.')


if __name__ == '__main__':
    test_cases = [
        (0.071, 0.118, 0.213, 0.068),
        (0.345, 0.789, 0.415, 0.602),
        (0.65, 0.89, 0.21, 0.531),
        (0, 0, 0.2, 0.1),
        (1.0, 1.0, 1, 1),
        (-0.1, 0.3, 0.5, 0.7),
    ]

    for horse_x, horse_y, point_x, point_y in test_cases:
        try:
            location(horse_x, horse_y, point_x, point_y)

        except ValueError as e:
            print(e)


********************************************************************************

# Часть 1. Модуль 11. Задача 7. За что?
#
# Написать программу, которая из двух введённых чисел определяет наибольшее,
# не используя при этом условные операторы, циклы и встроенные функции вроде max/min/sorted.
#
# Пример:
# Введите первое число: 10
# Введите второе число: 5
# Наибольшее число: 10
#
# Что оценивается
# Результат вывода соответствует условию.
# Input содержит корректное приглашение для ввода.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).
#
# Советы и рекомендации
# Рассмотрите разность суммы и разности чисел, сумму разности и суммы чисел.
# При необходимости можете использовать функцию abs(), позволяющую взять модуль числа.

def compare_numbers(num1: float, num2: float) -> float:

    amount_numbers = num1 + num2
    difference_numbers = abs(num1 - num2)
    max_numbers = (amount_numbers + difference_numbers) / 2

    return round(max_numbers,2)


if __name__ == '__main__':
    test_cases = [
        (3, 5),
        (27, 1),
        (-27, -2),
        (0, -4),
        (0, 0),
        (4.65, 4.97)
    ]

    for num1, num2 in test_cases:
        result_max = compare_numbers(num1, num2)
        print(f"Из чисел {num1} и {num2} каксимальное: {result_max}")


********************************************************************************

# Часть 1. Модуль 11. Задачи под видео 2.

def mod_11_video_2_1():
    print('\nЗадача m11-v2-1 - Ставки на спорт\n')

    bet = float(input('Сколько ставим?С '))
    ratio = float(input('Какой коэффициент? '))

    print('Потенциальный выигрыш: ', round(bet * ratio, 2))


def mod_11_video_2_2():
    print('\nЗадача m11-v2-2 - День рождения\n')

    age = int(input('Сколько лет? '))
    temperature = float(input('Какая температура тела? '))

    print('Потенциальный подарок: ', round(age * temperature, 2))


def mod_11_video_2_3():
    print('\nЗадача m11-v2-3 - Индекс массы тела\n')

    height = float(input('Рост в метрах: '))
    weight = float(input('Вес в кг.: '))
    body_mass_index = round(weight / height ** 2, 2)
    print('Индекс массы тела: ', body_mass_index)

    if body_mass_index < 18.5:
        print('У вас недобор по весу.')
    elif body_mass_index < 25.0:
        print('У вас нормальный вес.')
    elif body_mass_index < 30.0:
        print('У вас избыточный вес.')
    else:
        print('У вас ожирение!')


mod_11_video_2_3()
# mod_11_video_2_2()
# mod_11_video_2_3()


********************************************************************************

# Часть 1. Модуль 11. Задачи под видео 3.

def mod_11_video_3_1():
    print('\nЗадача m11-v3-1 - Космические рейнджеры\n')

    course_CR, price_ship = 2200, 0.5
    chatles = int(input('Сколько у вас чатлов? '))

    CR = round(chatles / course_CR, 2)
    ships = int(CR / price_ship)

    print(f"У вас {CR} кредитов CR. Вы можете купить {ships} кораблей.")


def mod_11_video_3_2():
    print('\nЗадача m11-v3-2 - Компьютерное зрение\n')

    x_coord = float(input("По горизонтали: "))
    y_coord = float(input("По вертикали: "))

    if 0 < x_coord < 0.8 and 0 < y_coord < 0.8:
        x_number = int(x_coord * 10)
        y_number = int(y_coord * 10)
        print("Фигура находится в клетке (", x_number, ",", y_number, ")")
    else:
        print("Клетки с такой координатой не существует")


def mod_11_video_3_3():
    print('\nЗадача m11-v3-3 - Точность и аккуратность\n')
    x_coord = float(input("По горизонтали: "))
    y_coord = float(input("По вертикали: "))
    if 0 < x_coord < 0.8 and 0 < y_coord < 0.8:
        x_number = int(x_coord * 10)
        y_number = int(y_coord * 10)
        print("Фигура находится в клетке (", x_number, ",", y_number, ")")
        center_x = x_number / 10 + 0.05
        center_y = y_number / 10 + 0.05
        delta_x = round(center_x - x_coord, 3)
        delta_y = round(center_y - y_coord, 3)
        print("Поправьте положение фигуры на (", delta_x, ",", delta_y, ")")
    else:
        print("Клетки с такой координатой не существует")


def mod_11_video_3_4():
    print('\nЗадача m11-v3-4 - Компьютерное зрение плюс точность и аккуратность\n')

    print('Введите местоположение фигуры:')
    X = float(input('По горизонтали (X): '))
    Y = float(input('По вертикали (Y): '))

    if 0 < X < 1 and 0 < Y < 1:
        print(f"\nФигура находится в клетке ({int(X * 10)},{int(Y * 10)})")
        correct_X = round(int(X * 10) / 10 + 0.05 - X, 3)
        correct_Y = round(int(Y * 10) / 10 + 0.05 - Y, 3)
        print(f"Поправьте положение фигуры на ({correct_X}, {correct_Y})")
    else:
        print('\nКлетки с такой координатой не существует!')


mod_11_video_3_1()
# mod_11_video_3_2()
# mod_11_video_3_3()
# mod_11_video_3_4()


********************************************************************************

# Часть 1. Модуль 11. Видео 4. Задача 1. Герон
#
# Существует, так называемая, формула Герона, позволяющая вычислить площадь треугольника,
# зная длины его сторон.
#
# S= √ (p * (p - a)*(p - b)*(p - c)) , где
#
# S - площадь;
# p - полупериметр треугольника (a+b+c)/2;
# a,b,c - длины сторон треугольника.
#
# Напишите программу, которая принимает на вход длины сторон треугольника и выводит его площадь

import math

def is_exist(a: float, b: float, c: float) -> bool:
    return (a + b <= c) or (a + c <= b) or (b + c) <= a


def geron_area_triangle(a: float, b: float, c: float) -> float:
    if is_exist(a, b, c):
        raise ValueError(f"Треугольника со сторонами ({a}, {b}, {c}) не существует ")

    p = int((a + b + c) / 2)
    S = math.sqrt(p * (p - a) * (p - b) * (p - c))
    S = round(S, 4)
    return S


if __name__ == '__main__':
    test_cases = [
        (3, 4, 5),
        (10, 10, 10),
        (0, 0, 0),
        (100, 1, 1),
        (-3, 4, 5),
        (3.5, 4.5, 5.5)
    ]

    for a, b, c in test_cases:
        try:
            result_S = geron_area_triangle(a, b, c)
            print(f"Площадь треугольника со сторонами ({a}, {b}, {c}) по формуле Герона S = {result_S}")
        except ValueError as e:
            print(e)


********************************************************************************

# Часть 1. Модуль 11. Видео 4. Задача 2. Игра
#
# Вам предстоит создать 2D-игру (вид сверху, игрок двигается в двух плоскостях).
#
# Начнём с управления персонажем: получаем от игрока пройденное расстояние и угол,
# по которому двигался персонаж. Зная эту информацию,
# нужно изменить текущие координаты (0, 0) на новые (х, у).
# Чтобы это сделать, требуется узнать, какое расстояние персонаж преодолеет
# по горизонтали (по оси Х, x = расстояние × косинус угла)
# и по вертикали (по оси У, y = расстояние × синус угла).
#
# Напишите программу, которая получает на вход расстояние и угол поворота.
# Выведите координаты нового местоположения персонажа.

import math

def coordinates(distance: float, angle: float):

    angle /= 57.2958
    x = round(math.cos(angle) * distance, 2)
    y = round(math.sin(angle) * distance, 2)

    return (x, y)


if __name__ == '__main__':
    test_cases = [
        (-30, 180),
        (10, 90),
        (0, 370),
        (30, -30),
        (1, 30),
        (3.5, 91)
    ]

    for distance, angle in test_cases:
        result_coordinates = coordinates(distance, angle)
        print(f"Пройдено расстояние {distance} единиц под углом {angle} градусов. "
              f"Новые координаты (x, y) = {result_coordinates}")


********************************************************************************

# Часть 1. Модуль 11. Видео 4. Задача 3. Мега-калькулятор
#
# Напишите программу, которая получает от пользователя вещественное число,
# по очереди применяет к нему функции модуля Math и выводит результат:
# округляет вниз
# округляет вверх
# берет модуль числа
# извлекает квадратный корень
# возводит экспоненту в степень, равную числу
# считает натуральный логарифм числа
# считает логарифм числа по основанию 2
# считает логарифм числа по основанию 10
# считает синус и косинус числа
#
# Посчитать факториал числа. Реализовать контроль ввода:
# факториал вычисляется, только если введенное число было натуральным.

import math

def is_negative(x: float) -> bool:
    return x < 0


def is_float(x: float) -> bool:
    return isinstance(x, float)


def factorial_number(x: int):
    if is_negative(x):
        raise ValueError(f"Факториал вычисляется только от натурального числа, а это отрицательное!")
    elif is_float(x):
        raise ValueError(f"Факториал вычисляется только от натурального числа, а это дробное!")

    return math.factorial(x)


def abs_number(x: float):
    return abs(x)


def floor_number(x: float):
    return math.floor(x)


def ceil_number(x: float):
    return math.ceil(x)


def sqrt_number(x: float):
    if is_negative(x):
        raise ValueError(f"Не будем сейчас извлекать корень из отрицательного числа.")

    return math.sqrt(x)


def exp_number(x: float):
    return math.exp(x)


def log_number(x: float):
    if is_negative(x) or x == 0:
        raise ValueError(f"Натуральный логарифм от отрицательного числа не существует, а нуля - это неопределенность!")
    return math.log(x)


def log2_number(x: float):
    if is_negative(x) or x == 0:
        raise ValueError(f"Логарифм по основанию 2 от отрицательного числа не существует, а от нуля - это неопределенность!")
    return math.log2(x)


def log10_number(x: float):
    if is_negative(x) or x == 0:
        raise ValueError(f"Десятичный логарифм от отрицательного числа не существует, а от нуля - это неопределенность!")
    return math.log10(x)


def sin_x(x: float):
    x /= 57.2958

    return math.sin(x)


def cos_x(x: float):
    x /= 57.2958

    return math.cos(x)


if __name__ == '__main__':
    test_cases = [
        (-1),
        (0),
        (1),
        (3),
        (1.5),
        (5),
        (250),
        (-12.0964)
    ]

    for x in test_cases:

        result_abs = abs_number(x)
        print(f"Модуль {x} = {result_abs}\n")

        result_floor = floor_number(x)
        print(f"Округленный в пол {x} = {result_floor}\n")

        result_ceil = ceil_number(x)
        print(f"Округленный в потолок {x} = {result_ceil}\n")

        result_sin = sin_x(x)
        print(f"sin({x}) = {result_sin}\n")

        result_cos = cos_x(x)
        print(f"cos({x}) = {result_cos}\n")

        result_exp = exp_number(x)
        print(f"Число e в степени x, e^{x} = {result_exp}\n")

        try:
            result_sqrt = sqrt_number(x)
            print(f"Квадратный корень из {x} = {result_sqrt}\n")

            result_log = log_number(x)
            print(f"Натуральный логарифм (по основанию e) числа {x} = {result_log}\n")

            result_log2 = log2_number(x)
            print(f"Двоичный логарифм числа {x} = {result_log2}\n")

            result_log10 = log10_number(x)
            print(f"Десятичный логарифм числа {x} = {result_log10}\n")

            result_factorial = factorial_number(x)
            print(f"{x}! = {result_factorial}\n")

        except ValueError as e:
            print(e)
        finally:
            print(f"Число e = {math.e}, число Пи = {math.pi}\n")


********************************************************************************

# Часть 1. Модуль 11. Индекс массы тела

height = float(input('Рост в метрах: '))
weight = float(input('Вес в кг.: '))
body_mass_index = weight / height**2

print(f"Индекс массы тела: {body_mass_index:.2f}")

if body_mass_index < 18.5:
    print('У вас недобор по весу.')
elif body_mass_index < 25.0:
    print('У вас нормальный вес.')
elif body_mass_index < 30.0:
    print('У вас избыточный вес.')
else:
    print('У вас ожирение!')


********************************************************************************

# Часть 1. Модуль 12. Задача 1. Сумма чисел
#
# Напишите функцию summa_n, которая принимает одно целое положительное число N
# и выводит сумму всех чисел от 1 до N включительно.
#
# Пример работы программы:
# Введите число: 5
# Я знаю, что сумма чисел от 1 до 5 равна 15
#
# Что оценивается
# Результат вывода соответствует условию.
# В input содержится корректное приглашение для ввода.
# Формат вывода соответствует примеру.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).

def summa_n(number: int):
    summ = 0
    for i in range(1, number+1):
        summ += i
    return summ

number = int(input('Введите число: '))
print(f"Сумма чисел от 1 до {number} равна {summa_n(number)}")


********************************************************************************

# Часть 1. Модуль 12. Задача 2. Функция в функции
#
# Основная ветка программы, не считая заголовков функций, состоит из одной строки кода.
# Это вызов функции test(). В ней запрашивается на ввод целое число.
# Если оно положительное, то вызывается функция positive(),
# тело которой содержит команду вывода на экран слова «Положительное».
# Если число отрицательное, то вызывается функция negative(),
# её тело содержит выражение вывода на экран слова «Отрицательное».
#
# Что оценивается
# Результат вывода соответствует условию.
# В input содержится корректное приглашение для ввода.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).

def positive():
    print('Положительное')


def negative():
    print('Отрицательное')


def test():
    number = int(input('Введите целое число: '))
    if number >= 0:
        positive()
    else:
        negative()


if __name__ == '__main__':
    test()


********************************************************************************

# Часть 1. Модуль 12. Задача 3. Апгрейд калькулятора
#
# Напишите программу, запрашивающую у пользователя число и действие,
# которое нужно сделать с числом: вывести сумму его цифр, максимальную или минимальную цифру.
# Каждое действие оформите в виде отдельной функции, а основную программу зациклите.
#
# Запрошенные числа должны передаваться в функции суммы, максимума и минимума при помощи аргументов.
#
# Что оценивается
# Результат вывода соответствует условию.
# В input содержится корректное приглашение для ввода.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).
# Нет обращения к глобальным переменным снаружи функции.
# Числа, с которыми должны работать функции, передаются через аргументы.
# Советы и рекомендации
# Не забывайте, что параметры функции и переменные снаружи могут иметь разные названия.

def sum_digits(number):
    sum_digit = 0
    for digit in number:
        sum_digit += int(digit)
    print(f"Сумма цифр числа {number} равна {sum_digit}.")


def max_digits(number):
    list_digits = []
    for digit in number:
        list_digits.append(int(digit))
    return max(list_digits)


def min_digits(number):
    list_digits = []
    for digit in number:
        list_digits.append(int(digit))
    return min(list_digits)

number = input('Введите число: ')


def main_menu():
    print('Выберите, что нужно сделать?\n'
          '1 - вывести сумму цифр\n'
          '2 - вывести максимальную цифру\n'
          '3 - вывести минимальную цифру\n'
          'Для выхода из программы введите 0.')
    choice = int(input('Ваш выбор: '))

    if choice == 1:
        sum_digits(number)
    elif choice == 2:
        print(f"Максимальная цифра числа {number} равна {max_digits(number)}.")
    elif choice == 3:
        print(f"Минимальная цифра числа {number} равна {min_digits(number)}.")
    elif choice == 0:
        print('Пока!')
        exit()
    else:
        print('Ошибка ввода: введите 1, 2 или 3.')
    main_menu()


main_menu()


********************************************************************************

# Часть 1. Модуль 12. Задача 4. Число наоборот
#
# Вводится последовательность чисел, оканчивающаяся нулём.
# Реализуйте функцию, которая принимает в качестве аргумента каждое число,
# переворачивает его и выводит на экран.
#
# Пример:
# Введите число: 1234
# Число наоборот: 4321
# Введите число: 1000
# Число наоборот: 0001
# Введите число: 0
# Программа завершена!
#
# Дополнительно: добейтесь такого вывода чисел, в начале которых идут нули.
# Пример:
# Введите число: 1230
# Число наоборот: 321
#
# Ноль, который мы убрали, называется ведущим.
#
# Что оценивается
# Результат вывода соответствует условию.
# Формат вывода соответствует примеру.
# В input содержится корректное приглашение для ввода.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).

def opposite_numbers(some_sequence:str):

    temp_list_numbers = []
    list_numbers = []
    new_number = ''
    for number in some_sequence:
        for i in range(0, len(number)):
            temp_list_numbers.append(number[i])
        temp_list_numbers.reverse()
        new_number = "".join(temp_list_numbers)
        list_numbers.append(str(int(new_number)))
        temp_list_numbers.clear()
    return list_numbers


if __name__ == '__main__':
    test_cases = [
        ('12345', '6789', '1080', '160', '4054', '0'),
        ('1', '0'),
        ('0'),
        ('0000', '000', '00', '0'),
        ]

    for some_sequence in test_cases:
        result_sequence = opposite_numbers(some_sequence)
        print(f"Исходная последовательность {some_sequence}:"
              f"\nПоследовательность наоборот: {result_sequence}")


********************************************************************************

# Альтернативное решение. Часть 1. Модуль 12. Задача 4. Число наоборот
#
# Принимает число в последовательности и переворачивает его.
#
# Альтернативное решение

def opposite_number(some_sequence:str) -> int:
    rebmun = ''.join(reversed(some_sequence))
    return int(rebmun)


if __name__ == '__main__':
    test_cases = [
        ('123450'),
        ('10'),
        ('0'),
        ('0000'),
        ]

    for some_sequence in test_cases:
        result_sequence = opposite_number(some_sequence)
        print(f"Исходная последовательность {some_sequence}:\n"
              f"Последовательность наоборот: {result_sequence}\n")


********************************************************************************

# Часть 1. Модуль 12. Задача 5. Текстовый редактор
#
# Напишите функцию count_letters(), которая принимает на вход текст и подсчитывает,
# какое в нём количество цифр K и букв N. Функция должна вывести на экран
# информацию о найденных буквах и цифрах в определённом формате.
#
# Пример:
#
# Введите текст: 100 лет в обед
# Какую цифру ищем? 0
# Какую букву ищем? Л
#
# Количество цифр 0: 2
# Количество букв Л: 1
#
# Что оценивается
# Результат вывода соответствует условию.
# В input содержится корректное приглашение для ввода.
# Формат вывода соответствует примеру.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).

def count_symbols(text: str):
    print(text)
    letter = str(input('Введите букву, которую будем считать: '))
    finger = str(input('Введите цифру, которую будем считать: '))
    letter = letter.lower()
    text = text.lower()

    count_letter, count_finger = 0, 0

    for symbol in text:
        if symbol == letter:
            count_letter += 1
        if symbol == finger:
            count_finger += 1
    return count_letter, count_finger


if __name__ == '__main__':
    test_cases = [
        ('100 Лет в Обед'),
        ('Когда 100 лет? Кому обед, а кому котлет?'),
        ('   @   '),
        (''),
        ]

    for text in test_cases:
        result = count_symbols(text)
        print(f"(букв, цифр) = {result}\n")


********************************************************************************

# Альтернативное решение. Часть 1. Модуль 12. Задача 5. Текстовый редактор
#
# # Альтернативное решение с использованием модуля

import re

def count_letters(some_string):
    match_d = re.findall('(\d)', some_string)
    match_w = re.findall('(\w)', some_string)
    return [len(match_d), len(match_w) - len(match_d)]



if __name__ == '__main__':
    test_cases = [
        ('123456789'),
        ('asЖdfghK JG'),
        ('kjo989yjyghРЛДttr6ь647087yg'),
        ('    @   '),
        ('kjo 9Ъ89y jyghВt"№tr 664@70 87yg'),
        ]

    for some_string in test_cases:
        result = count_letters(some_string)
        print(f"Кол-во [цифр, букв] в строке '{some_string}': {result} из {len(some_string)}")


********************************************************************************

# Альтернативное решение 2. Часть 1. Модуль 12. Задача 5. Текстовый редактор
#
# Альтернативное решение прямым путем

def count_letters(some_string: str) -> tuple[int, int, int]:

    count_digit, count_alpha, count_different, count_other = 0, 0, 0, 0

    for letter in some_string:
        if (
                letter == '0' or letter == '1' or letter == '2' or letter == '3'
                or letter == '4' or letter == '5' or letter == '6' or letter == '7'
                or letter == '8' or letter == '9'
            ):
            count_digit += 1
        elif (
                letter == 'a' or letter == 'A' or letter == 'b' or letter == 'B'
                or letter == 'c' or letter == 'C' or letter == 'd' or letter == 'D'
                or letter == 'e' or letter == 'E' or letter == 'f' or letter == 'F'
                or letter == 'g' or letter == 'G' or letter == 'h' or letter == 'H'
                or letter == 'i' or letter == 'I' or letter == 'j' or letter == 'J'
                or letter == 'k' or letter == 'K' or letter == 'l' or letter == 'L'
                or letter == 'm' or letter == 'M' or letter == 'n' or letter == 'N'
                or letter == 'o' or letter == 'O' or letter == 'p' or letter == 'P'
                or letter == 'q' or letter == 'Q' or letter == 'r' or letter == 'R'
                or letter == 's' or letter == 'S' or letter == 't' or letter == 'T'
                or letter == 'u' or letter == 'U' or letter == 'v' or letter == 'V'
                or letter == 'w' or letter == 'W' or letter == 'x' or letter == 'X'
                or letter == 'y' or letter == 'Y' or letter == 'z' or letter == 'Z'
                or letter == 'а' or letter == 'А' or letter == 'б' or letter == 'Б'
                or letter == 'в' or letter == 'В' or letter == 'г' or letter == 'Г'
                or letter == 'д' or letter == 'Д' or letter == 'е' or letter == 'Е'
                or letter == 'ё' or letter == 'Ё' or letter == 'ж' or letter == 'Ж'
                or letter == 'з' or letter == 'З' or letter == 'и' or letter == 'И'
                or letter == 'й' or letter == 'Й' or letter == 'к' or letter == 'К'
                or letter == 'л' or letter == 'Л' or letter == 'м' or letter == 'М'
                or letter == 'н' or letter == 'Н' or letter == 'о' or letter == 'О'
                or letter == 'п' or letter == 'П' or letter == 'р' or letter == 'Р'
                or letter == 'с' or letter == 'С' or letter == 'т' or letter == 'Т'
                or letter == 'у' or letter == 'У' or letter == 'ф' or letter == 'Ф'
                or letter == 'х' or letter == 'Х' or letter == 'ц' or letter == 'Ц'
                or letter == 'ч' or letter == 'Ч' or letter == 'ш' or letter == 'Ш'
                or letter == 'щ' or letter == 'Щ' or letter == 'ь' or letter == 'Ь'
                or letter == 'ы' or letter == 'Ы' or letter == 'ъ' or letter == 'Ъ'
                or letter == 'э' or letter == 'Э' or letter == 'ю' or letter == 'Ю'
                or letter == 'я' or letter == 'Я'
            ):
            count_alpha += 1
        else:
            count_different += 1

    return count_digit, count_alpha, count_different


if __name__ == '__main__':
    test_cases = [
        ('123456789'),
        ('asЖdfghK JG'),
        ('kjo989yjyghРЛДttr6ь647087yg'),
        ('    @   '),
        ('kjo 9Ъ89y jyghВt"№tr 664@70 87yg'),
        ]

    for some_string in test_cases:
        result = count_letters(some_string)
        print(f"Кол-во [цифр, букв, прочих символов] в строке '{some_string}': {result}")


********************************************************************************

# Часть 1. Модуль 12. Задача 6. НОД
#
# Напишите функцию, вычисляющую наибольший общий делитель двух чисел.
# Разложим на простые множители 18 = 2 • 3 • 3
# Разложим на простые множители 35 = 5 • 7
# Выберем одинаковые простые множители в обоих числах. Одинаковые простые множители отсутствуют
# Находим произведение одинаковых простых множителей и записываем ответ НОД (18; 35) = 1
#
# Что оценивается
# Результат вывода соответствует условию.
# В input содержится корректное приглашение для ввода.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).

import math

def n_o_d(number_1: int, number_2: int) -> int:

    nod = 1

    if number_1 > number_2:
        smaller = number_2
    else:
        smaller = number_1

    for i in range(1, smaller + 1):
        try:
            if((number_1 % i == 0) and (number_2 % i == 0)):
                nod = i
        except ZeroDivisionError:
            return 0
    return nod


if __name__ == '__main__':
    test_cases = [
        (12, 34),
        (34, 12),
        (49, 7),
        (350, 800),
        (200, 224),
        (1, 0),
        ]

    for number_1, number_2 in test_cases:

            result = n_o_d(number_1, number_2)
            print(f"Проверка функцией: {math.gcd(number_1, number_2)}")
            print(f"Наибольший общий делитель чисел {number_1} и {number_2}: {result}\n")


********************************************************************************

# Часть 1. Модуль 12. Задача 7. Недоделка
#
# Используя шаблон, реализуйте игры «Камень, ножницы, бумага» и «Угадай число».
#
# def rock_paper_scissors():
#   # Здесь будет игра «Камень, ножницы, бумага»
#
# def guess_the_number():
#   # Здесь будет игра «Угадай число»
#
# def mainMenu():
#   # Здесь главное меню игры
#
# mainMenu():
#   pass
#
# Правила игры «Камень, ножницы, бумага»:
# программа запрашивает у пользователя строку и выводит, победил он или проиграл.
# Камень бьёт ножницы, ножницы режут бумагу, бумага кроет камень.
#
# Правила игры «Угадай число»:
# программа запрашивает у пользователя число до тех пор, пока он не отгадает загаданное.
#
# Что оценивается
# Игры работают корректно.
# В input содержится корректное приглашение для ввода.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).

import random

def word_ending(count):
    text = ''
    if (count == 1) or ((count > 20) and (count % 10 == 1)):
        text = 'ку'
    elif ((count == 2) or (count == 3) or (count == 4)) or ((count > 20) and ((count % 10 == 2) or (count % 10 == 3) or (count % 10 == 4))):
        text = 'ки'
    else:
        text = 'ок'
    return text


def rock_paper_scissors():
    print('\n','*' * 10, 'Добро пожаловать в игру «Камень, ножницы, бумага»', '*' * 10)

    gamer, score, count = 1, 0, 0

    while gamer:
        count += 1
        rand = int(random.randint(1, 3))

        dict_rps = {
            1 : '«камень»',
            2 : '«ножницы»',
            3 : '«бумага»'
        }

        gamer = int(input('\nДля выхода введите 0.\nВведите «камень» - 1, «ножницы» - 2 или «бумага» - 3: '))

        if gamer == 0:
            break
        elif (rand == 1 and gamer == 2) or (rand == 2 and gamer == 3) or (rand == 3 and gamer == 1):
            print(f"Ваш выбор: {gamer} - {dict_rps.setdefault(gamer)}")
            print(f"Случайный выбор компьютера: {rand} - {dict_rps.setdefault(rand)}")
            print('Вы проиграли!')
        elif (rand == 1 and gamer == 3) or (rand == 2 and gamer == 1) or (rand == 3 and gamer == 2):
            score = score + 1
            print(f"Ваш выбор: {gamer} - {dict_rps.setdefault(gamer)}")
            print(f"Случайный выбор компьютера: {rand} - {dict_rps.setdefault(rand)}")
            print(f"УРА! Вы выиграли {score} раз, сделав {count} попыт{word_ending(count)}.")
        elif rand == gamer:
            print('Ничья!')
        else:
            print('Ошибка ввода! Введите 1, 2 или 3. Для выхода из игры введите 0.')
            mainMenu()
    print('Пока!')
    mainMenu()


def guess_the_number():
    print('\n','*' * 10, 'Добро пожаловать в игру «Угадай число»', '*' * 10)
    print("Компьютер будет загадывать число от 1 до 10. Попробуйте угадать!")

    answer, score, count = 1, 0, 0

    while answer:
        count += 1
        rand = random.randint(1, 10)
        answer = int(input('Для выхода введите 0.\nЧисло загадано. Введи своё предположение: '))

        if answer == 0:
            break
        elif answer == rand:
            score = score + 1
            print(f"Правильно! Ты отгадал {score} раз, сделав {count} попыток.")
        else:
            print('Неверно!')

    print('Пока!')
    mainMenu()


def mainMenu():
    choice = input('\nВо что будем играть?\n1 - «Камень, ножницы, бумага»,\n2 - «Угадай число».\nВаш выбор: ')
    if choice == '1':
        rock_paper_scissors()
    elif choice == '2':
        guess_the_number()
    else:
        print('Ошибка ввода: введите 1 или 2.')
        mainMenu()

mainMenu()


********************************************************************************

# Часть 1. Модуль 12. Видео 2. Задача 1. Робот
#
# В одном отеле для эксперимента на вход хотят поставить робота,
# который будет спрашивать у прохожих, не желают ли они зайти.
# При ответе «Да» робот должен приветствовать человека и пустить в отель.
# Для робота написали вот такую программу с использованием функции:
#
# Def greeting()
#    print('Привет!')
# print('Добро пожаловать!')
#
# while True:
#    a = input('Зайдёте? Да/Нет: ')
#    if a = 'Да':
#        greeting
#    print('Следующий.\n')
# Однако программист очень торопился и допустил несколько ошибок.
# Скопируйте программу в реплит, найдите и исправьте ошибки. Убедитесь, что программа работает корректно.
#
# Пример результата:
# Зайдёте? Да/Нет: Да
# Привет!
# Добро пожаловать!
# Следующий.
#
# Зайдёте? Да/Нет: Да
# Привет!
# Добро пожаловать!
# Следующий.
#
# Зайдёте? Да/Нет: Нет
# Следующий.
# Зайдёте? Да/Нет: ...

def greeting():
    print('Привет!')
    print('Добро пожаловать!')

while True:
    a = input('Зайдёте? Да/Нет: ')
    if a == 'Да':
        greeting()
    print('Следующий.\n')


********************************************************************************

# Часть 1. Модуль 12. Видео 2. Задача 2. Провизия
#
# Одна государственная компания поставляет еду на разные труднодоступные базы
# (полярные, горные и так далее) в разных уголках страны.
# В компании для удобства расчёта количества еды была реализована такая программа:
#
# print("Сколько мешков рыбы и мяса?")
# a = int(input())
# b = int(input())
# print("Всего", a+b, "шт.")
# print("Сколько буханок белого и чёрного хлеба?")
# a = int(input())
# b = int(input())
# print("Всего", a+b, "шт.")
# print("Сколько вёдер воды и молока?")
# a = int(input())
# b = int(input())
# print("Всего", a+b, "шт.")
#
# Скопируйте программу в реплит и модифицируйте её: напишите функцию, которая заменит повторяющийся код внутри основной программы.

def counting_provisions():
    a = int(input('Введите кол-во мешков продукции 1-го вида: '))
    b = int(input('Введите кол-во мешков продукции 2-го вида: '))
    print("Всего", a+b, "шт.\n")

print("Сколько мешков рыбы и мяса?")
counting_provisions()
print("Сколько буханок белого и чёрного хлеба?")
counting_provisions()
print("Сколько вёдер воды и молока?")
counting_provisions()


********************************************************************************

# Часть 1. Модуль 12. Видео 2. Задача 3. Почта
#
# Напишите функцию для вывода фамилии, имени и адреса для конкретного члена семьи.
# Выведите информацию о нём три раза (без цикла).
#
# Пример результата:
#
# Фамилия: Иванов
# Имя: Василий
# Улица: Пушкина
# Дом: 32
#
# Фамилия: Иванов
# Имя: Василий
# Улица: Пушкина
# Дом: 32
#
# Фамилия: Иванов
# Имя: Василий
# Улица: Пушкина
# Дом: 32

def addressee():
    addressees_last_name = input('Фамилия: ')
    addressees_name = input('Имя: ')
    addressees_street = input('Улица: ')
    addressees_house_number = input('Дом: ')
    print()

addressee()
addressee()
addressee()


********************************************************************************

# Часть 1. Модуль 12. Видео 3. Задача 1. Вода
#
# Напишите программу, которая три раза вызывает функцию aboutWater, передаёт в неё
# один аргумент — цену на воду и выводит на экран название воды, производителя и цену.
#
# Пример:
#
# Название: КлирВотер
# Производитель: ВодЗавод
# Цена: 25
#
# Название: КлирВотер
# Производитель: ВодЗавод
# Цена: 30
#
# Название: КлирВотер
# Производитель: ВодЗавод
# Цена: 40

def water_cost(price):
    print('Название: КлирВотер')
    print('Производитель: ВодЗавод')
    print(f"Цена: {price}\n")

water_cost(23.00)
water_cost(45.61)
water_cost(31.03)


********************************************************************************

# Часть 1. Модуль 12. Видео 3. Задача 2. Вот это объёмы 2
#
# Напишите программу, которая на вход получает от пользователя радиус планеты
# (вещественное число) и вызывает функции sphereArea и sphereVolume.
# Реализуйте эти функции: первая считает и выводит на экран площадь сферы, вторая — объём шара.

import math

land_radius = 6569.925261403126
land_area = 510072000
land_volume = 1.08321 * (10**12)

print(f"Радиус Земли = {land_radius}\nПлощадь поверхности Земли = {land_area}\nОбъем Земли = {land_volume}\n")


def is_exist(radius: float) -> bool:
    return radius < 0


def sphere_area(radius: float) -> float:
    if is_exist(radius):
        raise ValueError(f"Радиус должен быть положительным.\n")
    return 4 * math.pi * radius**2


def ball_volume(radius: float) -> float:
    if is_exist(radius):
        raise ValueError(f"Радиус должен быть положительным.\n")
    return (4/3) * math.pi * radius**3



if __name__ == '__main__':
    test_cases = [(6569.925261403126),
                  (6371.00604465),
                  (-5000),
                  (0),
                  (7000),
                  (5000),
                  (0.0002)
                 ]

    for radius in test_cases:
        try:
            result_area = sphere_area(radius)
            print(f'Площадь поверхности сферы радиуса {radius} равна {result_area}')
            result_volume = ball_volume(radius)
            print(f'Объем шара радиуса {radius} равен {result_volume}')
            print()
        except ValueError as err:
            print(err)


********************************************************************************

# Часть 1. Модуль 12. Видео 3. Задача 3. Простые числа
#
# Пользователь вводит число N — количество чисел в последовательности.
# Напишите программу, которая проверяет, сколько из этих чисел являются простыми.
# Для проверки простоты числа реализуйте функцию isPrime.

def is_prime(number):
    for i in range(2, int(number ** 0.5) + 1):
        if number % i == 0:
            print("Не простое")
            break
    else:
        print("Простое")

# ** 0.5 - это по сути взятие корня из числа. Нам нет необходимости проверять числа дальше корня, т.к.
# проверив все множители до корня - мы проверим все возможные варианты делимости числа.

n = int(input("Введите количество чисел в последовательности: "))
for i in range(n):
    new_number = int(input("Введите число: "))
    is_prime(new_number)


# В целом с нашими текущими знаниями этого решения достаточно. Посчитать количество придётся вручную.
# Но решим задачку и вторым вариантом с забеганием вперед:

def is_prime(number):
    for i in range(2, int(number ** 0.5) + 1):
        if number % i == 0:
            return False
    return True


n = int(input("Введите количество чисел в последовательности: "))
count = 0
for i in range(n):
    new_number = int(input("Введите число: "))
    if is_prime(new_number):
        count += 1

print(count)


********************************************************************************

# Часть 1. Модуль 12. Видео 3. Задача 4. Простые числа 2
#
# Проверяет, является ли число из последовательности простым, и выводит простые.

def is_prime(number: float) -> bool:
    n = number**0.5 + 1
    for i in range(2, int(n)):
        if number % i == 0:
            return False
    return True


def prime_list(list_numbers: list) -> list:

    prime_list_numbers = []

    for number in list_numbers:
        if is_prime(number) and number >=2:
            prime_list_numbers.append(number)

    return prime_list_numbers


if __name__ == '__main__':
    test_cases = [
        (5449, 6863, 387, 725, 4, 3019, 1, 3017, 3011, 0, 3010, 3009),
        (0, 1, 37, 2, 30, 25, 0.12),
        ]

    for list_numbers in test_cases:
        result = prime_list(list_numbers)
        print(f'Подпоследовательность простых чисел из {list_numbers}:\n{result}\n')


********************************************************************************

# Часть 1. Модуль 12. Видео 4. Задача 1. Среднее арифметическое
#
# Программа получает от пользователя два числа — a и b.
# Реализуйте функцию, которая принимает на вход числа a и b, считает
# и выводит в консоль среднее арифметическое всех чисел из отрезка [a; b].
# Обеспечьте контроль ввода: не забывайте, что а всегда должно быть меньше, чем b.
#
# Пример:
# Введите левую границу: 3
# Введите правую границу: 8
# Среднее: 5.5
#
# Усложнение: сделайте это без использования циклов.

def arithmetic_mean(a:float, b:float) -> float:
    return round((a + b) / 2, 2)


def arithmetic_mean_2(a: float, b: float) -> float:
    if a > b:
        a, b = b, a
    sum_numbers, count_numbers = 0, 0
    for i in range(int(a), int(b) + 1):
        sum_numbers += i
        count_numbers += 1
    return round(sum_numbers / count_numbers, 2)


if __name__ == '__main__':
    test_cases = [
        (2, 5),
        (0, 1),
        (10, 3),
        (10.5, 3.25),
        (1, -2)
        ]

    for a, b in test_cases:
        result = arithmetic_mean_2(a, b)
        print(f'Среднее арифметическое чисел на отрезке [{a}, {b}]: {result}\n')


********************************************************************************

# Часть 1. Модуль 12. Видео 4. Задача 2. Почта 2
#
# Реализуйте функцию, которая получает все эти данные и выводит на экран.
# В программе вызовите функцию три раза с разными значениями аргументов.
# Подсказка: семь аргументов:
# фамилия, имя, страна проживания, город, улица, номер дома и номер квартиры

def post_info(last_name, name, country, city, street, house_number, apartment_number):
    print(f"Фамилия: {last_name}\n"
          f"Имя: {name}\n"
          f"Страна: {country}\n"
          f"Город: {city}\n"
          f"Улица: {street}\n"
          f"Номер дома: {house_number}\n"
          f"Номер квартиры: {apartment_number}\n")


for _ in range(3):
    user_last_name = input("Введите фамилию: ")
    user_name = input("Введите имя: ")
    user_country = input("Введите страну: ")
    user_city = input("Введите город: ")
    user_street = input("Введите улицу: ")
    user_house_number = input("Введите номер дома: ")
    user_apartment_number = input("Введите номер квартиры: ")

    post_info(user_last_name, user_name, user_country, user_city, user_street,
              user_house_number, user_apartment_number)


********************************************************************************

# Часть 1. Модуль 12. Видео 4. Задача 3. GPS-навигатор 2.0
#
# Напишите программу, где у пользователя спрашивается, чего он хочет —
# найти расстояние от себя до точки или найти расстояние между двумя
# произвольными точками, после чего запрашиваются
# необходимые координаты точек и выводится ответ на экран.

import math

def location_self(x, y):
    distance = math.sqrt(x**2 + y**2)
    print(f"{distance}")


def location_objects(x1, y1, x2, y2):
    distance = math.sqrt((x2-x1)**2 + (y2-y1)**2)
    print(f"{distance}")


def main_menu():

    print('Введите 1, если хотете узнать расстояние от себя до объекта.')
    print('Введите 2, если хотете узнать расстояние от 1-го объекта до 2-го объекта.')
    choice = int(input('Ваш выбор: '))

    if choice == 1:
        x = float(input('Введите координату х: '))
        y = float(input('Введите координату y: '))
        location_self(x, y)

    elif choice == 2:
        x1 = float(input('Введите координату х1: '))
        y1 = float(input('Введите координату y1: '))
        x2 = float(input('Введите координату х2: '))
        y2 = float(input('Введите координату y2: '))
        location_objects(x1, x2, y1, y2)

    else:
        print('Ошибка ввода: введите 1 или 2.')

        main_menu()

main_menu()


********************************************************************************

# Часть 1. Модуль 13. Задача 1. Урок информатики 2
#
# Задано положительное число x (x > 0).
# Преобразовать x > 0 в формат x = a * 10^b, где 1 ≤ a < 10. Обеспечьте контроль ввода.
# Обратите внимание, что x теперь больше нуля, а не больше единицы. Обеспечьте контроль ввода.
#
# Пример 1:
# Введите число: 92345
# Формат плавающей точки: x = 9.2345 * 10 ** 4
#
# Пример 2:
# Введите число: 0.0012
# Формат плавающей точки: x = 1.2 * 10 ** -3
#
# Что оценивается
# Результат вывода соответствует условию.
# Обеспечен контроль ввода и обрабатываемые числа > 0.
# Input содержит корректное приглашение для ввода.
# Формат вывода соответствует примеру.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).

def is_number_negative(number:float) -> bool:
    return number <= 0


def floating_point_format(number:float):
    if is_number_negative(number):
        raise ValueError(f"Ошибка ввода. Введите x > 0.")

    count = 0
    if number < 1:
        while number < 1:
            number *= 10
            count -= 1
    elif number >=10:
        while number >= 10:
            number /= 10
            count += 1
    return f"Формат плавающей точки: x = {number} * 10 ** {count}"


if __name__ == '__main__':
    test_casas = [
        (8.999995770864189e-07),
        (2.1999994714860804e-06),
        (1.100000190490391e-06),
        (0.000001),
        (567800),
        (1000),
        (0.1),
        (12),
        (100000000001),
        (2),
        (-1),
        (0)
    ]
    try:
        for number in test_casas:
            result = floating_point_format(number)
            print(result)

    except ValueError as e:
        print(e)


********************************************************************************

# Часть 1. Модуль 13. Задача 2. Функция максимума
#
# Написать программу, которая находит максимум из трёх чисел.
# Для этого используйте только функцию нахождения максимума из двух чисел.
# По итогу в программе должны быть реализованы две функции:
#
# maximum_of_two — функция принимает два числа и возвращает одно (наибольшее из двух);
# maximum_of_three — функция принимает три числа и возвращает одно (наибольшее из трёх);
# при этом она должна использовать для сравнений первую функцию maximum_of_two.
#
# Что оценивается
# Результат вывода соответствует условию.
# Найден корректный максимум трёх чисел.
# Input содержит корректное приглашение для ввода.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).
# maximum_of_two — функция принимает два числа и возвращает одно (наибольшее из двух);
# maximum_of_three — функция принимает три числа и возвращает одно (наибольшее из трёх);
# при этом она должна использовать для сравнений первую функцию maximum_of_two.

def maximum_of_two(num1: float, num2: float):
    if num1 > num2:
        return num1
    else:
        return num2


def maximum_of_three(num1: float, num2: float, num3: float):
    if maximum_of_two(num1, num2) > num3:
        return maximum_of_two(num1, num2)
    else:
        return num3


if __name__ == '__main__':
    test_cases = [
        (1, 2, 3),
        (217, -0.5, 0),
        (0.1, 0.301, 0.25),
        (-0.25, 0.25, 0.25),
        (0.15, -0.15, -0.15),
        (1, 1, 1),
        (-1/2**2, -1/3**3, -1/4**4),
        (-2, -1, -3),
        (8.999995770864189e-07, 2.1999994714860804e-06, 1.100000190490391e-06)
    ]
    for num1, num2, num3 in test_cases:
        result = maximum_of_three(num1, num2, num3)
        print(f"Максимальное число из {num1}, {num2}, {num3}: {result}")


********************************************************************************

# Часть 1. Модуль 13. Задача 3. Число наоборот 2
#
# Пользователь вводит два числа: N и K. Напишите программу,
# которая заменяет каждое число на число, которое получается из исходного
# записью его цифр в обратном порядке, затем складывает их,
# снова переворачивает и выводит ответ на экран.
#
# Пример:
# Введите первое число: 102
# Введите второе число: 123
# Первое число наоборот: 201
# Второе число наоборот: 321
# Сумма: 522
# Сумма наоборот: 225
#
# Что оценивается
# Результат вывода соответствует условию.
# Input содержит корректное приглашение для ввода.
# Формат вывода соответствует примеру.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).

def flip_number_reverse_order(str_number: str) -> int:
    reverse_str_number = ''
    for i in range(1, len(str_number) + 1):
        reverse_str_number += str_number[-i]
    return int(reverse_str_number)


if __name__ == '__main__':
    num1 = input("Введите первое число: ")
    reverse_mum1 = flip_number_reverse_order(str(num1))
    print(f"Число наоборот: {reverse_mum1}\n")

    num2 = input("Введите второе число: ")
    reverse_mum2 = flip_number_reverse_order(str(num2))
    print(f"Число наоборот: {reverse_mum2}\n")

    sum_numbers = reverse_mum1 + reverse_mum2

    print(f"Сумма чисел, записанных наоборот: {sum_numbers}")
    print(f"Перевернутая сумма: {flip_number_reverse_order(str(sum_numbers))}")


********************************************************************************

# Часть 1. Модуль 13. Задача 4. Недоделка 2
#
# Программа получает на вход два числа;
# в первом числе должно быть не менее трёх цифр,
# во втором — не менее четырёх,
# иначе программа выдаёт ошибку.
# Если всё нормально, то
# в каждом числе первая и последняя цифры меняются местами,
# а затем выводится их сумма.
#
# Повторений кода должно быть как можно меньше.
# Также сделайте, чтобы в основной части программы был только ввод чисел,
# затем изменённые числа и вывод их суммы.
#
# count_numbers — получает число и возвращает количество цифр в числе;
# change_number — получает число, меняет в нём местами первую и последнюю цифры и возвращает изменённое число;
# main — функция ничего не получает на вход, внутри она запрашивает нужные данные от пользователя,
# выполняет дополнительные проверки и вызывает функции 1 и 2 для выполнения задачи
# (проверки и изменения двух чисел).
#
# Что оценивается
# Программа разбита на несколько функций.
# Выполнены условия по организации основного тела программы.

def count_numbers(number: int):

    num_count = 0
    temp_number = number

    while temp_number > 0:
        num_count += 1
        temp_number = temp_number // 10

    return num_count


def change_number(number: int):
    num_count = count_numbers(number)

    last_digit = number % 10
    first_digit = number // 10 ** (num_count - 1)
    between_digits = number % 10 ** (num_count - 1) // 10
    number = last_digit * 10 ** (num_count - 1) + between_digits * 10 + first_digit

    return number


def main():

    first_n = int(input("Введите первое число: "))
    count_numbers(first_n)
    if count_numbers(first_n) < 3:
        return print(f"В числе меньше трёх цифр.")
    else:
        first_result = change_number(first_n)
        print(f"Изменённое первое число: {first_result}")

    second_n = int(input("\nВведите второе число: "))
    count_numbers(second_n)
    if count_numbers(second_n) < 4:
        return print(f"В числе меньше четырёх цифр.")
    else:
        second_result = change_number(second_n)
        print(f"Изменённое второе число: {second_result}")

    print(f"\nСумма чисел: {first_result + second_result}")


main()


********************************************************************************

# Часть 1. Модуль 13. Задача 5. Маятник
#
# Известно, что амплитуда качающегося маятника с каждым разом затухает
# на 8,4% от амплитуды предыдущего колебания.
# Программа получает на вход начальную амплитуду колебания в сантиметрах
# и конечную амплитуду колебаний, которая считается остановкой маятника.
# Обеспечьте контроль ввода.
#
# Пример:
# Введите начальную амплитуду: 1
# Введите амплитуду остановки: 0.1
# Маятник считается остановившимся через 27 колебаний
#
# Что оценивается
# Результат вывода соответствует условию.
# Input содержит корректное приглашение для ввода.
# Формат вывода соответствует примеру.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).

def input_err(initial_amplitude, amplitude_stop) -> bool:
    return (initial_amplitude <= 0 or amplitude_stop <= 0)


def pendulum(initial_amplitude, amplitude_stop):
    if input_err(initial_amplitude, amplitude_stop):
        raise ValueError("Исходные данные отрицательные либо нулевые.") from None

    attenuation_rate = initial_amplitude
    count = 0
    while attenuation_rate > amplitude_stop:
        attenuation_rate = attenuation_rate - attenuation_rate * 8.4 / 100
        count += 1
    return count


if __name__ == '__main__':
    test_cases = [
        (1, 0.1),    # ожидаем 27
        (10, 0.1),    # ожидаем 53
        (-1, 0)    # ожидаем ошибку
    ]

    try:
        for initial_amplitude, amplitude_stop in test_cases:
            result = pendulum(initial_amplitude, amplitude_stop)
            print(f"Маятник считается остановившимся через {result} колебаний.")
    except Exception as ex:
        print(ex)


********************************************************************************

# Часть 1. Модуль 13. Задача 6. Яйца
#
# Уровень опасности для черепашьих яиц рассчитывается по формуле:
# D = x^3 − 3x^2 − 12x + 10, где x — глубина кладки в метрах,
# а D — уровень опасности в условных единицах.
#
# Напишите программу, находящую такое значение глубины х,
# при котором уровень опасности как можно более близок к нулю.
# На вход программе подаётся максимально допустимое отклонение уровня опасности от нуля,
# а программа должна рассчитать приблизительное значение х, удовлетворяющее этому отклонению.
# Известно, что глубина точно больше нуля и меньше четырёх метров. Обеспечьте контроль ввода.
#
# Пример:
# Введите максимально допустимый уровень опасности: 0.01
# Приблизительная глубина безопасной кладки: 0.732421875 м
#
# Что оценивается
# Результат вывода соответствует условию.
# Input содержит корректное приглашение для ввода.
# Формат вывода соответствует примеру.
# Вывод содержит описание результата (выведенные числа сопровождаются текстовым описанием).
#
# x**3 - 3 * x**2 - 12 * x + (10 - D) = 0
# x1 = 5
# x2 = -(math.sqrt(3) + 1)
# x3 = math.sqrt(3) - 1

import math
import matplotlib.pyplot as plt
import numpy as np

x1 = 5 # Первый корень уравнения нахожу графическим методом
x2 = -(math.sqrt(3) + 1) # Остальные два корня уравнения нахожу по обобщенной теореме Виета


def is_normal(D: float) -> bool:
    return abs(D) > 1


def f(x, D):
    y = x ** 3 - 3 * x ** 2 - 12 * x + (10 - D)
    return y


def root_x3(D):
    if is_normal(D):
        raise ValueError("Ошибка значения допустимого отклонения: |D| < 1.")

    x3 = (D - 10) / (x1 * x2)

    return x3


def graph() -> object:
    fig, ax = plt.subplots()
    # Добавим заголовок графика
    ax.set_title('График функции')
    # Название оси X:
    ax.set_xlabel('x')
    # Название оси Y:
    ax.set_ylabel('y')
    # Начало и конец изменения значения X, разбитое на 100 точек
    x = np.linspace(-3, 6, 1000)  # X от -3 до 6
    # Построение y = x**3 - 3 * x**2 - 12 * x + (10 - D)
    y = f(x, D)
    # Вывод графика
    ax.plot(x, y)
    plt.show()


if __name__ == '__main__':
    try:
        D = float(input('Введите допустимое отклонение от нуля D : '))
        x = root_x3(D)
        y = f(x, D)
        print(f"x = {x}\nf(x) = {y}")
        # print(matplotlib.get_backend())
        graph()

    except ValueError as e:
        print(e)


********************************************************************************

# Альтернативное решение. Часть 1. Модуль 13. Задача 6. Яйца
#
# Альтернативное решение поиска корня на заданном интервале с заданной погрешностью
# методом деления отрезка пополам.

def f(x):
    return x ** 3 - 3 * x ** 2 - 12 * x + 10


while True:

    while True:
        try:
            d = float(input('Введите максимально допустимый уровень опасности: '))
            if 0 <= d < 1:
                break
            else:
                print('Ошибка ввода')
        except ValueError:
            print('Ошибка ввода')

    x_min = 0
    x_max = 4
    x_mid = (x_min + x_max) / 2
    denger = f(x_mid)

    while abs(denger) > d:
        if denger < 0:
            x_max = x_mid
        else:
            x_min = x_mid

        x_mid = (x_min + x_max) / 2
        denger = f(x_mid)

    print(x_mid)


********************************************************************************

# Часть 1. Модуль 13. Видео 2. Задача 1. Сумма чисел 2
#
# Пользователь вводит число N. Напишите функцию summa_n, которая принимает
# одно целое положительное число N и находит сумму всех чисел от 1 до N включительно.
# Функция вызывается два раза: сначала от числа N, а затем от полученной суммы.
#
# Пример работы программы:
# Введите число: 5
# Сумма от 1 до 5 = 15
# Сумма от 1 до 15 = 120

def fingers_sum(number):
    if number < 0:
        return 0

    count_sum = 0
    while number != 0:
        count_sum += number % 10
        number = number // 10

    return count_sum


if __name__ == '__main__':
    test_cases = [
        (123406),
        (-123406),
        (0),
        (1111111111111111111111)
    ]
    for number in test_cases:
        new_number = fingers_sum(number)
        new_count_sum = fingers_sum(new_number)

        print(f"Сумма цифр числа {number}: {new_number} и сумма цифр суммы цифр: {new_count_sum}")


********************************************************************************

# Часть 1. Модуль 13. Видео 2. Задача 2. «Назад в будущее»
#
# Модуль, который можно было бы просто подключить внутри программы.
# Реализуйте функцию gcd, которая получает два параметра — два числа —
# и возвращает наибольший общий делитель этих двух чисел.
#
# Пример работы программы:
# Введите первое число: 6
# Введите второе число: 10
# НОД = 2

def n_o_d(num1, num2):

    if num1 > num2:
        small = num2
    else:
        small = num1

    nod = 1
    for i in range(1, small + 1):
        if (num1 % i == 0) and (num2 % i == 0):
            nod = i

    return nod


if __name__ == '__main__':
    test_cases = [
        (12, 34),
        (120, 40),
        (0, 1),
        (48, 28)
    ]
    for num1, num2 in test_cases:
        rezult = n_o_d(num1, num2)
        print(f"Наибольший общий делитель чисел {num1} и {num2}: {rezult}")


********************************************************************************

# Часть 1. Модуль 13. Видео 2. Задача 3. Приоритет задач
#
# Вводится последовательность из N чисел. Нужно определить номер числа,
# у которого больше всего цифр, и вывести на экран соответствующее сообщение.
# Если число отрицательное, то считать его за 0. Для подсчёта количества цифр
# реализуйте функцию numeral_count.
#
# Пример работы программы:
# Введите кол-во задач: 4
# Введите число: 6
# Введите число: 14
# Введите число: 1
# Введите число: 13434
#
# Первая задача на обработку: 13434

def numeral_count(number):
    if number <= 0:
        print('Номер задачи', number, 'некорректен!', end = ' ')
        return 0
    len_number = 0
    while number != 0:
        number = number // 10
        len_number += 1
    return len_number


if __name__ == '__main__':
    test_cases = [
        (13434, 1343),
        (12345, 6708910),
        (123, 456),
        (123, -4560),
        (1234, 123),
        (12300, 00000000)
    ]

    for task_1, task_2 in test_cases:
        if numeral_count(task_1) > numeral_count(task_2):
            print(f"Делаем задачу №{task_1}\n")
        elif numeral_count(task_1) < numeral_count(task_2):
            print(f"Делаем задачу №{task_2}\n")
        else:
            print(f"Задачи равносильны\n")


********************************************************************************

# Часть 1. Модуль 13. Видео 3. Задача 1. Возможности компьютера
#
# Делим 1 на 2, пока не получим ноль. Считаем кол-во делений.

def del2(number):
    count = 0
    while number != 0:
        number = number / 2
        count += 1
    return count

count = del2(2e145)
print(f"Делим число на 2, пока не получим ноль. Кол-во делений {count}")


********************************************************************************

# Часть 1. Модуль 13. Видео 3. Задача 2. Тестирование
#
# Пользователь вводит число N в экспоненциальной форме,
# где мантисса всегда равна числу от 1 до 9, а порядок меньше нуля.
# Также есть переменная Х, которая изначально равна единице.
# Посчитайте, сколько раз нужно прибавить N к Х, чтобы оно перевалило за двойку.
# Обеспечьте контроль ввода.
#
# Пример 1:
# Введите число в эксп. форме: 1e-3
# Кол-во прибавлений: 1001
#
# Пример 2:
# Введите число в эксп. форме: 5.02e-1
# Кол-во прибавлений: 2
#
# start_number = 1
# delta = float(input("Введите число в эксп. форме "))
# count = 0
# while start_number <= 2:
#     start_number += delta
#     count += 1
#
# print("Кол-во прибавлений: ", count)

import time

def is_error_1(str_number: str):
    if 'e-' in str_number:
        return str_number.index('e-', 0, len(str_number))


def number_additions_up_to_2(number):
    x, count = 1, 0

    start = time.perf_counter()
    while x <= 2:
        x += number
        count += 1
    print(f"Цикл: {time.perf_counter() - start}")
    return count


if __name__ == '__main__':

    while True:

        str_number = str(input('\nВведите число в экспоненциальной форме, напр., 4e-54: '))

        if str_number == 'exit':
            print('Пока!')
            exit()
        elif is_error_1(str_number) != 1:
            raise ValueError(f"Ошибка ввода. Введите число в формате (мантисса от 1 до 9)e-(порядок).\n")

        try:
            number: float = float(str_number)
            print(f"К числу x = 1 прибавляем {number}, пока не получим 2 и более.")
            rezult = number_additions_up_to_2(number)
            print(f"Понадобилось {rezult} операций.")

        except ValueError as e:
            print(e)


********************************************************************************

# Часть 1. Модуль 13. Видео 3. Задача 3. Урок информатики
#
# Пользователь вводит положительное число x (x > 10).
# Напишите функцию, которая выводит его в формате плавающей точки, то есть
# x = a *10 ** b, где 1 ≤ a < 10.
#
# Пример 1:
# Введите число: 16
# Формат плавающей точки: x = 1.6 * 10 ** 1
#
# Пример 2:
# Введите число: 92345
# Формат плавающей точки: x = 9.2345 * 10 ** 4

def input_int_in_range(start, end):
    while True:
        try:
            number = int(input("Введите число: "))
        except ValueError:
            print("Вы ввели не число. Попробуйте снова.")
        else:
            if start <= number < end:
                return number
            print("Введённое число вне диапазона: [%d, %d)" % (start, end))

number = input_int_in_range(10, 50 + 1)

count = 0
while number > 10:
    count += 1
    number /= 10

print(f"Формат плавающей точки: x = {number} * 10 ** {count}")


********************************************************************************

# Альтернативное решение. Часть 1. Модуль 13. Видео 3. Задача 3. Урок информатики
#
# Напишите функцию, которая выводит его в формате плавающей точки, то есть
#
# Альтернативное решение
#
# 1e1 = 10
# 2e1 = 20
# 1e2 = 100
# 2e2 = 200
# 2e3 = 2000
# 1.1e1 = 11
# 2.1e1 = 21
# 1.23e2 = 123
# 2.03e1 = 20
# 123e2 = 12300
# 123e1 = 1230
# 123e5 = 12300000

def do_str_number(number) -> str:
    len_number = len(str(number))
    list_number_begin_part = []
    list_number_last_part = []

    for i in range(len_number):
        while int(number) > 10:
            number_end = number % 10
            number = number // 10
            list_number_last_part.append(str(number_end))
        if i == 0:
            list_number_begin_part.append(str(number))

    print(f"После точки: {list_number_last_part}")
    print(f"До точки: {list_number_begin_part}")

    list_number_last_part.reverse()
    print(f"Перевернутый после точки: {list_number_last_part}")

    str_number_last_part = ''
    str_number_last_part = "".join(list_number_last_part)

    str_number_begin_part = ''
    list_number_begin_part.append('.')
    str_number_begin_part = "".join(list_number_begin_part)

    str_number = str_number_begin_part + str_number_last_part

    return str_number


def do_degree(number) -> str:
    list_degree = []
    list_degree.append(str(len(str(number)) - 1))
    print(f"Степень: {list_degree}")
    str_degree = "".join(list_degree)
    return str_degree


def exponential_form_number(str_number: str):

    new_str_number = do_str_number(number) + ' * 10**' + do_degree(number)
    return new_str_number


if __name__ == '__main__':
    test_cases = [
        (39),
        (185254),
        (1.193959012546486e-05),
        (1),
        (0),
        (5426000000)
    ]
    for number in test_cases:
        rezult = exponential_form_number(number)
        print(f"Число в экспоненциальной форме {number} = {rezult}\n")


********************************************************************************

# Часть 1. Модуль 13. Видео 3. Задача 1. Опять налоги
#
# Напишите функцию, на вход которой подаются два числа —
# общая сумма налога tax и новый налог new_tax, который нужно добавить к общей сумме.
# Функция должна проверять, возможно ли сложить эти два числа или нет,
# и выводить соответствующее сообщение о том, увеличится ли бюджет или нет.
#
# Максимальное и минимальное число, с которыми может работать Python:
# max = 1.7976931348623157e+308
# min = 2.2250738585072014e-308
# Компьютерный эпсилон: 1e-15
#
# Пример 1:
# Введите бюджет страны: 1.23e2
# Новые поступления (налог): 1.2e1
# Результат: Бюджет увеличится
#
# Пример 2:
# Введите бюджет страны: 1.231221200034e12
# Новые поступления (налог): 1.2e-4
# Результат: Бюджет не изменится

def check_budget(old_budget, new_tax):
    while old_budget % 10 == 0:
        old_budget /= 10
        new_tax /= 10

    if int(old_budget + new_tax) == int(old_budget):
        print("Бюджет не изменился")
    else:
        print("Бюджет изменился")


if __name__ == '__main__':
    test_cases = [
        (1.23e2, 1.2e1),
        (1.231221200034e12, 0.2e-54),
        (1.231221200034e12, 1.2e-4),
        (1.231221200034e12, 6.2e0),
        (1.0e24, 0.000000001e10)
    ]

    for budget, new_tax in test_cases:
        check_budget(budget, new_tax)


********************************************************************************

# Часть 1. Модуль 13. Видео 3. Задача 2. Сравнение
#
# 0.1 + 0.2 не будет в точности равняться 0.3
# Компьютерный эпсилон: 1e-15
# Максимальное и минимальное число, с которыми может работать Python:
# max = 1.7976931348623157e+308
# min = 2.2250738585072014e-308
#
# Напишите функцию eqv, которая принимает три числа и
# сравнивает сумму первых двух чисел с третьим
# с определённой степенью точности: до 15-го знака после точки.
# Если равенство выполняется, то возвращает True, иначе False.
#
# Пример 1:
# Введите первое число: 1.1
# Введите второе число: 2.2
# Введите третье число: 3.3
# True
#
# Пример 2:
# Введите первое число: 1e-14
# Введите второе число: 1e-14
# Введите третье число: 3e-14
# False

def eqv(num1, num2, num3) -> bool:
    return round(abs((num1 + num2) - num3), 15) < 1e-15


if __name__ == '__main__':
    test_cases = [
        (1.1, 2.2, 3.3),
        (1e-14, 1e-14, 3e-14),
        (1e-14, 1e-14, 2e-14),
        (1e14, 1e14, 3e14),
        (1, 1, 3),
        (1, 1, 2)
    ]

    for num1, num2, num3 in test_cases:
        result = eqv(num1, num2, num3)
        print(f"({num1} + {num1}) и {num3} - {result}")


********************************************************************************

# Часть 2. Модуль 1. Задача 2. Сумма и разность
#
# Напишите две функции. Первая принимает одно целое положительное число N и находит сумму всех цифр в числе.
# Вторая принимает число N и считает количество цифр в числе.
# В ответ выводится разность суммы чисел и количества.
#
# Пример:
# Введите число: 500
# Сумма чисел: 5
# Количество цифр в числе: 3
# Разность суммы и количества цифр: 2
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Программа имеет две отдельные функции, описанные в условии задачи.
# Переменные и функции имеют значащие имена, не только a, b, c, d (подробнее об этом в видео 2.3).



def is_negative(number: int) -> bool:
    return number < 0


def summ_number(number: int):
    if is_negative(number):
        raise ValueError(f"Ошибка ввода. Введите целое положительное число.")

    summ = 0
    while number > 0:
        summ += number % 10
        number = number // 10

    return summ


def quality_number(number: int):
    if is_negative(number):
        raise ValueError(f"Ошибка ввода. Введите целое положительное число.")

    count = 0
    while number > 0:
        number = number // 10
        count += 1

    return count



if __name__ == '__main__':
    try:
        number = int(input('Введите число: '))
    except ValueError:
        print(f"Ошибка ввода. Введите целое положительное число.")
        number = int(input('Введите число: '))

    try:
        result = abs(summ_number(number) - quality_number(number))
        print(f"Разность суммы цифр и колл-ва цифр в числе {number}: {result}")
    except ValueError as e:
        print(e)


********************************************************************************

# Часть 2. Модуль 1. Задача 3. Наименьший делитель
#
# Дано натуральное число n>1. Напишите функцию, которая находит его наименьший делитель, отличный от 1.
#
# Примеры:
# Введите число: 6
# Наименьший делитель, отличный от единицы: 2
# Введите число: 17
# Наименьший делитель, отличный от единицы: 17
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Основной функционал описан в отдельной(-ых) функции(-ях).
# Переменные и функции имеют значащие имена, не только a, b, c, d (подробнее об этом в видео 2.3).




def min_deviser(number: int):

    if int(number) == 0:
        raise ValueError(f"Ошибка ввода. Вы ввели ноль. Введите целое положительное число.")
    if int(number) < 0:
        raise ValueError(f"Ошибка ввода. Вы ввели отрицательное число. Введите целое положительное число.")

    min_dev = 1
    i = 2

    while i <= number:
        if number % i == 0:
            min_dev = i
            break
        else:
            i += 1

    return min_dev


if __name__ == '__main__':

    while True:

        try:
            number = int(input('Введите число: '))
            result = min_deviser(number)
            print(f"Наименьший делитель числа {number}, отличный от ед.: {result}")

        except ValueError as e:
            print(type(e), '::', e)


********************************************************************************

# Часть 2. Модуль 1. Задача 4. Монетка-2
#
# Даны два действительных числа x и y и радиус r.
# Напишите функцию, которая проверяет, лежит ли точка с координатами (x; y)
# внутри круга с радиусом r, включая его границу.
# Координаты центра круга — (0; 0).
# Если точка принадлежит кругу, выведите сообщение: «Монетка где-то рядом».
# В другом случае выведите сообщение: «Монетки в области нет».
#
# Пример 1
# Введите координаты монетки:
# x: 0.5
# y: 0.5
# Введите радиус: 1
# Монетка где-то рядом
#
# Пример 2
# Введите координаты монетки:
# x: 2
# y: 2
# Введите радиус: 1
# Монетки в области нет
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Основной функционал описан в отдельной(-ых) функции(-ях).
# Переменные и функции имеют значащие имена, не только a, b, c, d (подробнее об этом в видео 2.3).

import math

def point_in_round(x, y, r):

    OM = math.sqrt(x**2 + y**2)
    if OM <= r:
        return f"Монетка где-то рядом."
    else:
        return f"Монетки в области нет."



if __name__ == '__main__':
    print('Введите координаты монетки:')
    x = float(input('x = '))
    y = float(input('y = '))
    r = float(input('Введите радиус поиска r = '))

    result = point_in_round(x, y, r)
    print(result)


********************************************************************************

# Часть 2. Модуль 1. Задача 5. Годы
#
# Напишите программу, в которой у пользователя запрашиваются два четырёхзначных числа A и B.
# Затем выведите в порядке возрастания все четырёхзначные числа в интервале от A до B,
# запись которых содержит ровно три одинаковые цифры.
#
# Пример
# Введите первый год: 1900
# Введите второй год: 2100
# Годы от 1900 до 2100 с тремя одинаковыми цифрами:
# 1911
# 1999
# 2000
# 2022
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Основной функционал описан в отдельной(-ых) функции(-ях).
# Переменные и функции имеют значащие имена, не только a, b, c, d (подробнее об этом в видео 2.3).


def is_correct(year: str) -> bool:
    return len(year) != 4 or not(str(year).isdigit()) or int(year) < 0


def three_identical_digits(year: str):
    if is_correct(str(year)):
        raise ValueError(f"Ошибка ввода. Введите четырехзначное натуральное число.")

    year = str(year)
    a = year[3]
    if ((a == year[0] and a == year[1]) or (a == year[0] and a == year[2]) or (a == year[1] and a == year[2])) \
            and ((a != year[0]) or (a != year[1]) or (a != year[2])):
        print(year)


def years_list(year1, year2):

    for year in range(int(year1), int(year2) + 1):
        three_identical_digits(str(year))



if __name__ == '__main__':
    year1 = int(input('Введите начальный год: '))
    year2 = int(input('Введите конечный год: '))
    if year1 > year2:
        year1, year2 = year2, year1

    try:
        if is_correct(str(year1)) == False and is_correct(str(year1)) == False:
            print('Годы с тремя одинаковыми цифрами:')

        result = years_list(year1, year2)

    except ValueError as e:
        print(e)


********************************************************************************

# Часть 2. Модуль 1. Видео 4. Задача 1. Таблица умножения: возвращение
#
# Напишите простую программу, которая выводит на экран таблицу умножения.
# Используйте только консоль и текстовый редактор.

print('Таблица умножения')
for i in range(2, 10):
    for j in range(2, 10):
        print(f"{i} * {j} = {i * j}")
    print()

print('Учите таблицу умножения!')


********************************************************************************

# Часть 2. Модуль 1. Видео 4. Задача 2. Калькулятор
#
# Напишите программу калькулятор. Пользователь вводит два числа A и B и действие X
# (плюс, минус, умножить, разделить). Программа выводит результат в виде A X B = C,
# где C — результат этого действия над числами A и B.
# Используйте только консоль и текстовый редактор. Обеспечьте контроль ввода.
#
# Пример работы программы в консоли:
# Выберите операцию: +
# Введите первое число: 5
# Введите второе число: 6
# 5 + 6 = 11
#
# Пример работы программы в консоли 2:
# Выберите операцию: №
# Ошибка: такой операции не существует. Попробуйте ещё раз.
# Выберите операцию: -
# Введите первое число: 5
# Введите второе число: 6
# 5 - 6 = -1


def calc(s, a, b):
    c = 0

    if s not in ('+', '-', '*', '/', '**', '%', '//'):
        print()

    if s in ('+', '-', '*', '/', '**', '%', '//'):
        if s == '+':
            # c = "%.4f" % (a + b) - округление при выводе до 4-х знаков после плавающей точки
            c = a + b
        elif s == '-':
            c = a - b
        elif s == '*':
            c = a * b
        elif s == '**':
            c = a ** b
        elif s == '/':
            if b == 0:
                raise ZeroDivisionError("Давайте не будем делить на ноль!")
            else:
                c = a / b
        elif s == '//':
            if b == 0:
                raise ZeroDivisionError("Давайте не будем делить на ноль!")
            else:
                c = int(a // b)
        elif s == '%':
            if b == 0:
                raise ZeroDivisionError("Давайте не будем делить на ноль!")
            else:
                c = int(a % b)

    return c



if __name__ == '__main__':
    print('«+» , «-» , «*» , «/» - классические операции\n'
          '«**» - возведение в степень\n'
          '«%» - остаток от числа a при делении на b\n'
          '«//» - целочисленное деление a на b\n'
          'Для выхода введите «q»')

    while True:
        s = input('\nВыберите операцию: ')
        if s == 'q':
            break
        else:
            a = float(input("a = "))
            b = float(input("b = "))
            result = calc(s, a, b)
            print(f"{a} {s} {b} = {result}")



********************************************************************************

# Часть 2. Модуль 1. Видео 4. Задача 3. Калькулятор 2
#
# Модифицируйте программу калькулятор.
# Программа должна спрашивать действие и кол-во операндов.
# Пользователь вводит то кол-во чисел, которое он заказал.
# Используйте только консоль и текстовый редактор.
#
# Пример работы программы в консоли:
# Выберите операцию: +
# Сколько операндов? 4
# Введите операнд 1: 6
# Введите операнд 2: 43
# Введите операнд 3: 11
# Введите операнд 4: 0
# 6 + 43 + 11 + 0 = 60


def calc(s:str, n:int):
    c = a_1
    for i in range(2, n + 1):
        if s == '+':
            a_i = float(input(f"a({i}) = "))
            c += a_i
        elif s == '-':
            a_i = float(input(f"a({i}) = "))
            c -= a_i
        elif s == '*':
            a_i = float(input(f"a({i}) = "))
            c *= a_i
        elif s == '/':
            a_i = float(input(f"a({i}) = "))
            c /= a_i
        else:
            print('Ошибка ввода операции.')

    return c

if __name__ == '__main__':
    print('«+» , «-», «*» , «/» - допустимые операции. Для выхода введите «q»')
    while True:
        s = input('\nВыберите операцию: ')
        if s == 'q':
            break
        n = int(input('Введите кол-во операндов: '))
        if n == 0:
            break
        else:
            a_1 = float(input(f"a(1) = "))
            result = calc(s, n)
            print(f"a(i=1..{n}) {s}= {result}")

********************************************************************************

# Часть 2. Модуль 1. Видео 5. Задача 2. НОД
#
# На вход подаются числа 4782 и 698. Используя только точку останова, определите,
# чему будет равняться переменная а, когда переменная b станет равна двум.
#
# Ответ: при b = 2, a = 14


def gcd(a, b):

    while a != 0 and b != 0:
        if a > b:
            a = a % b
        else:
            b = b % a

    print('Наибольший общий делитель:', a + b)

gcd(4782, 698)

********************************************************************************

# Часть 2. Модуль 1. Видео 5. Задача 3. Сессия
# Программа выдаёт корректное уравнение,
# если координаты первой точки равны (10, 20),
# а координаты второй точки равны (10, 45).
# Нужно отладить.



print("Введите первую точку")
x1 = float(input('X: '))
y1 = float(input('Y: '))

print("\nВведите вторую точку")
x2 = float(input('X: '))
y2 = float(input('Y: '))

x_diff = x1 - x2
y_diff = y1 - y2

print("Уравнение прямой, проходящей через эти точки:")

if x_diff == 0:
    print(f"x = {x1}")
elif y_diff == 0:
    print(f"y = {y1}")
else:
    k = round(y_diff / x_diff, 4)
    b = round(y1 - k * x1, 4)
    print("y = ", k, " * x + ", b)


********************************************************************************

# Часть 2. Модуль 2. Практическая работа. Задание 1. Генерация списка
#
# Дано целое число N. Напишите программу, которая формирует список из нечётных чисел от одного до N.
#
# Пример 1:
# Введите число: 1
# Список из нечётных чисел от одного до N: [1]
#
# Пример 2:
# Введите число: 14
# Список из нечётных чисел от одного до N: [1, 3, 5, 7, 9, 11, 13]
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значащие имена, не только a, b, c, d. Подробнее об этом — в видео 2.3.



n = int(input('Введите n: '))

numbers_list = []

for i in range(1, n+1, 2):
    numbers_list.append(i)
print(numbers_list)


********************************************************************************

# Часть 2. Модуль 2. Практическая работа. Задание 2. Турнир
#
# Дан список из восьми имён: Артемий, Борис, Влад, Гоша, Дима, Евгений, Женя, Захар.
# Напишите программу, которая выводит элементы списка только с чётными индексами.
#
# Пример:
# Первый день: ['Артемий', 'Влад', 'Дима', 'Женя']
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значащие имена, не только a, b, c, d. Подробнее об этом — в видео 2.3.



grid = ["Артемий", "Борис", "Влад", "Гоша", "Дима", "Евгений", "Женя", "Захар"]
i = 0
print("Первый день:", end=' ')
for id, elem in enumerate(grid):
        if id % 2 == 0:
            print(f"{elem}", end=', ')


********************************************************************************

# Часть 2. Модуль 2. Практическая работа. Задание 3. Видеокарты
#
# Напишите программу, которая удаляет наибольшие элементы из списка видеокарт.
#
# Пример:
# Количество видеокарт: 5
# Видеокарта 1: 3070
# Видеокарта 2: 2060
# Видеокарта 3: 3090
# Видеокарта 4: 3070
# Видеокарта 5: 3090
# Старый список видеокарт: [ 3070 2060 3090 3070 3090 ]
# Новый список видеокарт: [ 3070 2060 3070 ]
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значащие имена, не только a, b, c, d. Подробнее об этом — в видео 2.3.

def max_el_search(lst):
    max_el = lst[0]
    for i, el in enumerate(lst):
        if el > max_el:
            max_el = el
    return max_el



v_cards_list = [3070, 2060, 3090, 3070, 3090]
v_cards_list_c = v_cards_list.copy() # v_cards_list[::] - копирование через срез

for elem in v_cards_list:
    if elem == max_el_search(v_cards_list):
        v_cards_list.remove(elem)

print(f"Старый список видеокарт: {v_cards_list_c}\n"
      f"Новый список видеокарт: {v_cards_list}")


********************************************************************************

# Часть 2. Модуль 2. Практическая работа. Задание 4. Кино
#
# films = [‘Крепкий орешек’, ‘Назад в будущее’, ‘Таксист’, ‘Леон’,
# ‘Богемская рапсодия’, ‘Город грехов’, ‘Мементо’, ‘Отступники’, ‘Деревня’]
#
# Напишите программу, в которой пользователь вводит фильм.
# Если кинокартина есть в перечне, то добавляется в список любимых.
# Если её нет, то выводится ошибка. В конце выведите весь список любимых фильмов.
#
# Пример:
# Сколько фильмов хотите добавить? 3
# Введите название фильма: Леон
# Введите название фильма: Безумный Макс
# Ошибка: фильма Безумный Макс у нас нет :(
# Введите название фильма: Мементо
# Ваш список любимых фильмов: Леон, Мементо
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значащие имена, не только a, b, c, d. Подробнее об этом — в видео 2.3.



films = ['Крепкий орешек', 'Назад в будущее', 'Таксист', 'Леон',
         'Богемская рапсодия', 'Город грехов', 'Мементо', 'Отступники', 'Деревня']
favourite_list = []

n = int(input('Сколько фильмов хотите добавить?: '))

for i in range(n):
    film = input('Введите название фильма: ')
    if film in films:
        favourite_list.append(film)
    else:
        print("Такого фильма у нас нет(((")

print(f"Ваш список любимых фильмов: {favourite_list}")


********************************************************************************

# Часть 2. Модуль 2. Практическая работа. Задание 5. Контейнеры
#
# Напишите программу, которая получает на вход невозрастающую последовательность натуральных чисел.
# Они означают массу каждого контейнера в ряду. После этого вводится число X — масса нового контейнера.
# Программа выводит номер, под которым будет лежать новый контейнер.
# Если в ряду есть контейнеры с массой, как у нового, то его нужно положить после них.
#
# Обеспечьте контроль ввода: все числа не превышают 200.
#
# Пример:
# Количество контейнеров: 8
# Введите вес контейнера: 165
# Введите вес контейнера: 163
# Введите вес контейнера: 160
# Введите вес контейнера: 160
# Введите вес контейнера: 157
# Введите вес контейнера: 157
# Введите вес контейнера: 155
# Введите вес контейнера: 154
# Введите вес нового контейнера: 162
# Номер, который получит новый контейнер: 3
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значащие имена, не только a, b, c, d. Подробнее об этом — в видео 2.3.



n = int(input('Сколько ящиков будем добавлять?: '))

weight_list = []

for i in range(n):
    weight = int(input(f"Сколько весит {i+1}-й ящик?: "))
    weight_list.append(weight)

weight_list.sort()
print(f"Ящики упорядочены: {weight_list}")

new_weight = int(input('Сколько весит новый ящик?: '))

id = 0

for i, elem in enumerate(weight_list):
    if new_weight < elem:
        id = i
        break
    elif new_weight == elem:
        id += 1
    else:
        if new_weight > weight_list[-1]:
            id = len(weight_list)

weight_list.insert(id, new_weight)    # добавляю новый ящик в место его веса

print(f"Номер, который получит новый ящик: {id}\nНовый список: {weight_list}")


********************************************************************************

# Часть 2. Модуль 2. Практическая работа. Задание 6. Бегущие цифры
#
# Дан список из N элементов и целое число K. Напишите программу, которая
# циклически сдвигает элементы списка вправо на K позиций.
# Используйте минимально возможное количество операций присваивания.
#
# Пример 1:
# Сдвиг: 1
# Изначальный список: [1, 2, 3, 4, 5]
# Сдвинутый список: [5, 1, 2, 3, 4]
#
# Пример 2:
# Сдвиг: 3
# Изначальный список: [1, 4, –3, 0, 10]
# Сдвинутый список: [–3, 0, 10, 1, 4]
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значащие имена, не только a, b, c, d. Подробнее об этом — в видео 2.3.

def var_1():
    i = 0
    id = i + step

    for elem in start_list:
        if id < len(start_list):
            end_list.insert(id, elem)
            id += 1
        elif id == len(start_list):
            id = 0
            end_list.insert(id, elem)
            id += 1
        else:
            print('Ошибка ввода: шаг превышает длину списка.')
            break
        i += 1

def var_2():
    srez_l = start_list[:step]
    srez_r = start_list[step:]
    end_list[1:step] = srez_r + srez_l #добавила элементы с помощью среза

start_list = [1, 4, -3, 0, 10]
step = 2
end_list = []

var_2()

print(f"Стартовый список {start_list}\n"
      f"Сдвинутый список: {end_list}")


********************************************************************************

# Часть 2. Модуль 2. Практическая работа. Задание 7. Анализ слова — 2
#
# Необходимо реализовать код, с помощью которого можно определять палиндромы,
# то есть слова, которые читаются одинаково слева направо и справа налево.
#
# Пример 1:
# Введите слово: мадам
# Слово является палиндромом
#
# Пример 2:
# Введите слово: abccba
# Слово является палиндромом
#
# Пример 3:
# Введите слово: abbd
# Слово не является палиндромом
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значащие имена, не только a, b, c, d. Подробнее об этом — в видео 2.3.

word = input("Введите слово: ")
l = len(word) // 2
count = 0

for i in range(l):
    if word[i] == word[len(word) - 1 - i]:
        count += 1

if count == l:
    print('Слово является палиндромом.')
else:
    print('Слово не является палиндромом.')


********************************************************************************

# Часть 2. Модуль 2. Практическая работа. Задание 8. Сортировка
#
# Дан список из N чисел. Напишите программу, которая сортирует элементы списка
# по возрастанию и выводит их на экран. Дополнительный список использовать нельзя.
#
# Постарайтесь придумать и написать как можно более эффективный алгоритм сортировки.
#
# Пример:
# Изначальный список: [1, 4, –3, 0, 10]
# Отсортированный список: [–3, 0, 1, 4, 10]
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значащие имена, не только a, b, c, d. Подробнее об этом — в видео 2.3.
#
#
#
# Сортировка выбором (selection sort) — на каждом шаге находит минимальный или максимальный элемент
# из неотсортированной части списка и помещает его в начало или конец отсортированной части.
# Устойчивый, ограниченно эффективен.


def selection_sort(some_list: float):
    id_min = 0
    for id_min in range(len(some_list)):
        for id_curr in range(id_min, len(some_list)):
            if some_list[id_curr] < some_list[id_min]:
                some_list[id_curr], some_list[id_min] = some_list[id_min], some_list[id_curr]

    return some_list


if __name__ == '__main__':
    # some_list = [9, 96.56, -37, 3, -27.39, 50, 1, 19.29, 15, 4, -5.3, 2, 0, -70.07, 48, 2, 37.72, 63, -3, -77.29, 86, 1, 26.33, 4, 7, 4.84, 12, 9, -66.73, -74]
    some_list = [4, 8, 5, 6, 9, 1, 3, 2, 7]

    result = selection_sort(some_list)

    print(f"\nИсходный список:\n[4, 8, 5, 6, 9, 1, 3, 2, 7]\n"
          f"\nАлгоритм сортировки выбором:\n{result}")


********************************************************************************

# Часть 2. Модуль 2. Практическая работа. Задание 8. Сортировка
#
# Написать наиболее эффективный алгоритм сортировки.


import random
import time


start_creating_list = time.perf_counter()
def creating_list(minnumber, maxnumber, quantity):
    rand_list = []

    for _ in range(quantity):
       rand_list.append(random.randint(minnumber, maxnumber))

    return rand_list
creating_list_speed = time.perf_counter() - start_creating_list
print(f"Скорость генерации списка: {creating_list_speed}\n")




# Сортировка пузырьком (bubble sort) — простой алгоритм сортировки,
# который проходит по списку несколько раз, сравнивая пары соседних элементов
# и меняя их местами, если они находятся в неправильном порядке.
# Этот процесс повторяется до тех пор, пока весь список не будет отсортирован.

start_bubble_sort = time.perf_counter()
def bubble_sort(lst):
    n = len(lst)
    for i in range(n - 1):
        for j in range(n - i - 1):
            # Сравниваем пару соседних элементов
            if lst[j] > lst[j + 1]:
                # Если элементы находятся в неправильном порядке, меняем их местами
                lst[j], lst[j + 1] = lst[j + 1], lst[j]
    return lst
bubble_sort_speed = time.perf_counter() - start_bubble_sort
print(f"Скорость сортировки пузырьком: {bubble_sort_speed}")




# Сортировка вставками (insertion sort) — простой алгоритм сортировки,
# который постепенно строит отсортированную последовательность, один элемент за другим,
# вставляя каждый новый элемент в правильное место.

start_insertion_sort = time.perf_counter()
def insertion_sort(lst):
    n = len(lst)
    for i in range(1, n):
        key = lst[i]  # Берём текущий элемент, который нужно вставить в отсортированную часть списка
        j = i - 1
        # Перемещаем элементы, которые больше key, на одну позицию вперёд
        while j >= 0 and lst[j] > key:
            lst[j + 1] = lst[j]
            j -= 1
        lst[j + 1] = key  # Вставляем key в правильное место
    return lst
insertion_sort_speed = time.perf_counter() - start_insertion_sort
print(f"Скорость сортировки вставками: {insertion_sort_speed}")




# Сортировка Шелла (Shell sort) — применяет сортировку вставками к диапазонам элементов с определённым шагом.
# Шаг постепенно уменьшается, позволяя элементам быстрее перемещаться в свои конечные позиции.
# Таким образом, сортировка Шелла — это усовершенствованный вариант сортировки вставками.
# Универсальный

start_shell_sort = time.perf_counter()
def shell_sort(lst):
    n = len(lst)
    gap = n // 2  # Инициализация начального значения интервала

    while gap > 0:
        # Применяем сортировку вставками с заданным интервалом
        for i in range(gap, n):
            temp = lst[i]
            j = i
            # Сдвигаем элементы, чтобы найти правильную позицию для вставки элемента
            while j >= gap and lst[j - gap] > temp:
                lst[j] = lst[j - gap]
                j -= gap
            lst[j] = temp
        gap //= 2  # Уменьшаем интервал

    return lst
shell_sort_speed = time.perf_counter() - start_shell_sort
print(f"Скорость сортировки Шелла: {shell_sort_speed}")




# Сортировка выбором (selection sort) — на каждом шаге находит минимальный или максимальный элемент
# из неотсортированной части списка и помещает его в начало или конец отсортированной части.
# Устойчивый, ограниченно эффективен.

start_selection_sort = time.perf_counter()
def selection_sort(lst):
    n = len(lst)

    for i in range(n - 1):
        min_index = i
        # Находим индекс минимального элемента в неотсортированной части списка
        for j in range(i + 1, n):
            if lst[j] < lst[min_index]:
                min_index = j
        # Меняем местами минимальный элемент с первым элементом неотсортированной части
        lst[i], lst[min_index] = lst[min_index], lst[i]

    return lst
selection_sort_speed = time.perf_counter() - start_selection_sort
print(f"Скорость сортировки выбором: {selection_sort_speed}")




# Сортировка слиянием (merge sort) — использует стратегию «разделяй и властвуй».
# Он разбивает список на две половины, рекурсивно сортирует каждую, затем объединяет их.
# Для работы с большим объемом данных

start_merge_sort = time.perf_counter()
def merge_sort(lst):
    if len(lst) <= 1:
        return lst
    # Разделяем список на две половины
    mid = len(lst) // 2
    left_half = lst[:mid]
    right_half = lst[mid:]
    # Рекурсивно сортируем каждую половину
    left_half = merge_sort(left_half)
    right_half = merge_sort(right_half)
    # Объединяем отсортированные половины в один список
    return merge_2(left_half, right_half)

def merge_2(left, right):
    merged = []
    left_index = 0
    right_index = 0
    while left_index < len(left) and right_index < len(right):
        # Сравниваем элементы из обоих списков и добавляем меньший в объединённый список
        if left[left_index] <= right[right_index]:
            merged.append(left[left_index])
            left_index += 1
        else:
            merged.append(right[right_index])
            right_index += 1
    # Добавляем оставшиеся элементы из левого списка
    merged.extend(left[left_index:])
    # Добавляем оставшиеся элементы из правого списка
    merged.extend(right[right_index:])
    return merged
merge_sort_speed = time.perf_counter() - start_merge_sort
print(f"Скорость сортировки слиянием: {merge_sort_speed}")




# Timsort — гибридный алгоритм, который комбинирует идеи из сортировки слиянием (merge sort)
# и сортировки вставками (insertion sort) для достижения эффективности в разных сценариях сортировки,
# при этом он сохраняет относительный порядок равных элементов.
# Timsort — адаптивный алгоритм, который оптимизирован для разных случаев,
# включая частично отсортированные или обратно отсортированные списки.
# Он эффективно обрабатывает списки с повторяющимися элементами.

start_timsort = time.perf_counter()
minrun = 32
def InsSort(arr, start, end):
    for i in range(start + 1, end + 1):
        elem = arr[i]
        j = i - 1
        while j >= start and elem < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = elem
    return arr

def merge(arr, start, mid, end):
    if mid == end:
        return arr
    first = arr[start:mid + 1]
    last = arr[mid + 1:end + 1]
    len1 = mid - start + 1
    len2 = end - mid
    ind1 = 0
    ind2 = 0
    ind = start

    while ind1 < len1 and ind2 < len2:
        if first[ind1] < last[ind2]:
            arr[ind] = first[ind1]
            ind1 += 1
        else:
            arr[ind] = last[ind2]
            ind2 += 1
        ind += 1

    while ind1 < len1:
        arr[ind] = first[ind1]
        ind1 += 1
        ind += 1

    while ind2 < len2:
        arr[ind] = last[ind2]
        ind2 += 1
        ind += 1

    return arr

def TimSort(arr):
    n = len(arr)

    for start in range(0, n, minrun):
        end = min(start + minrun - 1, n - 1)
        arr = InsSort(arr, start, end)

    curr_size = minrun
    while curr_size < n:
        for start in range(0, n, curr_size * 2):
            mid = min(n - 1, start + curr_size - 1)
            end = min(n - 1, mid + curr_size)
            arr = merge(arr, start, mid, end)
        curr_size *= 2
    return arr
timSort_speed = time.perf_counter() - start_timsort
print(f"Скорость сортировки Timsort: {timSort_speed}")




if __name__ == '__main__':
    rand_list = creating_list(-1000, 1000, 10**5)

    print(f"\nРандомизированный список:\n{rand_list}\n")
    # print(f"nАлгоритм сортировки пузырьком:\n{bubble_sort(rand_list)}"
          # f"\nАлгоритм сортировки вставками:\n{insertion_sort(rand_list)}"
          # f"\nАлгоритм сортировки Шелла:\n{shell_sort(rand_list)}"
          # f"\nАлгоритм сортировки выбором:\n{selection_sort(rand_list)}"
          # f"\nАлгоритм сортировки слиянием:\n{merge_sort(rand_list)}"
          # f"\nАлгоритм сортировки TimSort:\n{TimSort(rand_list)}")

    dict = {
        bubble_sort_speed: 'Пузырьком',
        insertion_sort_speed: 'Вставками',
        shell_sort_speed: 'Шелла',
        selection_sort_speed: 'Выбором',
        merge_sort_speed: 'Слиянием',
        timSort_speed: 'TimSort'
    }
    speed_list = [bubble_sort_speed, insertion_sort_speed, shell_sort_speed,
                  selection_sort_speed, merge_sort_speed, timSort_speed]
    speed_list.sort()

    print('Скорость сортировки алгоритмов (от быстрой к медленной):\n')
    for elem in speed_list:
        print(f"{dict.setdefault(elem)} speed = {elem}")


********************************************************************************

# Часть 2. Модуль 2. Практическая работа. Задание 9. Обратный анализ чётных чисел
#
# Контекст
# Вы работаете в научной лаборатории, в ней проводятся эксперименты и записываются
# результаты в виде списка целых чисел. Ваша задача — написать программу,
# которая поможет исследователям выделить чётные числа из списка результатов экспериментов.
# Они хотят анализировать эти числа в обратном порядке,
# чтобы исследовать особые закономерности, связанные с чётными значениями.
#
# Задача
# Напишите программу, которая считывает целые числа из списка и выводит из него
# только чётные в обратном порядке. Создавать дополнительные списки нельзя.
#
# Ограничения
# Нельзя использовать:
#
# метод reverse,
# функцию reversed,
# разворот при помощи среза (список[::-1]).
#
# Советы
# Вы можете управлять направлением перебора элементов в списке
# (можете перебирать элементы с начала до конца, а можете начать с конца и двигаться к началу).
# Это может стать основой решения задачи.
# Список является изменяемым типом данных, значит вы можете изменять положение элементов внутри списка.
# Это может стать основой ещё одного варианта решения задачи. Можете выбрать любой или решить обоими способами!
# Обратите внимание: некоторые операции со списками создают их копии,
# даже если вы не указываете на это явно. Простой пример, который это демонстрирует:
# test = [1, 2, 3]
# print(id(test)) # Здесь вы увидите один айди
# test = test[::-1]
# print(id(test)) # А здесь уже другой

import random
import time

start_creating_list = time.perf_counter()
def creating_list(quantity):
    rand_list = []

    for _ in range(quantity):
        number = random.randint(-100, 100)
        float_num = random.uniform(-100, 100)
        float_num = round(float_num, 2)
        digit = random.randint(0, 9)
        rand_list.append(digit)
        rand_list.append(float_num)
        rand_list.append(number)

    return rand_list

creating_list_speed = time.perf_counter() - start_creating_list
print(f"Скорость генерации списка: {creating_list_speed}\n")

numbers_list = creating_list(10)

print(f"Список:\n{numbers_list}")
print(f"Длина списка: {len(numbers_list)}")
l = len(numbers_list)
for i in range(l):
    if numbers_list[i] > 0 and numbers_list[i] % 2 == 0:
        print(f"{numbers_list[i]}", end = '    ')


********************************************************************************

# Часть 2. Модуль 2. Видео 1. Задача 1. Таблица степеней
#
# Иправить ошибки в коде. Убедитесь, что программа работает верно.
#
# Пример:
# Новое число: 1
# Текущий список чисел: [3, 7, 5, 1]
# 9 27 81
# 49 343 2401
# 25 125 625
# 1 1 1
# Новое число: 2
# Текущий список чисел: [3, 7, 5, 1, 2]
# 9 27 81
# 49 343 2401
# 25 125 625
# 1 1 1
# 4 8 16

numbers = [3, 7, 5]

while True:
    number = int(input('Новое число: '))
    numbers.append(number)
    print(f"Текущий список чисел: {numbers}")

    for i in numbers:
         print(i ** 2, i ** 3, i ** 4, sep="\t")
    print()


********************************************************************************

# Часть 2. Модуль 2. Видео 1. Задача 2. Очень простая задача
#
# Напишите программу, которая заполняет список числами от 0 до 100 и выводит его на экран.

numbers_list = []
def var_1_numbers_k_n():
    for i in range(101):
        numbers_list.append(i)
    return numbers_list

def var_2_numbers_k_n(k, n): # упрощенный вариант
    numbers_list = list(range(k, n))
    return numbers_list


if __name__ == '__main__':
    result = var_2_numbers_k_n(0, 101)
    print(result)


********************************************************************************

# Часть 2. Модуль 2. Видео 1. Задача 3. Контроль
#
# Напишите программу, которая сначала запрашивает у пользователя количество сотрудников в офисе,
# ID их пропусков, а затем запрашивает ID пропуска, который нужно найти в этом списке.
# Если такой есть, то вывести «Сотрудник на месте», а иначе «Сотрудник не работает!».
#
# Пример:
# Кол-во сотрудников в офисе: 4
# ID сотрудника: 10
# ID сотрудника: 20
# ID сотрудника: 30
# ID сотрудника: 40
# Какой ID ищем? 35
# Сотрудник не работает!

quantity_employees = int(input('Введите кол-во сотрудников: '))

list_id_employees = []
for _ in range(1, quantity_employees + 1):
    id = int(input('ID сотрудника: '))
    list_id_employees.append(id)

verifiable_id = int(input('Какой ID ищем? '))

search = False
for id in  list_id_employees:
    if id == verifiable_id:
        search = True

if search:
    print("Сотрудник на месте.")
else:
    print("Сотрудник не работает!")

# Вариант решения 2
# if search_id not in workers_id:
    # print('Сотрудник не работает!'"')
# else:
    # print('"'Сотрудник на месте.'"')

# Вариант решения 3
# if verifiable_id in list_id_employees:
    # print('Сотрудник на месте.')
# else:
    # print('Сотрудник не работает!')



********************************************************************************

# Часть 2. Модуль 2. Видео 2. Задача 1. Гугл
#
# Программисты постоянно гуглят ошибки и ищут уже готовый код,
# который можно использовать для своей программы, чтобы не изобретать велосипед.
# Вы нашли код, который должен находить минимальное и максимальное числа в списке:
#
# nums_list = []
# N = int(input('Кол-во чисел в списке: '))
# for _ in range(N):
#  num = int(input('Очередное число: '))
#  nums_list.append(num)
# maximum = 0
# minimum = -1
# for i in nums_list:
#  if maximum < i:
#    maximum = i
#  if minimum > i:
#    minimum = i
# print('Максимальное число в списке:', maximum)
# print('Минимальное число в списке:', minimum)
#
# Однако он столкнулся с проблемой. Если брать, к примеру, количество чисел 5, то на тестах
# -1 -2 -3 -4 -5 и 1 2 3 4 5 программа выводит неверный результат.
#
# Доработайте программу так, чтобы она выводила верный результат.
# Подсказка: для отладки используйте точки останова.

def var1():
    nums_list = []

    N = int(input('Кол-во чисел в списке: '))

    for _ in range(N):
        num = int(input('Очередное число: '))
        nums_list.append(num)

    if nums_list:
        maximum = nums_list[0]
        minimum = nums_list[0]

        for i in nums_list:

            if maximum < i:
                maximum = i

            if minimum > i:
                minimum = i

        print(f"Максимальное число в списке: {maximum}")
        print(f"Минимальное число в списке: {minimum}")

    else:
        print('Список пуст.')


def var2(): # Аналогичное решение при помощи функции enumerate:

    user_msg = input("Введите строку: ")
    letters = list(user_msg)
    what_replace = ":"
    for_what_replace = ";"
    for index, letter in enumerate(letters):
        if letter == what_replace:
            letters[index] = for_what_replace

    for letter in letters:
        print(letter, end='')

# var1()
var2()

********************************************************************************

# Часть 2. Модуль 2. Видео 2. Задача 2. Кратность
# Пользователь вводит список из N чисел и число K.
# Напишите код, выводящий на экран сумму индексов элементов списка, которые кратны K.
#
# Пример:
# Кол-во чисел в списке: 4
# Введите 1 число: 1
# Введите 2 число: 20
# Введите 3 число: 30
# Введите 4 число: 4
# Введите делитель: 10
# Индекс числа 20: 1
# Индекс числа 30: 2
# Сумма индексов: 3


n = int(input('Кол-во чисел в списке: '))

nums_list = []

for i in range(n):
    num = int(input(f"Введите {i + 1} число: "))
    nums_list.append(num)

dev = int(input('Введите делитель: '))

sum_i = 0
id = 0

for elem in nums_list:
    if elem % dev == 0:
        print(f"Индекс числа {elem}: {id}")
        sum_i += i
    id += 1

print(f"Сумма индексов: {sum_i}")


********************************************************************************

# Часть 2. Модуль 2. Видео 2. Задача 3. Собачьи бега
#
# Дан список очков из N собак. Напишите программу,
# которая меняет местами наибольший и наименьший элементы в списке.

def is_control(num) -> bool:
    return num < 0

def search_min(nums_list: list):
    if nums_list:
        minimum = nums_list[0]

        for elem in nums_list:
            if minimum > elem:
                minimum = elem

        return minimum

    else:

        return f"Список пуст"


def search_max(nums_list: list):
    if nums_list:
        maximum = nums_list[0]

        for elem in nums_list:
            if maximum < elem:
                maximum = elem

        return maximum

    else:

       return f"Список пуст"


def swap():
    list_points, list_result = [], []

    for i in range(n):
        num = int(input(f"Очки {i + 1}-й собаки: "))
        if is_control(num):
            raise ValueError("Ошибка ввода. Введите положительное число.")
        list_points.append(num)

    print(f"Список очков: {list_points}")
    min_point = search_min(list_points)
    print(f"Минимальное кол-во очков: {min_point}")
    max_point = search_max(list_points)
    print(f"Максимальное кол-во очков: {max_point}")

    for elem in list_points:
        if elem == min_point:
           list_result.append(max_point)
        elif elem == max_point:
            list_result.append(min_point)
        else:
            list_result.append(elem)

    return list_result



if __name__ == '__main__':
    n = int(input('Кол-во собак: '))
    result = swap()
    print(f"Список отсортированных очков: {result}")


********************************************************************************

# Часть 2. Модуль 2. Видео 3. Задача 1. Текстовый редактор: возвращение
#
# Пользователь вводит строку S. Напишите программу, которая заменяет в строке все двоеточия (:)
# на точки с запятой (;).
# Также подсчитайте количество замен и выведите ответ на экран (и новую строку тоже).
# Для решения используйте список.
#
# Пример:
# Введите строку: гвозди:шурупы:гайки
# Исправленная строка: гвозди;шурупы;гайки
# Кол-во замен: 2


user_msg = input("Введите строку: ")
letters = list(user_msg)
what_replace = ":"
for_what_replace = ";"
index = 0
replace_count = 0
for letter in letters:
    if letter == what_replace:
        letters[index] = for_what_replace
        replace_count += 1
    index += 1

print("Исправленная строка:", end=' ')
for letter in letters:
    print(letter, end='')

print("Кол-во замен:", replace_count)


********************************************************************************

# Часть 2. Модуль 2. Видео 3. Задача 2. Соседи
#
# Дана строка S и номер позиции символа в строке. Напишите программу,
# которая выводит соседей этого символа и сообщение о количестве таких же символов среди этих соседей:
# их нет, есть ровно один или есть два таких же.
#
# Пример 1:
# Введите строку: abbc
# Номер символа: 3
# Символ слева: b
# Символ справа: c
# Есть ровно один такой же символ.
#
# Пример 2:
# Введите строку: abсd
# Номер символа: 3
# Символ слева: b
# Символ справа: d
# Таких же символов нет.

msg = input("Введите строку: ")
index_of_letter = int(input("Номер символа: ")) - 1  # сразу отнимаем 1, чтобы превратить номер в индекс
letters = list(msg)
count = 0

if index_of_letter > 0:
    print("Символ слева:", letters[index_of_letter - 1])
    if letters[index_of_letter - 1] == letters[index_of_letter]:
        count += 1
if index_of_letter < len(letters) - 1:
    print("Символ справа:", letters[index_of_letter + 1])
    if letters[index_of_letter + 1] == letters[index_of_letter]:
        count += 1

if count == 0:
    print("Таких же символов нет.")
elif count == 1:
    print("Есть ровно один такой же символ.")
elif count == 2:
    print("Таких символов два.")


********************************************************************************

# Часть 2. Модуль 2. Видео 3. Задача 3. Улучшенная лингвистика
#
# Есть список из трёх слов, которые вводит пользователь.
# Затем вводится сам текст произведения строго по словам.
# Текст вводится до тех пор, пока не встретится слово end.
# Напишите программу, которая посчитает, сколько раз слова пользователя встречаются в тексте.
#
# Пример:
# Введите 1 слово: я
# Введите 2 слово: год
# Введите 3 слово: лучший
#
# Слово из текста: этот
# Слово из текста: год
# Слово из текста: -
# Слово из текста: лучший
# Слово из текста: год
#
# Подсчёт слов в тексте
# я: 0
# год: 2
# лучший: 1

words_list = []
counts = [0, 0, 0]

for i in range(3):
    print("Введите", i + 1, "слово", end=' ')
    word = input()
    words_list.append(word)

text = input("Слово из текста: ")
while text != "end":
    for index in range(3):
        if words_list[index] == text:
            counts[index] += 1
    text = input("Слово из текста: ")

print("Подсчёт слов в тексте")
for i in range(3):
    print(words_list[i], ':', counts[i])

********************************************************************************




********************************************************************************

# Часть 2. Модуль 3. Практическая работа. Задание 1. Страшный код
#
# Есть один основной (‘a’) и два побочных списка (‘b’ и ‘c’),
# в основном лежат элементы [1, 5, 3], а в побочных — [1, 5, 1, 5] и [1, 3, 1, 5, 3, 3] соответственно.
#
# Программа добавляет элементы побочного списка ‘b’ в основной, а затем считает количество цифр 5.
# Это число выводится на экран, и после этого цифры 5 удаляются из основного списка.
# Затем программа добавляет в основной список элементы списка ‘c’,
# считает количество цифр 3 и выводит это число на экран.
# В конце появляется и сам список.
#
# Код:
# a = [1, 5, 3]
# b = [1, 5, 1, 5]
# c = [1, 3, 1, 5, 3, 3]
# for i in b:
# a.append(i)
# t = 0
# for i in a:
# if i == 5:
# t += 1
# print(t)
# d = []
# for i in a:
# if i != 5:
# d.append(i)
# for i in c:
# d.append(i)
# t = 0
# for i in d:
# if i == 3:
# t += 1
# print(t)
# print(d)
# Используя знания о методах списков, а также о стиле программирования,
# помогите другу переписать программу. Не используйте дополнительные списки.
#
# Результат работы программы:
# Количество цифр 5 при первом объединении: 3
# Количество цифр 3 при втором объединении: 4
# Итоговый список: [1, 3, 1, 1, 1, 3, 1, 5, 3, 3]
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

list_a = [1, 5, 3]
b = [1, 5, 1, 5]
c = [1, 3, 1, 5, 3, 3]

list_a.extend(b)
print(f"Количество цифр 5 при первом объединении: {list_a.count(5)}")
while 5 in list_a:
    list_a.remove(5)
print(f"Cписок: {list_a}")
list_a.extend(c)
print(f"Количество цифр 3 при втором объединении: {list_a.count(3)}")
print(f"Итоговый список: {list_a}")


********************************************************************************

# Часть 2. Модуль 3. Практическая работа. Задание 2. Уникальное объединение списков
#
# Напишите программу, которая объединяет два отсортированных списка целых чисел в один отсортированный список без дубликатов.
#
# Пример:
# list1 = [1, 3, 5, 7, 9]
# list2 = [2, 4, 5, 6, 8, 10]
# merged = merge_sorted_lists(list1, list2)
# print(merged)
# Вывод в консоли:
# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# Советы
# Учтите, что один список может быть короче другого.
# Проверьте ваше решение с различными тестовыми данными, включая случаи с пустыми списками,
# списками без дубликатов и списками с повторяющимися элементами.
# Убедитесь, что в вашем итоговом списке не будет дубликатов.


def merge_sorted_lists(list1, list2):
    print(f"Исходные списки:\n{list1}\n{list2}")
    list1.extend(list2)
    print(f"Слияние:{list1}")
    list1.sort()
    print(f"Сортировка:{list1}")
    set_list = set(list1)
    list1 = list(set_list)

    return list1

if __name__ == '__main__':
    test_cases = [
        [[1, 3, 5, 7, 9], [2, 4, 5, 6, 8, 10]],
        [[1, 3, 5, 7, 9], [2, 4, 6, 8]],
        [[1, 3, 5, 7, 9], [1, 2, 3, 4, 5, 5, 7, 8, 9]],
        [[1, 3, 5, 7, 9], [1, 3, 5, 7, 9]],
        [[1, 3, 5, 7, 9], []],
        [[], []]
    ]

    for list1, list2 in test_cases:
        result = merge_sorted_lists(list1, list2)
        print(f"Слитый отсортированный и очищенный от дубликатов список:\n{result}\n")

********************************************************************************

# Часть 2. Модуль 3. Практическая работа. Задание 3. Детали
#
# В базе данных магазина всякой всячины хранится список названий деталей и их стоимостей:
#
# shop = [['каретка', 1200], ['шатун', 1000], ['седло', 300], ['педаль', 100], ['седло', 1500], ['рама', 12000], ['обод', 2000], ['шатун', 200], ['седло', 2700]]
#
# Напишите программу, которая запрашивает у пользователя деталь, считает их количество и общую стоимость.
#
# Пример:
# Название детали: седло
# Количество деталей: 3
# Общая стоимость: 4500
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

shop = [
    ['каретка', 1200],
    ['шатун', 1000],
    ['седло', 300],
    ['педаль', 100],
    ['седло', 1500],
    ['рама', 12000],
    ['обод', 2000],
    ['шатун', 200],
    ['седло', 2700]
]

count = 0
summ = 0
detail = input('Введите название детали: ')

for i_shop in shop:
    if i_shop[0] == detail:
        count += 1
        summ += i_shop[1]

print(f"Кол-во деталей {count}, общая сумма: {summ}")

********************************************************************************

# Часть 2. Модуль 3. Практическая работа. Задание 4. Вечеринка
#
# Дан список гостей, которые пришли к началу:
# guests = [‘Петя’, ‘Ваня’, ‘Саша’, ‘Лиза’, ‘Катя’]
#
# Напишите программу, которая спрашивает у пользователя,
# ушёл ли человек и пришёл ли новый гость, и, исходя из ответа,
# добавляет в список или удаляет из него нужное имя.
# При этом гостей может быть не больше шести.
# Имена запрашиваются до тех пор, пока пользователь не введёт сообщение «Пора спать».
#
# Пример:
# Сейчас на вечеринке 5 человек: [‘Петя’, ‘Ваня’, ‘Саша’, ‘Лиза’, ‘Катя’]
# Гость пришёл или ушёл? пришёл
# Имя гостя: Алекс
# Привет, Алекс!
# Сейчас на вечеринке 6 человек: [‘Петя’, ‘Ваня’, ‘Саша’, ‘Лиза’, ‘Катя’, ‘Алекс’]
# Гость пришёл или ушёл? пришёл
# Имя гостя: Гоша
# Прости, Гоша, но мест нет.
# Сейчас на вечеринке 6 человек: [‘Петя’, ‘Ваня’, ‘Саша’, ‘Лиза’, ‘Катя’, ‘Алекс’]
# Гость пришёл или ушёл? ушёл
# Имя гостя: Ваня
# Пока, Ваня!
# Сейчас на вечеринке 5 человек: [‘Петя’, ‘Саша’, ‘Лиза’, ‘Катя’, ‘Алекс’]
# Гость пришёл или ушёл? Пора спать
# Вечеринка закончилась, все легли спать.
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

guests = ["Петя", "Ваня", "Саша", "Лиза", "Катя"]

while True:
    print(f"Сейчас на вечеринке {len(guests)} человек: {guests}")
    guest_action = input('Гость пришёл или ушёл?: ')

    match guest_action:
        case 'пришёл' | 'Пришёл' | 'пришeл' | 'Пришeл' | 'п' | 'П':
            guest_name = input('Как зовут гостя?: ')
            if len(guests) == 6:
                print(f"Прости, {guest_name}, но мест нет.")
            else:
                print(f"Привет, {guest_name}!")
                guests.append(guest_name)
        case 'ушёл' | 'Ушёл' | 'ушел' | 'Ушел' | 'у' | 'У':
            guest_name = input('Как зовут гостя, который ушел?: ')
            if guest_name in guests:
                print(f"Пока, {guest_name}!")
                guests.remove(guest_name)
            else:
                print(f"{guest_name} на вечеринке не присутствовал(а)!")
        case 'Пора спать' | 'пора спать' | 'спать' | 'Cпать':
            print('Вечеринка закончилась, все легли спать.')
            break
        case _:
            print('Ваша команда не распознана!')
            break


********************************************************************************

# Часть 2. Модуль 3. Практическая работа. Задача 5. Песни
#
# Есть список из девяти песен группы Depeche Mode.
# В информацию о каждом треке входит название и продолжительность с точностью до долей минут:
#
# violator_songs = [
# ['World in My Eyes', 4,86],
# ['Sweetest Perfection', 4,43],
# ['Personal Jesus', 4,56],
# ['Halo', 4,9],
# ['Waiting for the Night', 6,07],
# ['Enjoy the Silence', 4,20],
# ['Policy of Truth', 4,76],
# ['Blue Dress', 4,29],
# ['Clean', 5,83]
# ]
#
# Напишите программу, которая запрашивает у пользователя количество песен из списка и их названия,
# а на экран выводит общее время их звучания.
#
# Пример:
# Сколько песен выбрать? 3
# Название 1-й песни: Halo
# Название 2-й песни: Enjoy the Silence
# Название 3-й песни: Clean
# Общее время звучания песен — 14,93 минуты
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

violator_songs = [
    ['World in My Eyes', 4.86],
    ['Sweetest Perfection', 4.43],
    ['Personal Jesus', 4.56],
    ['Halo', 4.9],
    ['Waiting for the Night', 6.07],
    ['Enjoy the Silence', 4.20],
    ['Policy of Truth', 4.76],
    ['Blue Dress', 4.29],
    ['Clean', 5.83]
]

n = int(input('Сколько песен выбрать?: '))
timer = 0

for i in range(1, n+1):
    some_song = input(f"Название {i}-й песни: ")
    for i_song in violator_songs:
        if i_song[0] == some_song:
            timer += i_song[1]


print(f"\nОбщее время звучания песен: {round(timer, 2)} минут.")

********************************************************************************

# Часть 2. Модуль 3. Практическая работа. Задание 6. Ролики
#
# Пользователь вводит два списка размеров: N размеров коньков и K размеров ног людей.
# Реализуйте код, который определяет,
# какое наибольшее число человек может одновременно взять ролики и пойти кататься.
#
# Пример:
# Количество коньков: 4
# Размер пары 1: 41
# Размер пары 2: 40
# Размер пары 3: 39
# Размер пары 4: 42
# Количество людей: 3
# Размер ноги человека 1: 42
# Размер ноги человека 2: 41
# Размер ноги человека 3: 42
# Наибольшее количество людей, которые могут взять ролики: 2
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.
# Советы и рекомендации
# Помните, по условиям задачи размер коньков должен быть больше размера ноги или равен размеру ноги.
# Чтобы подобрать максимальное количество пар,
# старайтесь найти наименьший возможный размер коньков для каждого размера ноги.

skates_size, people_size = [], []

n = int(input('Введите кол-во пар коньков: '))
for i in range(1, n+1):
    men = int(input(f"Размеры {i}-й пары: "))
    skates_size.append(men)

k = int(input('\nВведите кол-во людей: '))
for i in range(1, k+1):
    skate = int(input(f"Размер ноги {i}-го человека: "))
    people_size.append(skate)

count = 0
for i_men in people_size:
    for j_skate in skates_size:
        if i_men == j_skate:
            skates_size.remove(j_skate)
            count += 1

print(f"\nКол-во обутых людей: {count}")
print(f"Оставшиеся размеры: {skates_size}")



********************************************************************************

# Часть 2. Модуль 3. Практическая работа. Задание 7. Считалка
#
# ИНДЕКС ВЫХОДИТ ЗА ПРЕДЕЛЫ СПИСКА - ЧТО ДЕЛАТЬ
#
# N человек, пронумерованных числами от 1 до N, стоят в кругу.
# Каждый K-й по счёту человек выходит из круга, после чего счёт продолжается со следующего за ним человека.
#
# На вход подаётся количество человек N и номер K.
# Напишите программу, которая выводит число от 1 до N — это номер человека, который останется в кругу последним.
#
# Пример:
# Количество человек: 5
# Какое число в считалке? 7
# Значит, выбывает каждый 7-й человек
# Текущий круг людей: [1, 2, 3, 4, 5]
# Начало счёта с номера 1
# Выбывает человек под номером 2
# Текущий круг людей: [1, 3, 4, 5]
# Начало счёта с номера 3
# Выбывает человек под номером 5
# Текущий круг людей: [1, 3, 4]
# Начало счёта с номера 1
# Выбывает человек под номером 1
# Текущий круг людей: [3, 4]
# Начало счёта с номера 3
# Выбывает человек под номером 3
# Остался человек под номером 4
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.
# Советы и рекомендации
# Чтобы индекс не вышел за пределы списка, нужно ограничить его рост.
# Для этого подходит операция %: (индекс + число) % длина списка.
# Так индекс не будет равен длине списка или не превысит её, а значит не выйдет за пределы списка.

n = int(input('Введите кол-во человек в игре: '))
k = int(input('Введите номер, на котором будет завершаться круг счета: '))
print(f"Выбывает каждый {k}-й человек в круге.")
people_list = list(range(1, n+1))
id_retired = 0

for _ in range(n-1):
    id_start = id_retired % len(people_list)
    id_retired = (id_start + k - 1) % len(people_list)
    print(f"\nТекущий круг людей: {people_list}\n"
          f"Начало счёта с номера: {people_list[id_start]}\n"
          f"Выбывает человек под номером: {people_list[id_retired]}")
    people_list.remove(people_list[id_retired])

print(f"\nОстался человек под номером {people_list[0]}")


********************************************************************************

# Часть 2. Модуль 3. Практическая работа. Задание 8. Симметричная последовательность
# Решение на skillbox через срезы

import time

start = time.perf_counter()
def is_palindrome(num_list):
    reverse_list = num_list[::-1]    # реверс списка через срез
    if num_list == reverse_list:
        return True
    else:
        return False

nums = [-2, 45, -80, -89, 54, -61, 8, -41, -5, 1, 55, -93, 89, 24, -84, 98, -37, -21, 86, 97, 48, 43, 28, 93, 25, -65, 67,
        -7, -19, 79, -95, 45, 83, -41, 64, -91, -45, -75, 48, 78, 33, 86, 34, -92, 52, -14, -80, -82, -12, -100, 56, -52,
        84, 21, -82, -23, 95, -60, 4, -5, -66, -77, -73, 51, -2, -2, -23, 23, -66, -50, -17, 70, 46, -17, -71, -57, -79, 77,
        -66, 24, -59, -83, 12, -1, -67, -21, -32, -61, -60, 57, -9, -91, 8, 95, -83, -37, -90, -62, -56, -28, 87, 42, 90, 6,
        70, 99, 33, -77, -65, 11, 50, -55, -76, -37, -72, 27, 66, 86, -2, 71, 21, -55, -57, 82, 64, 55, -72, 44, 77, 28, 76,
        89, 62, -89, 75, 36, -25, -1, 71, -75, 73, -74, 94, -22, 86, -58, -19, -98, -82, -98, 1, 64, -5, 62, 9, 74, -35, 28,
        10, 59, -82, 31, 54, 47, -17, 34, 85, -71, 94, -43, -44, 73, 60, 42, -69, -4, 54, 23, -37, -63, -18, -89, 99, 99, 14,
        81, -18, -90, -17, 4, -40, 84, 70, 78, 63, 94, -86, -2, 82, -17, -45, 84, -7, 96, 76, -33, -72, -67, 78, -72, 43, -59,
        33, 49, 43, -5, 30, -23, -43, 44, -32, 22, -88, -87, -76, -77, -43, 57, 96, 87, -87, -4, 73, 79, 82, 17, 78, 31, 100,
        34, 45, -89, -67, 73, 64, -76, 54, -15, -97, -19, -44, 17, -41, 93, -52, 4, 5, 56, 70, -23, -18, 54, -5, 53, -56, -22,
        98, 96, 24, 92, 33, 39, -87, 57, -74, 56, 11, -71, -74, -21, -25, -99, -84, 54, -66, -35, -36, -78, -4, 29, -3, -62,
        -20, -27, 87, 67, 13, -17, 82, 60, 88, -45, -34, 29, 48, 19, 48, -87, -97, -77, -37, -42, 57, 30, -84, 87, -59, 95,
        50, -53, -68, -96, -37, 63, -2, -4, 21, -31, -83, -94, 22, -36, -98, -33, -19, 63, 21, 34, -29, 81, 79, 97, 41, 18,
        -3, -95, -90, 93, -57, -16, 43, -31, 4, 44, 53, 92, 42, 53, 82, 98, -47, 36, 52, 87, -82, 77, 92, 100, 61, -90, 70,
        -67, 29, -9, 41, -39, 29, 87, 66, 54, 37, 9, 2, -98, -63, -17, 14, 15, 85, -29, 92, -83, 92, -14, -76, 79, -94, 12,
        -67, -73, 92, -31, -11, -64, -5, 52, -94, -21, -76, 1, 63, 82, -48, -94, 57, -16, -26, 63, 11, -43, 58, -21, -40,
        -50, 77, -79, -4, 25, 26, -46, 65, 90, -27, 50, -28, -74, 43, 26, -56, -99, -52, 22, 57, 61, -50, 21, -40, 11, 62,
        38, 96, -85, 25, 34, 60, -58, -3, 32, 23, 60, -40, -36, -48, -33, 14, -1, 85, -53, -82, -30, -50, -100, 73, 4, 41,
        52, 35, -29, -81, -51, -66, 39, -55, 82, -50, -38, -91, -19, 90, 73, 9, 10, 15, 81, 6, 74, 59, 39, -45, -72, -54,
        86, 79, -79, -91, -61, 25, -68, 98, -88, 27, -16, 48, 58, 93, -22, -38, -100, -96, -89, -21, -30, -78, 9, -84, 33,
        -46, 41, 30, 20, 12, -66, 30, -29, 40, 80, 29, 84, -57, -79, 2, -85, -25, 60, -45, -9, -83, 73, -48, 48, -45, 96,
        74, 91, -31, 1, -85, 83, 92, 26, 46, 11, 1, 8, -59, 74, 71, -42, -25, 5, -86, -100, -12, 63, 63, -21, 31, 50, 48,
        -94, 7, 16, -17, 66, -51, -87, 7, 89, -1, 46, 71, 17, 39, 17, 97, -77, 97, -90, -85, 29, -61, -54, -26, -85, 97,
        65, 92, -49, 38, 30, 39, 49, -11, -74, -68, 6, 56, 89, -85, -94, -9, 68, -25, 11, 4, -100, 74, -65, -88, 4, -35,
        -85, 51, 8, -98, 92, -62, -93, 69, 68, -3, -13, 3, 51, -59, 9, -72, -66, 44, -37, 72, -14, -84, -57, 79, -2, -91,
        -4, 90, -12, 30, 92, 28, -54, 47, -11, -28, 49, -55, 91, 61, 32, 22, -54, 69, -13, 46, 65, 79, 76, 4, 71, 21, -89,
        -47, 28, -13, 6, -97, -7, 92, -27, -16, -55, 80, 60, -65, -83, -39, -60, -65, -45, 93, -25, 49, 62, 33, 35, 92,
        -38, -97, -86, -40, 52, 86, 0, -15, -86, -22, -47, -6, -43, -14, -30, 61, 23, 91, 2, 45, 98, 34, -43, 16, -74, 37,
        -55, -91, -95, -21, 31, 67, -75, 89, 50, 7, 95, -28, 96, -34, 53, 55, -60, 6, 69, 53, 70, -68, -78, 94, -96, 91,
        72, -71, 10, -25, 45, 65, 96, 57, -90, 87, -2, -89, 3, -71, -10, 89, -71, 71, 61, 33, -2, 93, 15, 51, -25, -9, 65,
        16, -57, 82, -11, -81, -8, -38, 59, -51, -21, -29, 61, -71, 17, 14, 54, 40, -84, -24, -4, -10, 66, -31, -20, -29,
        -52, 61, 52, -55, -75, 12, -74, -43, -37, -7, 51, -87, -61, 21, 6, 44, 54, 25, -17, -43, 27, -9, -8, 63, 14, 1, 5,
        -100, 33, -18, -32, -29, -21, -38, -58, 90, 17, -43, -70, 37, -47, 52, 47, 74, 84, 13, 47, -47, -16, 85, 63, 25,
        -93, 52, -20, -40, 31, 72, 88, -99, 79, 92, -23, -97, -52, 16, -41, -82, 16, 84, -6, 62, 83, -41, -70, 70, -71,
        -63, -44, 75, 7, 4, -98, -43, -38, -48, -81, 56, 88, 91, 87, 72, -78, -56, -12, 88, -89, -56, 49, 48, 49, -94, 1,
        -60, -15, -52, -25, -33, 37, 86, -12, -62, 7, 76, -13, 28, 32, -56, -19, -66, -31, 2, -49, 75, -68, 78, -11, 99,
        40, 3, -73, -71, 51, 93, 42, -89, 70, -31, 66, 13, -98, 64, 57, 73, 33, 75, 52, -80, -77, 80, -73, -67, 58, 22,
        -23, 36, 94, -20, 64, -68, -27, -40, 49, -100, 27, -75, -68, -19, 87, 45, -89, 72, 7, 14, 11, -37, 60, 37, -1, 44,
        94, 53, -74, 28, -5, 75, 73, -33, 36, -47, -97, -70, -66, 68, 65, 55, 35, 24, -25, 96, -81, 51, -16, 49, -19, 30,
        -97, 88, 43, 60, -30, 10, 67, -37, -99, 20, -32, -34, -84, 61, 34, -50, 18, 90, -68, 93, -90, 58, -65, 34, 84, -2,
        55, -48, -11, -85, 87, -88, 85, -59, -63, 3, 65, -60, -48, -47, -3, 71, -30, 49, 4, 20, 81, -77, -2, -13, 67, 2,
        -1, 13, 25, -86, -76, 26, 11, 75, -68, -89, 86, 61, 65, 87, 95, 71, 51, 55, 11, 43, 64, -53, 58, -77, 36, -63,
        -14, -77, 18, 92, 41, -78, 18, 85, -24, -24, 66, -94, 40, 18, 27, -19, -57, 30, -74, 27, 88, 91, -4, -10, 10, 80,
        40, 44, -10, 79, -100, 75, 64, 69, 93, 77, 30, -23, 78, -81, 74, -46, -13, -58, -31, -87, -12, 20, -38, 14, -3, 79,
        92, -42, -75, -80, -13, 89, -72, 60, -3, 44, 27, -6, 40, 23, 33, 52, 10, -71, -2, -24, 72, -45, 15, -48, -30, 88,
        -59, 26, -85, -41, 38, 21, -80, -9, 13, -86, -8, -75, -41, 86, 79, -91, -58, 54, 72, -73, 88, -8, -41, -16, 0, -80,
        73, 64, 32, -51, 36, 53, -61, 82, 44, -28, -54, -55, -95, -59, -41, -72, -13, -70, 57, -39, -15, 47, 79, -12, -91,
        -57, 60, 55, 17, -6, -61, 94, -80, -57, -58, 60, -79, -78, 84, 49, 37, 4, 65, -89, -87, 44, -41, -8, -37, -55, 13,
        93, -90, 68, 6, -42, -33, 51, 8, -9, 83, -99, 66, -67, -27, -2, 60, -15, -65, 72, -77, -65, 48, 59, 81, 25, -60, 91,
        -36, 3, 33, -45, -61, -28, 76, -45, -42, 34, 43, -45, 70, -3, -76, 54, -41, 6, -71, -87, -9, -31, 65, 67, -24, 89,
        37, -20, -8, -25, -98, 45, -69, 46, 74, 94, -59, -24, -51, -91, -66, 87, 52, 58, -47, 75, -99, -11, -13, -87, -28,
        -100, 54, -66, -27, -79, 33, 84, 38, 90, -9, -46, 8, -63, -79, -71, 71, -17, 0, 94, 54, -43, 81, -64, -30, 29, 70,
        -90, -74, 73, 74, -20, 59, 57, -71, -58, -88, -87, 7, -19, -46, -54, -19, -66, 69, 16, 45, -27, 84, -60, -70, -32,
        15, -15, -62, -38, 57, -76, -72, -88, 37, -82, 91, 59, 22, -70, 82, 11, -21, 18, -79, 53, 79, 74, 67, -89, 100, -37,
        35, -6, -45, 60, -21, -74, -20, 73, -69, 39, -56, -85, 49, -31, -23, 19, 27, 74, 75, 74, 62, 95, -10, 8, -43, 45,
        -53, 90, 91, -60, 33, -56, -4, 98, -6, -55, 31, 0, -95, -1, -90, 13, 30, 92, 86, -4, 89, -19, -31, 64, -23, 84, 29, 4,
        5, -48, -6, 48, 62, 57, -9, 31, -72, 17, 18, 9, -35, 18, 45, -63, 41, -88, -14, -43, -3, 74, 39, -97, -9, 66, -2,
        -83, -8, 60, 93, -13, -17, -31, 50, 77, 69, -32, 62, -26, -34, 99, -50, -30, 23, -38, -75, -10, -21, 34, 91, -75,
        8, 28, 93, 93, -15, 64, 28, 5, -57, -82, -84, 32, -39, -83, -79, 68, -18, -88, -78, -84, 74, -75, -31, -95, -23, -39,
        -16, -14, 57, -4, -97, -54, 36, 43, -19, 77, -85, -6, -92, -32, 93, -18, 11, 44, -72, 16, 100, -89, 8, 7, -76, 88,
        78, 41, -93, -19, 49, -28, -25, 53, -4, 37, 39, 63, 85, 22, -99, -56, -38, -74, -18, -76, -92, -58, -68, 17, -60,
        33, 42, -35, 50, 41, -13, -25, 25, 1, 93, -1, 33, -34, -74, 25, -8, 43, -14, 69, -69, 19, -89, 30, -62, -96, 12, 66,
        92, -12, -83, 26, -44, 48, 44, 43, 97, -38, -28, 58, 31, 67, 20, -28, -88, 87, 12, -90, -9, -48, -78, 14, -83, 70, 100,
        -87, -4, -18, -2, 41, -8, -69, 59, 73, 45, 40, 99, -48, -15, 70, -53, 98, -40, -99, -37, -52, -44, -44, 88, 71, 57, -69,
        -25, 39, 73, 36, -90, -42, -49, -89, 64, -74, 79, -54, -43, -8, -44, -18, -66, 8, 9, 89, -100, -90, -30, 75, -71, 9,
        26, -80, 64, 18, -10, 37, 69, 24, -25, -45, -40, -12, 65, 11, 73, -8, -74, -57, -96, 68, 86, -4, -89, -42, 5, -22,
        -38, 42, 14, -59, 9, -32, 72, -56, 48, 97, -76, 46, 7, 38, -79, 65, -55, 4, -16, 55, 69, 24, 81, -76, 91, 67, -42,
        53, -47, 0, 31, 21, 79, -63, -97, 1, -58, 68, -32, 95, 73, -36, -51, 67, -73, -88, 86, 15, 55, -38, -78, 95, 8, -62,
        18, 93, -27, 15, -58, 85, 44, 32, 12, -8, -24, 52, -56, -54, -8, 88, 53, 17, 37, 98, 28, 9, 40, 28, -97, 46, -87, 13,
        63, -86, -12, 17, 10, -60, -85, -95, 52, 17, -92, 58, -35, 8, 85, 63, -90, -23, -23, -89, 78, -66, -49, -60, 64, -26,
        37, 60, -51, 16, 75, -97, 47, -64, -63, -90, -35, -15, -90, 75, -49, 64, 48, -25, 21, -24, -49, -44, 30, -1, 76, -75,
        16, 61, -100, 84, -24, 88, -20, 26, 38, -68, 58, -63, 86, 0, -85, -26, -51, -98, 5, -60, -55, 85, -7, 58, -73, 54, 17,
        89, 13, 70, 7, 72, 4, -89, -2, 9, -77, -82, -15, 82, 97, 100, -39, 45, 95, -13, 1, -28, 4, -50, 7, -52, -93, 84, 70,
        34, 28, 97, 1, -31, -34, -76, 9, 74, -5, 77, 19, 51, -31, -2, 12, -62, -25, 47, -62, -69, 76, 91, -95, 15, -3, 41,
        -21, 90, 64, 28, -12, -34, 56, -91, -59, 76, 99, -98, 81, 58, -54, 30, 27, -20, 77, -87, 0, 88, 0, -80, -8, 15, 55,
        81, 90, 47, -92, 56, 92, -22, -79, -99, -48, -10, -19, -73, 29, 44, 27, -27, 32, -43, 17, -1, 100, 31, 80, 29, 5, -67,
        -90, 100, -98, -54, 48, 22, -100, 72, 11, 55, -81, -3, 12, -61, 72, 18, -71, 52, -21, -43, 91, 83, -89, 56, 34, 89,
        -40, -56, 15, -91, -79, 18, -13, 22, 62, 49, 39, 45, -96, 9, -37, -1, -42, -98, -18, -2, 99, 21, 91, -1, -49, 26, 53,
        -10, 48, 52, -2, -16, 23, 52, -15, 34, -15, -46, 49, 83, -8, 13, -47, -20, 9, -99, -67, -84, 50, -36, 42, 84, -75,
        11, 21, -3, 16, -97, -16, -55, 64, 14, 72, -80, -32, -52, -72, 49, -97, 55, -41, -80, -92, -38, 50, -67, 76, 64,
        -29, -94, -88, 5, 73, 15, -17, 53, -26, -49, 75, 69, 75, -23, 67, 40, -41, -17, 22, 51, -5, 60, 92, -33, 26, -35,
        -8, 61, 4, 30, -26, -8, 43, -30, -31, -51, 38, -60, 94, -76, -98, 67, -23, -18, 54, 40, 27, -87, -41, 17, 46, -63,
        -96, -87, -41, 91, 27, 80, -32, -56, 14, 38, -49, 39, -97, 76, 91, -43, 93, -54, -55, -52, 40, -84, -89, 76, -84,
        -57, -30, 23, 70, -3, 49, -83, 1, -32, -45, 51, 72, 25, 87, 73, -8, 65, 43, 52, -5, -14, -81, -6, 34, 19, -87, -59,
        -83, 92, -85, 51, -66, 75, 18, 43, -2, 44, 92, 48, -90, -27, 61, -65, 31, 72, -77, -65, 10, 38, -63, -50, 31, -10,
        85, -83, 31, -64, 75, 27, -96, 68, -81, -78, -91, -68, -91, 93, -85, 30, -13, 13, 66, 88, -74, -98, 16, 65, 62, -12,
        51, 71, 43, -46, 2, 79, 99, 0, 65, -86, -56, -93, 64, -21, -56, 37, -46, 72, -18, -87, 63, -93, 77, 80, 56, -35,
        13, 65, -38, -31, -71, -13, 93, 55, 14, -76, -28, -76, 57, -1, -50, -43, 59, -10, 99, 39, 24, -54, -59, -79, -36,
        24, 75, 19, 68, -40, 35, -68, 96, -53, -94, -22, -96, 21, 98, 74, 4, 100, -94, 21, -97, 12, 83, -67, -7, 84, -66,
        99, 5, -9, -32, -26, 49, 33, 54, -70, -50, -61, -31, 28, -82, 34, -92, -58, -4, -92, 37, 54, -35, -61, -39, -84,
        78, -91, -40, 82, -21, -12, 86, 60, 51, 14, -74, -66, -44, -57, -56, 72, -59, -99, -25, -23, 75, -88, -48, -32,
        -73, -47, 67, 81, 96, -49, -47, 31, -78, 56, 23, 13, 52, 77, 54, -44, -5, 1, -19, 14, 55, -86, 86, -89, 43, 97,
        30, -91, 8, 89, -100, 95, -56, -86, -68, 6, 45, -57, 42, 99, 55, -22, -88, 100, 81, 78, 11, 59, 27, 63, 71, -99,
        29, -36, -13, 70, 94, 35, -11, -42, 20, 30, -70, 66, 2, -74, -29, 80, -3, -39, 85, -80, -76, -95, -67, 11, -14,
        -40, 91, -46, 9, -84, 59, -79, 90, -29, -43, -76, 11, 87, 25, -95, -48, 89, 50, -25, -24, 99, -75, -100, 85, -92,
        25, -24, -35, -17, 88, -91, -12, -22, -67, 98, 92, 100, 30, -30, 12, 75, -95, 48, 22, 43, -4, -91, 23, -3, 8, 67,
        20, 78, -44, -32, -70, -86, -15, 67, -65, 2, 82, 73, 54, 8, 72, 43, 63, 18, -77, 33, -96, -36, 46, -29, -85, 32,
        -43, -11, -99, -51, 64, 50, 73, -23, 74, -63, -95, 66, -17, -72, -73, 10, -57, -89, 54, -56, -24, 86, -34, -9,
        -73, -6, -46, -72, 55, -79, 4, 5, -59, 98, -27, -32, 78, 24, -94, 82, -31, -49, -20, 11, 72, -59, -73, 32, -58,
        -37, -34, 41, 56, 92, -53, -74, 62, -92, 81, 95, 99, -83, 14, -42, -59, -85, -86, -77, 100, 33, -31, -81, 43, 20,
        -18, 29, 83, -83, 43, -37, 61, -36, -89, -18, -40, 32, -1, 58, 8, 41, 52, 13, 55, -67, -38, 14, 43, 97, -70, -30,
        53, 86, -53, 83, -58, -2, -99, 82, -22, -2, 64, -54, 18, -64]

answer = []

for i_nums in range(0, len(nums)):
    if is_palindrome(nums[i_nums:len(nums)]):
        answer = nums[:i_nums]
        answer.reverse()
        break

print('Исходный список', nums)
print('Нужно чисел для палиндрома: ', len(answer))
print('Список нужных чисел: ', answer)

print(f"Запрос: {time.perf_counter() - start}")




********************************************************************************

# Часть 2. Модуль 3. Практическая работа. Задание 8. Симметричная последовательность
#
# Последовательность чисел называется симметричной, если она одинаково читается как слева направо,
# так и справа налево. Например, следующие последовательности являются симметричными:
#
# 1 2 3 4 5 4 3 2 1
# 1 2 1 2 2 1 2 1
#
# Пользователь вводит последовательность из N чисел.
# Напишите программу, которая определяет, какое минимальное количество и каких чисел
# нужно добавить в конец этой последовательности, чтобы она стала симметричной.
#
# Пример 1:
# Количество чисел: 5
# Число: 1
# Число: 2
# Число: 1
# Число: 2
# Число: 2
# Последовательность: [1, 2, 1, 2, 2]
# Нужно приписать чисел: 3
# Сами числа: [1, 2, 1]
#
# Пример 2:
# Количество чисел: 5
# Число: 1
# Число: 2
# Число: 3
# Число: 4
# Число: 5
# Последовательность: [1, 2, 3, 4, 5]
# Нужно приписать чисел: 4
# Сами числа: [4, 3, 2, 1]
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.
# Советы и рекомендации
# Убедитесь что ваш алгоритм работает с разными последовательностями, например с такими:
# [1, 2, 1] — в этом случае ничего добавлять не нужно.
# [1, 2, 3, 4, 3] — в этом случае надо добавить минимум, то есть числа 2 и 1.
# [::-1] - реверс, [:n-1] - срез до предпоследнего элемента

import time
import random

start = time.perf_counter()
def is_simm(some_list):
    reverse_list = some_list[::-1]    # реверс списка через срез
    if some_list == reverse_list:
        return True
    else:
        return False


def search_simm(some_list):
    if is_simm(some_list):
        print(f"Последовательность {some_list} уже является симметричной. Ничего не нужно добавлять.")
        exit()

    for i in range(len(some_list)):
        if is_simm(some_list[i:]):
            return i


def add_simm(some_list):
    i = search_simm(some_list)
    slice_list: list = some_list[:i]
    some_list.extend(reversed(slice_list))
    return some_list



if __name__ == '__main__':

    test_cases = [
       # [1, 2, 1, 2, 2],
       # [1, 2, 3, 4, 5],
       # [1, 2, 3, 4, 3],
       # [1, 2, -3, 4, 0, 1],
      #  [1, 2, -3, 4, 0, 0, 1, 1, 1],
      #  [1, 2, 3, 4, 3, 2],
        [-2, 45, -80, -89, 54, -61, 8, -41, -5, 1, 55, -93, 89, 24, -84, 98, -37, -21, 86, 97, 48, 43, 28, 93, 25, -65,
         67, -7, -19, 79, -95, 45, 83, -41, 64, -91, -45, -75, 48, 78, 33, 86, 34, -92, 52, -14, -80, -82, -12, -100,
         56, -52, 84, 21, -82, -23, 95, -60, 4, -5, -66, -77, -73, 51, -2, -2, -23, 23, -66, -50, -17, 70, 46, -17, -71,
         -57, -79, 77, -66, 24, -59, -83, 12, -1, -67, -21, -32, -61, -60, 57, -9, -91, 8, 95, -83, -37, -90, -62, -56,
         -28, 87, 42, 90, 6, 70, 99, 33, -77, -65, 11, 50, -55, -76, -37, -72, 27, 66, 86, -2, 71, 21, -55, -57, 82, 64,
         55, -72, 44, 77, 28, 76, 89, 62, -89, 75, 36, -25, -1, 71, -75, 73, -74, 94, -22, 86, -58, -19, -98, -82, -98,
         1, 64, -5, 62, 9, 74, -35, 28, 10, 59, -82, 31, 54, 47, -17, 34, 85, -71, 94, -43, -44, 73, 60, 42, -69, -4,
         54, 23, -37, -63, -18, -89, 99, 99, 14, 81, -18, -90, -17, 4, -40, 84, 70, 78, 63, 94, -86, -2, 82, -17, -45,
         84, -7, 96, 76, -33, -72, -67, 78, -72, 43, -59, 33, 49, 43, -5, 30, -23, -43, 44, -32, 22, -88, -87, -76, -77,
         -43, 57, 96, 87, -87, -4, 73, 79, 82, 17, 78, 31, 100, 34, 45, -89, -67, 73, 64, -76, 54, -15, -97, -19, -44,
         17, -41, 93, -52, 4, 5, 56, 70, -23, -18, 54, -5, 53, -56, -22, 98, 96, 24, 92, 33, 39, -87, 57, -74, 56, 11,
         -71, -74, -21, -25, -99, -84, 54, -66, -35, -36, -78, -4, 29, -3, -62, -20, -27, 87, 67, 13, -17, 82, 60, 88,
         -45, -34, 29, 48, 19, 48, -87, -97, -77, -37, -42, 57, 30, -84, 87, -59, 95, 50, -53, -68, -96, -37, 63, -2,
         -4, 21, -31, -83, -94, 22, -36, -98, -33, -19, 63, 21, 34, -29, 81, 79, 97, 41, 18, -3, -95, -90, 93, -57, -16,
         43, -31, 4, 44, 53, 92, 42, 53, 82, 98, -47, 36, 52, 87, -82, 77, 92, 100, 61, -90, 70, -67, 29, -9, 41, -39,
         29, 87, 66, 54, 37, 9, 2, -98, -63, -17, 14, 15, 85, -29, 92, -83, 92, -14, -76, 79, -94, 12, -67, -73, 92,
         -31, -11, -64, -5, 52, -94, -21, -76, 1, 63, 82, -48, -94, 57, -16, -26, 63, 11, -43, 58, -21, -40, -50, 77,
         -79, -4, 25, 26, -46, 65, 90, -27, 50, -28, -74, 43, 26, -56, -99, -52, 22, 57, 61, -50, 21, -40, 11, 62, 38,
         96, -85, 25, 34, 60, -58, -3, 32, 23, 60, -40, -36, -48, -33, 14, -1, 85, -53, -82, -30, -50, -100, 73, 4, 41,
         52, 35, -29, -81, -51, -66, 39, -55, 82, -50, -38, -91, -19, 90, 73, 9, 10, 15, 81, 6, 74, 59, 39, -45, -72,
         -54, 86, 79, -79, -91, -61, 25, -68, 98, -88, 27, -16, 48, 58, 93, -22, -38, -100, -96, -89, -21, -30, -78, 9,
         -84, 33, -46, 41, 30, 20, 12, -66, 30, -29, 40, 80, 29, 84, -57, -79, 2, -85, -25, 60, -45, -9, -83, 73, -48,
         48, -45, 96, 74, 91, -31, 1, -85, 83, 92, 26, 46, 11, 1, 8, -59, 74, 71, -42, -25, 5, -86, -100, -12, 63, 63,
         -21, 31, 50, 48, -94, 7, 16, -17, 66, -51, -87, 7, 89, -1, 46, 71, 17, 39, 17, 97, -77, 97, -90, -85, 29, -61,
         -54, -26, -85, 97, 65, 92, -49, 38, 30, 39, 49, -11, -74, -68, 6, 56, 89, -85, -94, -9, 68, -25, 11, 4, -100,
         74, -65, -88, 4, -35, -85, 51, 8, -98, 92, -62, -93, 69, 68, -3, -13, 3, 51, -59, 9, -72, -66, 44, -37, 72,
         -14, -84, -57, 79, -2, -91, -4, 90, -12, 30, 92, 28, -54, 47, -11, -28, 49, -55, 91, 61, 32, 22, -54, 69, -13,
         46, 65, 79, 76, 4, 71, 21, -89, -47, 28, -13, 6, -97, -7, 92, -27, -16, -55, 80, 60, -65, -83, -39, -60, -65,
         -45, 93, -25, 49, 62, 33, 35, 92, -38, -97, -86, -40, 52, 86, 0, -15, -86, -22, -47, -6, -43, -14, -30, 61, 23,
         91, 2, 45, 98, 34, -43, 16, -74, 37, -55, -91, -95, -21, 31, 67, -75, 89, 50, 7, 95, -28, 96, -34, 53, 55, -60,
         6, 69, 53, 70, -68, -78, 94, -96, 91, 72, -71, 10, -25, 45, 65, 96, 57, -90, 87, -2, -89, 3, -71, -10, 89, -71,
         71, 61, 33, -2, 93, 15, 51, -25, -9, 65, 16, -57, 82, -11, -81, -8, -38, 59, -51, -21, -29, 61, -71, 17, 14,
         54, 40, -84, -24, -4, -10, 66, -31, -20, -29, -52, 61, 52, -55, -75, 12, -74, -43, -37, -7, 51, -87, -61, 21,
         6, 44, 54, 25, -17, -43, 27, -9, -8, 63, 14, 1, 5, -100, 33, -18, -32, -29, -21, -38, -58, 90, 17, -43, -70,
         37, -47, 52, 47, 74, 84, 13, 47, -47, -16, 85, 63, 25, -93, 52, -20, -40, 31, 72, 88, -99, 79, 92, -23, -97,
         -52, 16, -41, -82, 16, 84, -6, 62, 83, -41, -70, 70, -71, -63, -44, 75, 7, 4, -98, -43, -38, -48, -81, 56, 88,
         91, 87, 72, -78, -56, -12, 88, -89, -56, 49, 48, 49, -94, 1, -60, -15, -52, -25, -33, 37, 86, -12, -62, 7, 76,
         -13, 28, 32, -56, -19, -66, -31, 2, -49, 75, -68, 78, -11, 99, 40, 3, -73, -71, 51, 93, 42, -89, 70, -31, 66,
         13, -98, 64, 57, 73, 33, 75, 52, -80, -77, 80, -73, -67, 58, 22, -23, 36, 94, -20, 64, -68, -27, -40, 49, -100,
         27, -75, -68, -19, 87, 45, -89, 72, 7, 14, 11, -37, 60, 37, -1, 44, 94, 53, -74, 28, -5, 75, 73, -33, 36, -47,
         -97, -70, -66, 68, 65, 55, 35, 24, -25, 96, -81, 51, -16, 49, -19, 30, -97, 88, 43, 60, -30, 10, 67, -37, -99,
         20, -32, -34, -84, 61, 34, -50, 18, 90, -68, 93, -90, 58, -65, 34, 84, -2, 55, -48, -11, -85, 87, -88, 85, -59,
         -63, 3, 65, -60, -48, -47, -3, 71, -30, 49, 4, 20, 81, -77, -2, -13, 67, 2, -1, 13, 25, -86, -76, 26, 11, 75,
         -68, -89, 86, 61, 65, 87, 95, 71, 51, 55, 11, 43, 64, -53, 58, -77, 36, -63, -14, -77, 18, 92, 41, -78, 18, 85,
         -24, -24, 66, -94, 40, 18, 27, -19, -57, 30, -74, 27, 88, 91, -4, -10, 10, 80, 40, 44, -10, 79, -100, 75, 64,
         69, 93, 77, 30, -23, 78, -81, 74, -46, -13, -58, -31, -87, -12, 20, -38, 14, -3, 79, 92, -42, -75, -80, -13,
         89, -72, 60, -3, 44, 27, -6, 40, 23, 33, 52, 10, -71, -2, -24, 72, -45, 15, -48, -30, 88, -59, 26, -85, -41,
         38, 21, -80, -9, 13, -86, -8, -75, -41, 86, 79, -91, -58, 54, 72, -73, 88, -8, -41, -16, 0, -80, 73, 64, 32,
         -51, 36, 53, -61, 82, 44, -28, -54, -55, -95, -59, -41, -72, -13, -70, 57, -39, -15, 47, 79, -12, -91, -57, 60,
         55, 17, -6, -61, 94, -80, -57, -58, 60, -79, -78, 84, 49, 37, 4, 65, -89, -87, 44, -41, -8, -37, -55, 13, 93,
         -90, 68, 6, -42, -33, 51, 8, -9, 83, -99, 66, -67, -27, -2, 60, -15, -65, 72, -77, -65, 48, 59, 81, 25, -60,
         91, -36, 3, 33, -45, -61, -28, 76, -45, -42, 34, 43, -45, 70, -3, -76, 54, -41, 6, -71, -87, -9, -31, 65, 67,
         -24, 89, 37, -20, -8, -25, -98, 45, -69, 46, 74, 94, -59, -24, -51, -91, -66, 87, 52, 58, -47, 75, -99, -11,
         -13, -87, -28, -100, 54, -66, -27, -79, 33, 84, 38, 90, -9, -46, 8, -63, -79, -71, 71, -17, 0, 94, 54, -43, 81,
         -64, -30, 29, 70, -90, -74, 73, 74, -20, 59, 57, -71, -58, -88, -87, 7, -19, -46, -54, -19, -66, 69, 16, 45,
         -27, 84, -60, -70, -32, 15, -15, -62, -38, 57, -76, -72, -88, 37, -82, 91, 59, 22, -70, 82, 11, -21, 18, -79,
         53, 79, 74, 67, -89, 100, -37, 35, -6, -45, 60, -21, -74, -20, 73, -69, 39, -56, -85, 49, -31, -23, 19, 27, 74,
         75, 74, 62, 95, -10, 8, -43, 45, -53, 90, 91, -60, 33, -56, -4, 98, -6, -55, 31, 0, -95, -1, -90, 13, 30, 92,
         86, -4, 89, -19, -31, 64, -23, 84, 29, 5, -48, -6, 48, 62, 57, -9, 31, -72, 17, 18, 9, -35, 18, 45, -63, 41,
         -88, -14, -43, -3, 74, 39, -97, -9, 66, -2, -83, -8, 60, 93, -13, -17, -31, 50, 77, 69, -32, 62, -26, -34, 99,
         -50, -30, 23, -38, -75, -10, -21, 34, 91, -75, 8, 28, 93, 93, -15, 64, 28, 5, -57, -82, -84, 32, -39, -83, -79,
         68, -18, -88, -78, -84, 74, -75, -31, -95, -23, -39, -16, -14, 57, -4, -97, -54, 36, 43, -19, 77, -85, -6, -92,
         -32, 93, -18, 11, 44, -72, 16, 100, -89, 8, 7, -76, 88, 78, 41, -93, -19, 49, -28, -25, 53, -4, 37, 39, 63, 85,
         22, -99, -56, -38, -74, -18, -76, -92, -58, -68, 17, -60, 33, 42, -35, 50, 41, -13, -25, 25, 1, 93, -1, 33,
         -34, -74, 25, -8, 43, -14, 69, -69, 19, -89, 30, -62, -96, 12, 66, 92, -12, -83, 26, -44, 48, 44, 43, 97, -38,
         -28, 58, 31, 67, 20, -28, -88, 87, 12, -90, -9, -48, -78, 14, -83, 70, 100, -87, -4, -18, -2, 41, -8, -69, 59,
         73, 45, 40, 99, -48, -15, 70, -53, 98, -40, -99, -37, -52, -44, -44, 88, 71, 57, -69, -25, 39, 73, 36, -90,
         -42, -49, -89, 64, -74, 79, -54, -43, -8, -44, -18, -66, 8, 9, 89, -100, -90, -30, 75, -71, 9, 26, -80, 64, 18,
         -10, 37, 69, 24, -25, -45, -40, -12, 65, 11, 73, -8, -74, -57, -96, 68, 86, -4, -89, -42, 5, -22, -38, 42, 14,
         -59, 9, -32, 72, -56, 48, 97, -76, 46, 7, 38, -79, 65, -55, 4, -16, 55, 69, 24, 81, -76, 91, 67, -42, 53, -47,
         0, 31, 21, 79, -63, -97, 1, -58, 68, -32, 95, 73, -36, -51, 67, -73, -88, 86, 15, 55, -38, -78, 95, 8, -62, 18,
         93, -27, 15, -58, 85, 44, 32, 12, -8, -24, 52, -56, -54, -8, 88, 53, 17, 37, 98, 28, 9, 40, 28, -97, 46, -87,
         13, 63, -86, -12, 17, 10, -60, -85, -95, 52, 17, -92, 58, -35, 8, 85, 63, -90, -23, -23, -89, 78, -66, -49,
         -60, 64, -26, 37, 60, -51, 16, 75, -97, 47, -64, -63, -90, -35, -15, -90, 75, -49, 64, 48, -25, 21, -24, -49,
         -44, 30, -1, 76, -75, 16, 61, -100, 84, -24, 88, -20, 26, 38, -68, 58, -63, 86, 0, -85, -26, -51, -98, 5, -60,
         -55, 85, -7, 58, -73, 54, 17, 89, 13, 70, 7, 72, 4, -89, -2, 9, -77, -82, -15, 82, 97, 100, -39, 45, 95, -13,
         1, -28, 4, -50, 7, -52, -93, 84, 70, 34, 28, 97, 1, -31, -34, -76, 9, 74, -5, 77, 19, 51, -31, -2, 12, -62,
         -25, 47, -62, -69, 76, 91, -95, 15, -3, 41, -21, 90, 64, 28, -12, -34, 56, -91, -59, 76, 99, -98, 81, 58, -54,
         30, 27, -20, 77, -87, 0, 88, 0, -80, -8, 15, 55, 81, 90, 47, -92, 56, 92, -22, -79, -99, -48, -10, -19, -73,
         29, 44, 27, -27, 32, -43, 17, -1, 100, 31, 80, 29, 5, -67, -90, 100, -98, -54, 48, 22, -100, 72, 11, 55, -81,
         -3, 12, -61, 72, 18, -71, 52, -21, -43, 91, 83, -89, 56, 34, 89, -40, -56, 15, -91, -79, 18, -13, 22, 62, 49,
         39, 45, -96, 9, -37, -1, -42, -98, -18, -2, 99, 21, 91, -1, -49, 26, 53, -10, 48, 52, -2, -16, 23, 52, -15, 34,
         -15, -46, 49, 83, -8, 13, -47, -20, 9, -99, -67, -84, 50, -36, 42, 84, -75, 11, 21, -3, 16, -97, -16, -55, 64,
         14, 72, -80, -32, -52, -72, 49, -97, 55, -41, -80, -92, -38, 50, -67, 76, 64, -29, -94, -88, 5, 73, 15, -17,
         53, -26, -49, 75, 69, 75, -23, 67, 40, -41, -17, 22, 51, -5, 60, 92, -33, 26, -35, -8, 61, 4, 30, -26, -8, 43,
         -30, -31, -51, 38, -60, 94, -76, -98, 67, -23, -18, 54, 40, 27, -87, -41, 17, 46, -63, -96, -87, -41, 91, 27,
         80, -32, -56, 14, 38, -49, 39, -97, 76, 91, -43, 93, -54, -55, -52, 40, -84, -89, 76, -84, -57, -30, 23, 70,
         -3, 49, -83, 1, -32, -45, 51, 72, 25, 87, 73, -8, 65, 43, 52, -5, -14, -81, -6, 34, 19, -87, -59, -83, 92, -85,
         51, -66, 75, 18, 43, -2, 44, 92, 48, -90, -27, 61, -65, 31, 72, -77, -65, 10, 38, -63, -50, 31, -10, 85, -83,
         31, -64, 75, 27, -96, 68, -81, -78, -91, -68, -91, 93, -85, 30, -13, 13, 66, 88, -74, -98, 16, 65, 62, -12, 51,
         71, 43, -46, 2, 79, 99, 0, 65, -86, -56, -93, 64, -21, -56, 37, -46, 72, -18, -87, 63, -93, 77, 80, 56, -35,
         13, 65, -38, -31, -71, -13, 93, 55, 14, -76, -28, -76, 57, -1, -50, -43, 59, -10, 99, 39, 24, -54, -59, -79,
         -36, 24, 75, 19, 68, -40, 35, -68, 96, -53, -94, -22, -96, 21, 98, 74, 4, 100, -94, 21, -97, 12, 83, -67, -7,
         84, -66, 99, 5, -9, -32, -26, 49, 33, 54, -70, -50, -61, -31, 28, -82, 34, -92, -58, -4, -92, 37, 54, -35, -61,
         -39, -84, 78, -91, -40, 82, -21, -12, 86, 60, 51, 14, -74, -66, -44, -57, -56, 72, -59, -99, -25, -23, 75, -88,
         -48, -32, -73, -47, 67, 81, 96, -49, -47, 31, -78, 56, 23, 13, 52, 77, 54, -44, -5, 1, -19, 14, 55, -86, 86,
         -89, 43, 97, 30, -91, 8, 89, -100, 95, -56, -86, -68, 6, 45, -57, 42, 99, 55, -22, -88, 100, 81, 78, 11, 59,
         27, 63, 71, -99, 29, -36, -13, 70, 94, 35, -11, -42, 20, 30, -70, 66, 2, -74, -29, 80, -3, -39, 85, -80, -76,
         -95, -67, 11, -14, -40, 91, -46, 9, -84, 59, -79, 90, -29, -43, -76, 11, 87, 25, -95, -48, 89, 50, -25, -24,
         99, -75, -100, 85, -92, 25, -24, -35, -17, 88, -91, -12, -22, -67, 98, 92, 100, 30, -30, 12, 75, -95, 48, 22,
         43, -4, -91, 23, -3, 8, 67, 20, 78, -44, -32, -70, -86, -15, 67, -65, 2, 82, 73, 54, 8, 72, 43, 63, 18, -77,
         33, -96, -36, 46, -29, -85, 32, -43, -11, -99, -51, 64, 50, 73, -23, 74, -63, -95, 66, -17, -72, -73, 10, -57,
         -89, 54, -56, -24, 86, -34, -9, -73, -6, -46, -72, 55, -79, 4, 5, -59, 98, -27, -32, 78, 24, -94, 82, -31, -49,
         -20, 11, 72, -59, -73, 32, -58, -37, -34, 41, 56, 92, -53, -74, 62, -92, 81, 95, 99, -83, 14, -42, -59, -85,
         -86, -77, 100, 33, -31, -81, 43, 20, -18, 29, 83, -83, 43, -37, 61, -36, -89, -18, -40, 32, -1, 58, 8, 41, 52,
         13, 55, -67, -38, 14, 43, 97, -70, -30, 53, 86, -53, 83, -58, -2, -99, 82, -22, -2, 64, -54, 18, -64]
       # [1, 2, 1]
    ]

    for some_list in test_cases:
        print(f"Исходная     последовательность : {some_list}")
        n = len(some_list)
        result = add_simm(some_list)
        print(f"Симметричная последовательность : {some_list}\n"
              f"Нужно прописать чисел           : {len(result) - n}\n"
              f"Сами числа                      : {result[n:]}\n")

print(f"Запрос: {time.perf_counter() - start}")


********************************************************************************

# Часть 2. Модуль 3. Видео 2. Задача 1. Зоопарк
#
# В маленьком зоопарке каждое животное сидит в отдельной клетке,
# всего этих животных четверо: лев, кенгуру, слон и обезьяна.
# В базе данных они хранятся в виде вот такого списка:
#
# zoo = ['lion', 'kangaroo', 'elephant', 'monkey']
#
# Сегодня в зоопарк завезли медведя (bear) и посадили его между львом и кенгуру. В итоге животных стало пять.
# А через неделю слона перевезли в другое место и в списке снова стало четверо животных.
#
# Реализуйте эти действия в коде программы и выведите в консоль итоговый список животных, а также покажите,
# в какой клетке сидят лев и обезьяна. Для этого используйте методы списков.
#
# Результат работы программы:
#
# Зоопарк: ['lion', 'bear', 'kangaroo', 'monkey']
# Лев сидит в клетке номер 1
# Обезьяна сидит в клетке номер 4

zoo = ['lion', 'kangaroo', 'elephant', 'monkey']
zoo.insert(1, 'bear')
zoo.remove('elephant')
print("Зоопарк:", zoo)

print("Лев сидит в клетке номер", zoo.index('lion') + 1)
print("Обезьяна сидит в клетке номер", zoo.index('monkey') + 1)

********************************************************************************

# Часть 2. Модуль 3. Видео 2. Задача 2. Сокращения
#
# Зарплаты сотрудников хранятся в списке из N зарплат.
# Зарплаты уволенных сотрудников обозначаются в списке числом 0.
#
# Напишите программу, которая запрашивает у пользователя количество сотрудников и их зарплаты,
# затем удаляет все элементы списка со значением 0 и выводит в консоль, сколько сотрудников осталось,
# а также их зарплаты. Дополнительный список использовать нельзя.
#
# Пример:
# Кол-во сотрудников: 7
# Зарплата 1 сотрудника: 10000
# Зарплата 2 сотрудника: 25000
# Зарплата 3 сотрудника: 0
# Зарплата 4 сотрудника: 50000
# Зарплата 5 сотрудника: 60000
# Зарплата 6 сотрудника: 0
# Зарплата 7 сотрудника: 17000
# Осталось сотрудников: 5
# Зарплаты: [10000, 25000, 50000, 60000, 17000]
# Дополнительно: выведите на экран максимальную и минимальную зарплату оставшихся сотрудников.
#
# Для этого используйте функции max и min. Да, те самые, которыми нельзя называть переменные. В скобках функций просто укажите список.
#
# Пример:
# Максимальная зп: 60000
# Минимальная зп: 10000



def var_1(): # №1 Можно изначально не добавлять нулевые значения в список
    number_of_workers = int(input("Кол-во сотрудников: "))
    wages_of_workers = []
    for i in range(number_of_workers):
        wage = int(input(f"Зарплата {i + 1} сотрудника: "))
        if wage > 0:
            wages_of_workers.append(wage)

    print("Осталось сотрудников:", len(wages_of_workers))
    print("Зарплаты:", wages_of_workers)

def var_2(): # №2 Можно сперва собрать все зарплаты, затем "удалить" их, собрав подходящие элементы в новый список
    number_of_workers = int(input("Кол-во сотрудников: "))
    wages_of_workers = []
    for i in range(number_of_workers):
        wage = int(input(f"Зарплата {i + 1} сотрудника: "))
        wages_of_workers.append(wage)

    new_workers = []
    for worker in wages_of_workers:
        if worker > 0:
            new_workers.append(worker)

    print("Осталось сотрудников:", len(wages_of_workers))
    print("Зарплаты:", wages_of_workers)

def var_3(): # №3 Можно и напрямую удалять нулевые элементы, но делать это надо осторожно
    number_of_workers = int(input("Кол-во сотрудников: "))
    wages_of_workers = []
    for i in range(number_of_workers):
        wage = int(input(f"Зарплата {i + 1} сотрудника: "))
        wages_of_workers.append(wage)

    index = 0
    while index < len(wages_of_workers):
        if wages_of_workers[index] == 0:
            wages_of_workers.pop(index)
        else:
            index += 1  # увеличивать индекс надо только без удаления
            # это нужно чтобы из-за сдвига не пропустить следующий за удаленным элемент списка
    print("Осталось сотрудников:", len(wages_of_workers))
    print("Зарплаты:", wages_of_workers)

    print("Максимальная зп:", max(wages_of_workers))
    print("Минимальная зп:", min(wages_of_workers))


var_1()




********************************************************************************

# Часть 2. Модуль 3. Видео 2. Задача 3. Кино
#
# Cделать так, чтобы пользователи после регистрации могли создать собственный рейтинг
# фильмов из тех, которые есть на сайте. Вот сам список фильмов (конечно же, можете брать свои):
#
# films = [
#     'Крепкий орешек', 'Назад в будущее', 'Таксист',
#     'Леон', 'Богемская рапсодия', 'Город грехов',
#     'Мементо', 'Отступники', 'Деревня',
#     'Проклятый остров', 'Начало', 'Матрица'
# ]
#
# Напишите программу, которая позволяет добавлять в свой рейтинг фильмы, удалять их оттуда,
# а также вставлять на нужное пользователю место. Обеспечьте контроль ввода и сделайте так,
# чтобы в список нельзя было добавить один и тот же фильм несколько раз.
#
# Пример:
# Ваш текущий топ фильмов: []
# Название фильма: Леон
# Команды: добавить, вставить, удалить
# Введите команду: добавить
# Ваш текущий топ фильмов: [‘Леон’]
# Название фильма: Леон
# Команды: добавить, вставить, удалить
# Введите команду: добавить
# Этот фильм уже есть в вашем списке.
# Ваш текущий топ фильмов: [‘Леон’]
# Название фильма: Матрица
# Команды: добавить, вставить, удалить
# Введите команду: добавить
# Ваш текущий топ фильмов: [‘Леон’, ‘Матрица’]
# Название фильма: Леон
# Команды: добавить, вставить, удалить
# Введите команду: удалить
# Ваш текущий топ фильмов: [‘Матрица’]
# Название фильма: …..

films = [
    'Крепкий орешек', 'Назад в будущее', 'Таксист',
    'Леон', 'Богемская рапсодия', 'Город грехов',
    'Мементо', 'Отступники', 'Деревня',
    'Проклятый остров', 'Начало', 'Матрица'
]

n = int(input("Сколько фильмов выбрать? "))
your_films = []
for i in range(n):
    print("Ваш текущий топ фильмов:", your_films)
    film_name = input("Имя фильма: ")
    print("Команды: добавить, вставить, удалить")
    command = input("Введите команду: ")
    if film_name not in your_films:
        if command == "добавить":
            your_films.append(film_name)
        elif command == "вставить":
            insert_index = int(input("Введите индекс для вставки "))
            insert_index %= len(your_films)  # ограничим индекс списка, чтобы он не вылезал за границу списка
            your_films.insert(insert_index, film_name)
    else:
        if command == "удалить":
            your_films.remove(film_name)
        elif command == "добавить" or command == "вставить":
            print("Этот фильм уже есть в вашем списке.")

print("Ваш текущий топ фильмов:", your_films)


********************************************************************************

# Часть 2. Модуль 3. Видео 3. Задача 1. Задачи компаний
#
# Одна IT-компания решила расшириться и взяла под своё крыло ещё три таких же, но поменьше.
# Конечно же, все выполненные и невыполненные задачи этих компаний перетекли в основную компанию.
#
# Даны четыре списка компаний, в которых для каждой задачи написано, выполнена (1) она или нет (0):
# main = [1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1]
# first_company = [0, 0, 0]
# second_company = [1, 0, 0, 1, 1]
# third_company = [1, 1, 1, 0, 1]
#
# Напишите программу, которая расширяет список main элементами остальных списков, выведите итоговый список,
# а также выведите количество невыполненных задач.
#
# Результат работы программы:
#
# Общий список задач: [1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1]
# Кол-во невыполненных задач: 10


main = [1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1]
first_company = [0, 0, 0]
second_company = [1, 0, 0, 1, 1]
third_company = [1, 1, 1, 0, 1]

main.extend(first_company)
main.extend(second_company)
main.extend(third_company)

# Вариант со сложением списков:
# main += first_company + second_company + third_company

print("Общий список задач:", main)
print("Кол-во невыполненных задач:", main.count(0))

********************************************************************************

# Часть 2. Модуль 3. Видео 3. Задача 2. Вредоносное ПО
#
# Пользователь вводит две строки. В каждой из них есть какое-то количество специальных символов ! и ?.
# Напишите программу, которая считает количество этих символов отдельно в первой строке и отдельно во второй.
# Если в первой строке их больше, чем во второй, то на экран выводится первая строчка, объединённая со второй,
# а иначе — вторая с первой. При равном количестве символов в строках выводится «Ой».
#
# Пример 1:
# Первое сообщение: Привет!
# Второе сообщение: Как дела? Что делаешь?
# Третье сообщение: Как дела? Что делаешь? Привет!
# Пример 2:
# Первое сообщение: Хм!!
# Второе сообщение: ?
# Третье сообщение: Хм!!?

first_word = input("Первое сообщение: ")
second_word = input("Первое сообщение: ")
first_count = first_word.count("!") + first_word.count("?")
second_count = second_word.count("!") + second_word.count("?")
if first_count < second_count:
    first_word, second_word = second_word, first_word  # пусть первым словом будет то, в котором больше знаков

print(first_word + second_word)

********************************************************************************

# Часть 2. Модуль 3. Видео 3.Задача 3. Пакеты
#
# При работе с сервером мы кодируем сообщение и отправляем его в виде пакетов информации. Их количество равно N.
# Допустим, каждый пакет содержит четыре числа, каждое из которых равно нулю или единице. Эти числа называются битами.
# Иногда в кодировке сообщения встречаются ошибки, и в пакете эта ошибка обозначается числом -1.
# Если таких ошибок не больше одной, то этот пакет мы целиком добавляем в список для декодирования, а иначе отбрасываем.
#
# Напишите программу, которая будет обрабатывать полученные пакеты и выведет на экран итоговое сообщение для декодирования,
# а также количество ошибок в нём и количество необработанных пакетов.
#
# Пример:
# Кол-во пакетов: 3
# Пакет номер 1
# 1 бит: 1
# 2 бит: 0
# 3 бит: -1
# 4 бит: 1
#
# Пакет номер 2
# 1 бит: -1
# 2 бит: -1
# 3 бит: 1
# 4 бит: 1
# Много ошибок в пакете.
#
# Пакет номер 3
# 1 бит: 0
# 2 бит: 1
# 3 бит: 1
# 4 бит: 1
#
# Полученное сообщение: [1, 0, -1, 1, 0, 1, 1, 1]
# Кол-во ошибок в сообщении: 1
# Кол-во потерянных пакетов: 1

def var_1():
    n = int(input("Кол-во пакетов: "))
    decoder = []
    lost_pack_count = 0

    for i in range(n):
        pack_list = []
        print(f"Пакет № {i + 1}:")
        for j in range(4):
            pack_el = int(input(f"{j + 1}-й бит: "))
            pack_list.append(pack_el)
        if pack_list.count(-1) > 1:
            print(f"to much error: {pack_list.count(-1)}")
            lost_pack_count += 1
        else:
            decoder.extend(pack_list)

    print(f"Итоговое сообщение: {decoder}\n"
          f"Кол-во ошибок: {decoder.count(-1)}\n"
          f"Кол-во необработанных пакетов: {lost_pack_count}")


def var_2():
    number_of_msgs = int(input("Количество пакетов: "))
    result_msg = []
    lost_packages = 0

    for _ in range(number_of_msgs):
        buffer = []
        errors_in_package = 0
        for i in range(1, 5):
            bit = int(input(f"{i} бит: "))
            buffer.append(bit)
            if bit < 0:
                errors_in_package += 1
        if errors_in_package <= 1:
            result_msg.extend(buffer)
        else:
            lost_packages += 1

    print("Полученное сообщение:", result_msg)
    print("Кол-во ошибок в сообщении:", result_msg.count(-1))
    print("Кол-во потерянных пакетов:", lost_packages)


var_2()

********************************************************************************

# Часть 2. Модуль 3. Видео 4. Задача 1. Матрица
#
# Дан вот такой список со списками:
# matrix = [[1, 2 ,3], [4, 5, 6], [7, 8, 9]]
# Реализуйте программу, которая выводит элементы этого списка в виде привычной нам матрицы.
# Результат работы программы:
#
# 1 2 3
#
# 4 5 6
#
# 7 8 9

N = 9
matrix = []
num = 1

for _ in range(N//3):
    matrix.append(list(range(num, num+3)))
    num +=3

print(f"Двумерный массив:\n{matrix}\n")

for i_matr in matrix:
    print(i_matr)
print()

for i_team in matrix:
    for i_man in i_team:
        print(i_man, end=' ')
    print('\n')

********************************************************************************

# Часть 2. Модуль 3. Видео 4. Задача 2. Олимпиада
#
# В олимпиаде по программированию участвует N человек.
# В списке участников они обозначаются под номерами 1, 2, 3, 4 и так далее до N.
# Эти участники поделены на команды по K человек.
#
# Напишите программу, которая принимает на вход количество участников и количество человек в каждой команде,
# затем генерирует список таких команд и выводит его на экран.
#
# Обеспечьте контроль ввода: в каждой команде должно быть ровно по K человек.
#
# Пример 1:
# Кол-во участников: 12
# Кол-во человек в команде: 4
# Общий список команд: [[1, 2 ,3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
#
# Пример 2:
# Кол-во участников: 12
# Кол-во человек в команде: 5
# 12 участников невозможно поделить на команды по 5 человек!

human_count = int(input("Кол-во участников: "))
team_count = int(input("Кол-во человек в команде: "))
if human_count % team_count == 0:
    teams = []
    teammate_number = 0
    for _ in range(human_count // team_count):
        new_team = []
        for _ in range(team_count):
            teammate_number += 1
            new_team.append(teammate_number)
        teams.append(new_team)
    print(teams)
else:
    print(human_count, "невозможно поделить на команды по", team_count, "человек!")


********************************************************************************

# Часть 2. Модуль 3. Видео 4. Задача 3. Лавка
#
# В небольшой фруктовой лавке у каждого фрукта есть название и цена. Эта информация хранится в одном большом списке, вот так:
#
# goods = [["яблоки", 50], ["апельсины", 190], ["груши", 100], ["нектарины", 200], ["бананы", 77]]
#
# Недавно в лавку привезли новый fruit_name по цене price, а после этого случилось ужасное: повысили налоги.
# А значит, повысились и цены на фрукты, на целых 8%!
#
# Реализуйте код, который добавляет в список goods ещё один список с новым фруктом и ценой (это запрашивается у пользователя),
# а затем увеличивает цены всех фруктов на 8%.
#
# Пример:
# Текущий ассортимент:
# [["яблоки", 50], ["апельсины", 190], ["груши", 100], ["нектарины", 200], ["бананы", 77]]
# Новый фрукт: абрикосы
# Цена: 150
# Новый ассортимент:
# [["яблоки", 50], ["апельсины", 190], ["груши", 100], ["нектарины", 200], ["бананы", 77], ["абрикосы", 150]]
# Новый ассортимент с увел. ценой:
# [['яблоки', 54.0], ['апельсины', 205.2], ['груши', 108.0], ['нектарины', 216.0], ['бананы', 83.16], ['абрикосы', 162.0]]

goods = [["яблоки", 50], ["апельсины", 190], ["груши", 100], ["нектарины", 200], ["бананы", 77]]

new_fruit_name = input("Новый фрукт: ")
new_fruit_price = int(input("Цена: "))

goods.append([new_fruit_name, new_fruit_price])

print("Новый ассортимент:", goods)

for good in goods:
    good[1] = round(good[1] * 1.08, 2)

print("Новый ассортимент с увел. ценой:", goods)


********************************************************************************

words_list =[['', 0], ['', 0], ['', 0]]

for i_num in range(3):
    print(f"Введите {i_num+1}-е слово: ", end=' ')
    word = input()
    words_list[i_num][0] = word

text = input('Слово из текста: ')
while text != 'end':
    for index in range(3):
        if words_list[index][0] == text:
            words_list[index][1] += 1
    text = input('Слово из текста: ')

print('\nПодсчет слов в тексте:')
for index in range(3):
    print(f"{words_list[index][0]} : {words_list[index]}")

********************************************************************************

# Часть 2. Модуль 4. Практическая работа. Задание 1. Гласные буквы
#
# Напишите программу, которая запрашивает у пользователя текст и генерирует список гласных букв
# этого материала (сама строка вводится на русском языке). Выведите в консоль сам список и его длину.
#
# Пример:
# Введите текст: Нужно отнести кольцо в Мордор!
# Список гласных букв: ['у', 'о', 'о', 'е', 'и', 'о', 'о', 'о', 'о']
# Длина списка: 9
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

a_str = 'АаЕеЁёИиОоУуЫыЭэЮюЯя'
text = input('Введите текст: ')

list_a = [i_text for i_text in text if i_text in a_str]

print(f"Список гласных букв: {list_a}\n"
      f"Длина списка: {len(list_a)}")



********************************************************************************

# Часть 2. Модуль 4. Практическая работа. Задание 2. Генерация
#
# Пользователь вводит целое число N. Вам необходимо написать программу, которая генерирует список
# из чисел от 0 до N (не включая N). Например, если N — это 5, то нужно работать со списком 0, 1, 2, 3, 4.
#
# Также есть дополнительное условие. При заполнении списка нужно выполнить одно из двух действий с каждым числом:
#
# если индекс числа чётный (или 0), то вместо числа необходимо взять 1;
# если индекс числа нечётный, то вместо числа необходимо взять остаток от деления этого числа на 5 (число % 5).
# Таким образом нужен следующий алгоритм:
#
# цикл по числам
#     если текущий индекс чётный
#         то в список добавляется 1
#     если текущий индекс нечётный
#         то в список добавляется (число % 5)
#
# Алгоритм нужно реализовать при помощи генератора списка (в одну строку).
#
# Пример:
# Введите длину списка: 10
# Результат: [1, 1, 1, 3, 1, 0, 1, 2, 1, 4]
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует указанному в задаче.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

import random

N = int(input('Введите целое число: '))
some_list = [(random.randint(0, N-1) % 5 if i % 2 != 0 else 1) for i in range(N)]
print(some_list)

********************************************************************************

# Часть 2. Модуль 4. Практическая работа. Задание 3. Случайные соревнования
#
# Есть два списка по 20 элементов в каждом. В них хранятся вещественные числа с двумя знаками после точки, например 4.03.
# Член одной команды соревнуется с участником другой команды под таким же номером.
# То есть первый соревнуется с первым, второй — со вторым и так далее.
# Напишите программу, которая генерирует два списка участников (по 20 элементов) из случайных
# вещественных чисел (от 5 до 10). Для этого найдите подходящую функцию из модуля random.
# Затем сгенерируйте третий список, в котором окажутся только победители из каждой пары.
#
# Пример:
# Первая команда: [7.86, 6.76, 9.97, 9.08, 5.45, 6.9, 8.65, 5.17, 8.17, 5.06, 7.56, 7.1, 7.18, 8.25, 5.53, 7.95, 8.91, 7.11, 8.29, 9.52]
# Вторая команда: [7.13, 5.7, 8.89, 5.36, 5.62, 9.46, 5.82, 8.67, 8.41, 7.0, 5.31, 7.8, 9.93, 7.76, 7.4, 8.26, 7.94, 5.71, 7.89, 7.77]
# Победители тура: [7.86, 6.76, 9.97, 9.08, 5.62, 9.46, 8.65, 8.67, 8.41, 7.0, 7.56, 7.8, 9.93, 8.25, 7.4, 8.26, 8.91, 7.11, 8.29, 9.52]
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

import random

list_1 = [round(random.uniform(5, 10), 2) for _ in range(21)]
list_2 = [round(random.uniform(5, 10), 2) for _ in range(21)]

result = [(list_1[i] if list_1[i] > list_2[i] or list_1[i] == list_2[i] else list_2[i]) for i in range(21)]

print(f"{list_1}\n{list_2}\n{result}")

********************************************************************************

# Часть 2. Модуль 4. Практическая работа. Задание 4. Тренировка со срезами
#
# Дана строка, в которой хранятся первые семь букв английского алфавита.
# alphabet = 'abcdefg'
# Напишите программу, которая выводит на экран десять таких результатов:
# ●	копию строки;
# ●	элементы строки в обратном порядке;
# ●	каждый второй элемент строки (включая самый первый);
# ●	каждый второй элемент строки после первого;
# ●	все элементы до второго;
# ●	все элементы, начиная с конца до предпоследнего;
# ●	все элементы в диапазоне индексов от 3 до 4 (не включая 4);
# ●	последние три элемента строки;
# ●	все элементы в диапазоне индексов от 3 до 4;
# ●	то же, что и в предыдущем пункте, но в обратном порядке.
# Для получения и вывода результатов используйте только команду print и срезы.
#
# Результаты работы программы:
# 1: abcdefg
# 2: gfedcba
# 3: aceg
# 4: bdf
#
# 5: a
# 6: g
# 7: d
# 8: efg
# 9: de
# 10: ed
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Для получения результата используются только print и срезы переменной alphabet.

alphabet = 'abcdefg'
print(f"Копия строки: {alphabet[::]}\n"
      f"Элементы строки в обратном порядке: {alphabet[::-1]}\n"
      f"Каждый второй элемент строки (включая самый первый): {alphabet[::2]}\n"
      f"Каждый второй элемент строки после первого: {alphabet[2::2]}\n"
      f"Все элементы до второго: {alphabet[:2]}\n"
      f"Все элементы, начиная с конца до предпоследнего: {alphabet[1::][::-1]}\n"
      f"Все элементы в диапазоне индексов от 3 до 4 (не включая 4): {alphabet[3:4]}\n"
      f"Последние три элемента строки: {alphabet[-3:]}\n"
      f"Все элементы в диапазоне индексов от 3 до 4: {alphabet[3:5]}\n"
      f"Все элементы в диапазоне индексов от 3 до 4, но в обратном порядке: {alphabet[3:5][::-1]}\n")

********************************************************************************

# Часть 2. Модуль 4. Практическая работа. Задание 5. Разворот
#
# На вход в программу подаётся строка, в которой буква h встречается как минимум два раза.
# Реализуйте код, который разворачивает последовательность символов, заключённую между
# первым и последним появлением буквы h, в противоположном порядке.
#
# Пример 1:
# Введите строку: hqwehrty
# Развёрнутая последовательность между первым и последним h: ewq.
#
# Пример 2:
# Введите строку: hh
# Развёрнутая последовательность между первым и последним h:
#
# Пример 3:
# Введите строку: hhqwerh
# Развёрнутая последовательность между первым и последним h: rewqh.
#
# Советы и рекомендации
# Индекс нужного элемента можно искать как вручную, так и при помощи готовых методов списка.
# У метода index есть «брат» — метод rindex. В отличие от первого второй метод начинает поиск с правой стороны (с конца).
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.
#
# Пример использования функции extend():
# a = ['car', 'top', 'lot']
# b = ['dog', 'cat']
# a.extend(b)
# print(a)
#
# Пример использования функции shuffle()
# import random
# lst = list(range(1, 50, 6))
# random.shuffle(lst)
# print(lst)
#
# Примеры получения индекса последнего совпадения символа/подстроки:
# x = 'раз два три раз два три раз'
# x.rindex('раз')
# >>> 24
# x.rindex('раз', 0, 23)
# >>> 12

import random

population = list('abcdefghijklmnoprstuvwxyz')
rand_population = random.sample(population, random.randint(0, 20))
rand_population.extend('hh')
random.shuffle(rand_population)
rand_population_str = "".join(rand_population)
print(rand_population_str)
a = rand_population_str.index('h')
b = rand_population_str.rindex('h')
print("".join(list(reversed(rand_population_str[a+1:b]))))


********************************************************************************

# Часть 2. Модуль 4. Практическая работа. Задание 6. Двумерный список
#
# Часто в программировании приходится писать код исходя из результата,
# который требует заказчик. В этот раз ему нужно получить двумерный список:
#
# [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
#
# Напишите программу, которая генерирует такой список и выводит его на экран. Используйте только list comprehensions.
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру: двумерный список с числами без текста.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

matrix = [[i + 3*j for i in range(1, 4)] for j in range(0, 4)]
print(matrix)


********************************************************************************

# Часть 2. Модуль 4. Практическая работа. Задание 7. Список списков
#
# Дан многомерный список:
# nice_list = [[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[10, 11, 12], [13, 14, 15], [16, 17, 18]]]
# Напишите код, который раскрывает все вложенные списки, то есть оставляет лишь внешний список.
# Для решения используйте только list comprehensions.
# Ответ: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует ответу.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

nice_list = [[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[10, 11, 12], [13, 14, 15], [16, 17, 18]]]

# мое решение
result = [z for x in range(len(nice_list)) for y in range(len(nice_list[x])) for z in nice_list[x][y]]
print(result)

# решение skillbox
# output = [digit for each_list in nice_list for each_list_2 in each_list for digit in each_list_2]
# print(output)




********************************************************************************

# Часть 2. Модуль 4. Практическая работа. Задание 8. Шифр Цезаря
#
# Юлий Цезарь использовал свой способ шифрования текста. Каждая буква заменялась
# на следующую по алфавиту через K позиций по кругу. Если взять русский алфавит и K,
# равное 3, то в слове, которое мы хотим зашифровать, буква А станет буквой Г, Б станет Д и так далее.
#
# Пользователь вводит сообщение и значение сдвига. Напишите программу, которая изменит фразу при помощи шифра Цезаря.
#
# Пример:
# Введите сообщение: это питон.
# Введите сдвиг: 3
# Зашифрованное сообщение: ахс тлхср.
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Алгоритм шифрования вынесен в отдельную функцию.
# Переменные и функции имеют значимые имена, не только a, b, c, d.
#
# Чтобы индекс не вышел за пределы списка, нужно ограничить его рост.
# Для этого подходит операция %: (индекс + число) % длина списка.
# Так индекс не будет равен длине списка или не превысит её, а значит не выйдет за пределы списка.
# Например: (id_start + k - 1) % len(people_list)

def c_cipher(message:str, offset:int):
    alpha = [chr(i) for i in range(ord("а"), ord("я") + 1)]    # заполняем список буквами алфавита

    c_cipher_message = [(alpha[(alpha.index(i_mes) + offset) % len(alpha)] if i_mes in alpha else i_mes) for i_mes in message]
    c_cipher_message_str = "".join(c_cipher_message)

    return c_cipher_message_str


if __name__ == '__main__':
    test_cases = [
        ('Это питон'.lower(), 3),
        ('это Питон'.lower(), 56)
    ]

    for message, offset in test_cases:
        print(f"Сообщение: «{message}», сдвиг: {offset}")
        result = c_cipher(message, offset)
        print(f"Зашифрованное сообщение: «{result}»\n")

********************************************************************************

# Часть 2. Модуль 4. Видео 2. Задача 1. Кубы и квадраты
#
# Пользователь вводит числа A и B. Напишите программу, которая генерирует два списка:
# в первом лежат кубы чисел в диапазоне от А до В,
# во втором — квадраты чисел в этом же диапазоне. Выведите списки на экран.
# Для генерации используйте list comprehensions (как и в следующих задачах).
#
# Пример:
#
# Левая граница: 5
# Правая граница: 10
# Список кубов чисел в диапазоне от 5 до 10: [125, 216, 343, 512, 729, 1000]
# Список квадратов чисел в диапазоне от 5 до 10: [25, 36, 49, 64, 81, 100]

left = int(input("Левая граница: "))
right = int(input("Правая граница: "))

cubes = [i ** 3 for i in range(left, right + 1)]
squares = [i ** 2 for i in range(left, right + 1)]

print(f"Список кубов чисел в диапазоне от {left} до {right}: {cubes}")
print(f"Список квадратов чисел в диапазоне от {left} до {right}: {squares}")

********************************************************************************

# Часть 2. Модуль 4. Видео 2. Задача 2. Сообщение
#
# Илья решил безобидно подшутить над другом и написал программу для смартфона, которая при отправке сообщения удваивает
# каждый символ строки и заодно к каждому удвоенному добавляет ещё один дополнительный.
#
# Пользователь вводит строку и дополнительный символ. Напишите программу, которая генерирует два списка:
# в первом списке каждый элемент — удвоенная буква первой строки, во втором списке каждый элемент —
# конкатенация элемента первого списка и дополнительного символа.
#
# Пример:
#
# Введите строку: привет
# Введите дополнительный символ: !
# Список удвоенных символов: ['пп', 'рр', 'ии', 'вв', 'ее', 'тт']
# Склейка с дополнительным символом: ['пп!', 'рр!', 'ии!', 'вв!', 'ее!', 'тт!']

incoming_msg = input("Введите строку: ")
special_symbol = input("Введите дополнительный символ: ")

doubled_letters = [letter * 2 for letter in incoming_msg]
result_msg = [letter + special_symbol for letter in doubled_letters]

print("Список удвоенных символов:", doubled_letters)
print("Склейка с дополнительным символом:", result_msg)

********************************************************************************

# Часть 2. Модуль 4. Видео 2. Задача 3. Повышение цен
#
# Дан список цен на пять товаров с точностью до копейки. Cпрогнозировали, что через год придётся
# повышать цены на X процентов, а ещё через один год — ещё на Y процентов.
#
# Напишите программу, которая получает на вход список цен на товары (вещественные числа, список генерируется также
# с помощью list comprehensions) и выводит в одну строку общую сумму стоимости товаров за каждый год.
#
# Пример:
#
# Цена на товар: 1.09
# Цена на товар: 23.56
# Цена на товар: 57.84
# Цена на товар: 4.56
# Цена на товар: 6.78
#
# Повышение на первый год: 0
# Повышение на второй год: 10
# Сумма цен за каждый год: 93.83 93.83 103.21

def t1():    # решение данной задачи
    prices = [float(input("Цена на товар: ")) for _ in range(5)]

    first_year = int(input("Повышение на первый год: "))
    second_year = int(input("Повышение на второй год: "))

    all_prices = "Сумма цен за каждый год: "
    for percent in 0, first_year, second_year:
        prices = [price * (1 + percent / 100) for price in prices]
        all_prices += " " + str(round(sum(prices), 2))

    print(all_prices)


def t2():    # немного другая задача из видео
    def get_higher_price(percent, price):
        return round(price * (1 + percent / 100), 2)

    prices_now = [1.09, 23.56, 57.84, 4.56, 6.78]
    first_percent = int(input('Повышение на первый год: '))
    second_percent = int(input('Повышение на второй год: '))

    prices_first = [get_higher_price(first_percent, i_price) for i_price in prices_now]
    prices_second = [get_higher_price(second_percent, i_price) for i_price in prices_first]

    print(f"Сумма цен за каждый год: {round(sum(prices_now), 2)}, {round(sum(prices_first), 2)}, {round(sum(prices_second), 2)}")

t1()

********************************************************************************

# Часть 2. Модуль 4. Видео 3. Задача 1. Список чётных чисел
#
# Пользователь вводит два числа: А и В.
# Реализуйте код, который генерирует список из чётных чисел в диапазоне от А до B.
# Используйте list comprehensions (как и в следующих задачах).

first = int(input("Первое число А: "))
second = int(input("Второе число B: "))

result = [number for number in range(first, second) if number % 2 == 0]
print(result)


********************************************************************************

# Часть 2. Модуль 4. Видео 3. Задача 2. Магазин
#
# У нас есть вот такой список цен на некоторые товары из магазина:
# original_prices = [1.25, -9.45, 10.22, 3.78, -5.92, 1.16]
#
# В этом списке также хранятся цены на товары, которые уже давно не продаются. По какой-то причине система,
# вместо того чтобы их занулить, просто приписала к ним минус. Нам нужно это исправить.
#
# Напишите программу, которая генерирует новый список из первого списка, заменяя все отрицательные числа на ноль.
#
# Результат:
# [1.25, 0, 10.22, 3.78, 0, 1.16]

original_prices = [1.25, -9.45, 10.22, 3.78, -5.92, 1.16]
new_prices = [price if price > 0 else 0 for price in original_prices]
print("Результат:\n\n", new_prices, sep="")

********************************************************************************

# Часть 2. Модуль 4. Видео 3. Задача 3. Отряды
#
# Есть два отряда, в каждом по 10 монстров. В первом отряде у каждого монстра урон случайный
# и колеблется от 50 до 80, а во втором — от 30 до 60. Оба отряда вместе напали на третий, также из 10 юнитов.
# Юнит третьего отряда погибает, если сумма урона от двух монстров больше 100.
#
# Напишите программу, которая генерирует случайные значения в первых двух списках в заданных диапазонах,
# а также генерирует список, состоящий из фраз «Погиб» или «Выжил». Выведите все списки на экран.
#
# Пример:
# Урон первого отряда: [77, 75, 76, 77, 76, 73, 57, 67, 76, 52]
# Урон второго отряда: [53, 51, 31, 60, 49, 37, 31, 60, 37, 47]
# Состояние третьего отряда: ['Погиб', 'Погиб', 'Погиб', 'Погиб', 'Погиб', 'Погиб', 'Выжил', 'Погиб', 'Погиб', 'Выжил']

import random

def t1():    # решение данной задачи
    first_squad = [random.randint(50, 80) for _ in range(10)]
    second_squad = [random.randint(30, 60) for _ in range(10)]
    min_len_of_squad = min(len(first_squad), len(second_squad))
    third_squad = ["Погиб" if first_squad[i] + second_squad[i] > 100 else "Выжил" for i in range(min_len_of_squad)]

    print("Урон первого отряда:", first_squad)
    print("Урон второго отряда:", second_squad)
    print("Состояние третьего отряда:", third_squad)



def t2():    # альтернативное решение из видео
    squad_1 = [random.randint(50, 80) for _ in range(10)]
    squad_2 = [random.randint(30, 60) for _ in range(10)]
    squad_3 = ['Погиб' if squad_1[i_damage] + squad_2[i_damage] > 100 else 'Выжил' for i_damage in range(10)]

    print(f"Урон первого отряда: {squad_1}")
    print(f"Урон второго отряда: {squad_2}")
    print(f"Состояние третьего отряда: {squad_3}")



t1()

********************************************************************************

# Часть 2. Модуль 4. Видео 4. Задача 1. Анализ цен
#
# Нашему другу заказали написать программу, которая анализирует цены на бирже.
# Она получает этот пакет данных, но делать что-либо с ним нельзя. Для нормальной работы
# аналитической программы берётся новый список, который равен тому, что пришло.
# Затем идёт работа с новым списком: если есть отрицательные цены, то программа их зануляет
# и в конце выводит на экран, сколько денег мы по итогу потеряли. Получился вот такой код:
#
# original_prices = [-12, 3, 5, -2, 1]
# new_prices = original_prices
# for i in range(len(original_prices)):
#     if new_prices[i] < 0:
#         new_prices[i] = 0
# print("Мы потеряли: ",  sum(original_prices) - sum(new_prices))
#
# Однако при таких входных данных программа почему-то работает неправильно:
# она выводит ответ 0, когда правильный ответ 14.
# Помогите другу исправить программу, а также сделайте так, чтобы
# список цен генерировался случайно (диапазон можно выбрать любой).

import random

original_prices = [random.randint(-100, 100) for _ in range(10)]

new_prices = original_prices.copy()
# new_prices = original_prices[::]  # копирование можно реализовать и через срез

for i in range(len(original_prices)):

    if new_prices[i] < 0:
        new_prices[i] = 0

print(f"Исходный список: {original_prices}\n"
      f"Новый с список с обнулением: {new_prices}\n"
      f"Сумма элементов исходного: {sum(original_prices)}\n"
      f"Сумма элементов нового: {sum(new_prices)}\n"
      f"Мы потеряли: {(sum(new_prices) - sum(original_prices))}")

********************************************************************************

# Часть 2. Модуль 4. Видео 4. Задача 2. Срезы
#
# Дан список чисел:
# nums = [48, -10, 9, 38, 17, 50, -5, 43, 46, 12]
#
# Напишите программу, которая выводит на экран шесть ответов:
# В первой строке выведите первые пять элементов списка.
# Во второй строке выведите весь список, кроме последних двух элементов.
# В третьей строке выведите все элементы с чётными индексами.
# В четвёртой строке выведите все элементы с нечётными индексами.
# В пятой строке выведите все элементы в обратном порядке.
# В шестой строке выведите все элементы списка через один в обратном порядке, начиная с последнего.
# Для решения используйте только срезы (и без функции len).
#
# Результат:
# [48, -10, 9, 38, 17]
# [48, -10, 9, 38, 17, 50, -5, 43]
# [48, 9, 17, -5, 46]
# [-10, 38, 50, 43, 12]
# [12, 46, 43, -5, 50, 17, 38, 9, -10, 48]
# [12, 43, 50, 38, -10]

nums = [48, -10, 9, 38, 17, 50, -5, 43, 46, 12]
print(f"{nums[:5]}\n"
      f"{nums[:-2]}\n"
      f"{nums[::2]}\n"
      f"{nums[1::2]}\n"
      f"{nums[::-1]}\n"
      f"{nums[::-2]}")


********************************************************************************

# Часть 2. Модуль 4. Видео 4. Задача 3. Удаление части
#
# Дан список из N чисел, а также числа А и В (можно сгенерировать случайно, при этом А < B).
# Напишите программу, которая удаляет элементы списка с индексами от А до В.
# Не используйте дополнительные переменные и методы списков.

import random

def var_1():    # мое решение
    prices = [random.randint(-100, 100) for i_price in range(random.randint(10, 30))]

    A = random.randint(0, len(prices) // 2)
    B = random.randint(len(prices) // 2 + 1, len(prices))

    print(f"Исходный список: {prices}\nA = {A}, B = {B}")
    del prices[A:B]
    print(f"Новый список: {prices}")



def var_2():    # альтернативное решение
    n = int(input("Введите количество чисел N: "))

    numbers = [random.randint(-10, 10) for _ in range(n)]

    a = random.randint(0, len(numbers) - 2)
    b = random.randint(a + 1, len(numbers) - 1)
    # Генерируем числа так, чтобы они не выходили за границу списка
    print(numbers, a, b)
    numbers = numbers[:a] + numbers[b + 1:]
    print(numbers)

var_1()


********************************************************************************

# Часть 2. Модуль 5. Практическая работа. Задание 1. Меню ресторана
#
# Ресторан заказал вам приложение, которое в один клик отображает пользователю меню.
# Для работы ресторан предоставил вам свой сайт, где можно найти меню в виде идущих подряд названий блюд.
#
# Напишите программу, которая выводит меню на экран. На вход подаётся строка из названий блюд,
# разделённых символом «;», а на выходе названия перечисляются через запятую и пробел.
#
# Пример:
# Доступное меню: утиное филе;фланк-стейк;банановый пирог;плов.
# Сейчас в меню есть: утиное филе, фланк-стейк, банановый пирог, плов.
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

menu = 'Пицца;Салат;Суп;Чай;Кофе;Пирожное;Хлеб'.split(';')
print(", ".join(menu))

********************************************************************************

# Часть 2. Модуль 5. Практическая работа. Задание 2. Самое длинное слово
#
# Пользователь вводит строку, содержащую пробелы. Найдите в ней самое длинное слово,
# выведите его и его длину. Если таких слов несколько, выведите первое.
#
# Пример 1
# Введите строку: я есть строка.
# Самое длинное слово: «строка».
# Длина этого слова: 6 символов.
#
# Пример 2
# Введите строку: а б.
# Самое длинное слово: «а».
# Длина этого слова: 1 символ.
#
# Пример 3
# Введите строку: б.
# Самое длинное слово: «б».
# Длина этого слова: 1 символ.
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

len_elб id_el = 0, 0
word = input('Введите фразу (слова через пробелы): ').split()

for id, el in enumerate(word):
    if len(el) > len_el:
        len_el = len(el)
        id_el = id
print(f"Самое длинное слово: {word[id_el]}, кол-во букв: {len_el}")



********************************************************************************

# Часть 2. Модуль 5. Практическая работа. Задание 3. Файлы
#
# В IT-компании есть негласные правила именования текстовых документов:
# Название файла не может начинаться с одного из специальных символов: @, №, $, %, ^, &, *, ().
# Файл должен заканчиваться расширением .txt или .docx.
# Напишите программу, которая получает на вход полное название файла и проверяет, соответствует ли он этим правилам.
#
# Пример 1
# Название файла: @example.txt.
# Ошибка: название начинается недопустимым символом.
#
# Пример 2
# Название файла: example.ttx.
# Ошибка: неверное расширение файла. Ожидалось .txt или .docx.
#
# Пример 3
# Название файла: example.txt.
# Файл назван верно.
#
# Советы и рекомендации
# Метод endswith (как и startswith) можно использовать для проверки нескольких окончаний. Примеры такого использования.
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

taboo_char = '@№$%^&*()'
allow_exten = ['.txt', '.docx']

file_name = input('Введите название файла: ')

for i in range(len(allow_exten)):
    if file_name.endswith(allow_exten[i]):
        for el in taboo_char:
            if file_name.startswith(el):
                print(f"Ошибка имени файла: используется запрещенный символ {el}")
                exit()
        print('Файл назван верно.')
        break
else:
    print(f"Ошибка расширения. Можно использовать только {allow_exten}")




********************************************************************************

# Часть 2. Модуль 5. Практическая работа. Задание 4. Заглавные буквы
#
# Пользователь вводит строку. Напишите программу, которая меняет регистр символов
# в этой строке так, чтобы первая буква каждого слова была прописной, а остальные — строчными.
#
# Пример
# Введите строку: Кажется, я забыл выключить утюг.
# Результат: Кажется, Я Забыл Выключить Утюг.
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует указанному в задаче.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

text = input('Введите текст: ').title()
print(text)


********************************************************************************

# Часть 2. Модуль 5. Практическая работа. Задание 5. Пароль
#
# При регистрации на сайте, помимо логина, нужно придумать пароль.
# Этот пароль должен состоять минимум из восьми символов, содержать
# хотя бы одну большую букву и не менее трёх цифр. Тогда он будет считаться надёжным.
#
# Напишите программу, которая просит пользователя придумать пароль до тех пор,
# пока этот пароль не станет надёжным. Должна использоваться латиница.
#
# Пример
# Придумайте пароль: qwerty.
# Пароль ненадёжный. Попробуйте ещё раз.
# Придумайте пароль: qwerty12.
# Пароль ненадёжный. Попробуйте ещё раз.
# Придумайте пароль: qwerty123.
# Пароль ненадёжный. Попробуйте ещё раз.
# Придумайте пароль: qWErty123.
# Это надёжный пароль.
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

def contains_num_up(usr_password):
    # alpha = [chr(i) for i in range(ord("a"), ord("z") + 1)]
    count_digit, count_up, count_alpha = 0, 0, 0

    for el in usr_password:
        if el.isdigit():
            count_digit += 1
        elif el.isupper():
            count_up += 1
        if count_digit >= 3 and count_up >= 1:
            return True


while True:

    usr_password = input('Придумайте пароль: ')
    min_lenth = 8

    if len(usr_password) >= min_lenth and contains_num_up(usr_password):
        print("Это надёжный пароль.")
        break
    else:
        print("Пароль ненадёжный. Попробуйте ещё раз.")


********************************************************************************

# Часть 2. Модуль 5. Практическая работа. Задание 6. Сжатие
#
# Из-за того, что объём данных увеличился, понадобилось сжать эти данные, но так,
# чтобы не потерять важную информацию. Для этого было придумано специальное кодирование:
# s = 'aaaabbсaa' преобразуется в 'a4b2с1a2'. То есть группы одинаковых символов
# исходной строки заменяются на эти символы и количество их повторений в строке.
#
# Напишите программу, которая считывает строку, кодирует её, используя предложенный алгоритм,
# и выводит закодированную последовательность на экран. Код должен учитывать регистр символов.
#
# Пример
# Введите строку: aaAAbbсaaaA.
# Закодированная строка: a2A2b2с1a3A1.
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.
# test = 'ffRfffrrRRRRtFFFffFFFFFttfrtaaaa'

text = input('Введите строку: ')
compressed_text = ''
count = 1

for i in range(len(text) - 1):
    if text[i] == text[i+1]:
        count += 1
    if text[i] != text[i+1] or i == len(text) - 2:
        compressed_text += text[i] + str(count)
        count = 1
if text[-2] != text[-1]:
    compressed_text += text[-1] + '1'
print(compressed_text)








********************************************************************************

# Часть 2. Модуль 5. Практическая работа. Задание 7. IP-адрес 2
#
# Напишите программу, которая определяет, действительно ли заданная строка —
# правильный IP-адрес. Обеспечьте контроль ввода, где предусматривается
# добавление целых чисел от 0 до 255 и точек между ними.
#
# Пример 1
# Введите IP: 128.16.35.a4
# a4 — это не целое число.
#
# Пример 2
# Введите IP: 240.127.56.340
# 340 превышает 255.
#
# Пример 3
# Введите IP: 34.56.42,5
# Адрес — это четыре числа, разделённые точками.
#
# Пример 4
# Введите IP: 128.0.0.255
# IP-адрес корректен.
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.
usr_ip = input('Введите IP: ')
count = 0

if usr_ip.count('.') == 3:
    for elem in usr_ip.split('.'):
        if elem.isdigit():
            if 0 <= int(elem) <= 255:
                count += 1
            else:
                print(f"{elem} не входит в диапазон 0 до 255.")
        else:
            print(f"{elem} не является целым числом.")
else:
    print('IP — это четыре числа, разделённые тремя точками. Проверьте разделители.')

if count == 4:
    print('IP-адрес корректен.')

********************************************************************************

# Часть 2. Модуль 5. Практическая работа. Задание 8. Бегущая строка
#
# В одной из практических работ вы писали программу для табло,
# которая циклически сдвигает элементы списка чисел вправо на K позиций.
# В этот раз вы работаете с двумя строками. Возможно, одна из строк немного сдвинута.
# Нужно проверить, не равна ли первая строка второй.
#
# Пользователь вводит две строки. Напишите программу, которая определяет,
# можно ли получить первую строку из второй циклическим сдвигом.
#
# По желанию: если строку получить можно, выведите значение сдвига.
#
# Пример 1
# Первая строка: abcd.
# Вторая строка: cdab.
# Первая строка получается из второй со сдвигом 2.
#
# Пример 2
# Первая строка: abcd.
# Вторая строка: cdba.
#
# Первую строку нельзя получить из второй с помощью циклического сдвига.
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.



str1 = 'eeeabcdfee'
str2 = 'cdfeeeeeab'

if len(str1) != len(str2):
    print("Строки разной длины!")

if str1[0:str1.count(str1[0])] in str2:
    combo = "".join((str2[str2.index(str1[0:str1.count(str1[0])]):], str2[:str2.index(str1[0:str1.count(str1[0])])]))
    if str1 == combo:
        k = str2.index(str1[0:str1.count(str1[0])])
        print(f"Первая строка получается из второй со сдвигом {k}")
    else:
        print("Первую строку нельзя получить из второй с помощью циклического сдвига.")

********************************************************************************

# Часть 2. Модуль 5. Практическая работа. Задание 9. Анализ комментариев
#
# Напишите программу, которая считывает строку и выводит количество заглавных
# и строчных букв в строке, используя методы строк.
#
# Программа должна это делать за один проход по строке.
#
# Решение должно быть оформлено в виде функции, которая принимает на вход строку-текст,
# а на выход возвращает два числа (количество заглавных и строчных букв).
#
# Пример:
# text = input("Введите строку для анализа: ")
# uppercase, lowercase = count_uppercase_lowercase(text)
# print("Количество заглавных букв:", uppercase)
# print("Количество строчных букв:", lowercase)
#
# Вывод в консоли:
# Введите строку для анализа: Hello World!
# Количество заглавных букв: 2
# Количество строчных букв: 8
#
# Советы
# Вспомните методы строк, которые изучили. Выберите из них те, которые помогут вам
# выполнить проверку буквы (является ли она заглавной или нет).
# Чтобы вернуть несколько элементов из функции, перечислите их через запятую:
# return a, b

def count_up_low(text):

    count_upper, count_lower = 0, 0

    for el in text:
        if el.isupper():
            count_upper += 1
        elif el.islower():
            count_lower += 1
    return print(f"Заглавных букв: {count_upper}, строчных букв: {count_lower}")



if __name__ == '__main__':

    text = input('Введите строку: ')
    result = count_up_low(text)


********************************************************************************

# Часть 2. Модуль 5. Видео 2. Задача 1. Заказ
#
# Напишите программу, которая получает на вход имя и код заказа, а затем выводит на экран соответствующее сообщение.
# Для решения используйте строковый метод format.

# Пример:
# Имя: Иван
# Номер заказа: 10948
# Здравствуйте, Иван! Ваш номер заказа: 10948. Приятного дня!

name = input("Имя: ")
order_id = input("Номер заказа: ")

print("Здравствуйте, {0}! Ваш номер заказа: {1}. Приятного дня!".format(name, order_id))
# print("Здравствуйте, {name}! Ваш номер заказа: {id}. Приятного дня!".format(name=name, id=order_id))

********************************************************************************

# Часть 2. Модуль 5. Видео 2. Задача 2. Долги
#
# Напишите программу, которая получает на вход имя и долг, а затем выводит на экран сообщение,
# где имя повторяется несколько раз (и долг, возможно, тоже). Используйте числа в названиях ключей.
#
# Пример:
# Введите имя: Том
# Введите долг: 100
# Том! Том, привет! Как дела, Том? Где мои 100 рублей? Том!

name = input("Имя: ")
debt = input("Долг: ")

print("{name}! {name}, привет! Как дела, {name}? Помнишь, {name}, ты у меня {debt} рублей на пиво занимал? Где мои {debt} рублей? {name}!".format(name=name, debt=debt))


********************************************************************************

# Часть 2. Модуль 5. Видео 2. Задача 3. IP-адрес
#
# IP-адрес компьютера состоит из 4 чисел, разделённых точкой.
# IPv4 (Internet Protocol v. 4) — адрес, записанный в 32-битном формате.
# Имеет вид четырех 8-битных чисел (минимум 0, максимум 255), которые разделены друг от друга точками.
# Пример: 172.16.255.2.
# Каждое число находится в диапазоне от 0 до 255 (включительно).
#
# Пример правильного адреса: 192.168.1.0
# Пример неправильного адреса: 192.168.300.0
#
# Напишите программу, которая получает на вход 4 числа и выводит на экран IP-адрес.
# Используйте переменную ip_address в качестве шаблона. Обеспечьте контроль ввода.
#
# Диапазоны внутренних («серый», локальный или частный IP-адрес источника) IP-адресов:
# 10.0.0.0 – 10.255.255.255;
# 172.16.0.0 – 172.31.255.255;
# 192.168.0.0 – 192.168.255.255.

ip_address = "{0}.{1}.{2}.{3}"
numbers = [(int(input("Введите число: ")) if 0 <= num <= 255 else print('Ошибка ввода')) for num in range(4)]

print(ip_address.format(*numbers))    # * - полезный инструмент
# print(ip_address.format(numbers[0], numbers[1], numbers[2], numbers[3]))


********************************************************************************

# Часть 2. Модуль 5. Видео 3. Задача 1. Улучшенная лингвистика 2
#
# У нас есть список из трёх слов, которые вводит пользователь. Затем вводится сам текст произведения,
# который вводится уже в одну строку. Напишите программу, которая посчитает, сколько раз слова пользователя встречаются в тексте.

words = [input("Введите слово: ") for _ in range(3)]
text = input("Введите текст: ")
words_count = [text.count(word) for word in words]

print(words_count)

********************************************************************************

# Часть 2. Модуль 5. Видео 3. Задача 2. Бабушка
#
# Пользователь вводит строку. Напишите программу, которая преобразовывает
# в этой строке все идущие подряд пробелы в один и выводит результат на экран.
# Пример:
# Введите текст: У       нас         пошёл                    снег    !
# Исправленный текст: У нас пошёл снег !

text = input("Введите текст: ")
print(" ".join(text.split()))

********************************************************************************

# Часть 2. Модуль 5. Видео 3. Задача 3. Разделители символов
#
# Нужно сделать рассылку поздравлений для определённого списка людей.
# Напишите программу, которая запрашивает у пользователя:
# Шаблон поздравления (туда вставляется ФИ и возраст)
# ФИ людей (в одну строку, разделяются запятой)
# Возраст каждого человека (в одну строку через пробел)
# В конце программа выводит поздравления и всех именинников в одну строку вместе с их возрастом.
#
# Пример:
# Введите шаблон поздравления, в шаблоне можно использовать конструкцию {name} и {age}:
# С днём рождения, {name}! С {age}-летием тебя!
# Список людей через запятую: Иван Иванов, Петя Петров, Лена Ленова
# Возраст людей через пробел: 20 30 18
#
# С днём рождения, Иван Иванов! С 20-летием тебя!
# С днём рождения, Петя Петров! С 30-летием тебя!
# С днём рождения, Лена Ленова! С 18-летием тебя!
#
# Именинники: Иван Иванов 20, Петя Петров 30, Лена Ленова 18

while True:
    grats_template = input('Введите шаблон поздравления, вставив {name} и {age}: ')
    if '{name}' in grats_template and '{age}' in grats_template:
        break
    print('Ошибка ввода: вставьте {name} и {age}')

names_list = input('Список имен через запятую: ').split(', ')
ages_list = input('Список возрастов через пробел: ').split()

for i, i_name in enumerate(names_list):
    print(grats_template.format(name=i_name, age=ages_list[i]))

# Вариант 2 - zip соединяет списки и можно брать сразу по элементу из каждого
# for age, name in zip(ages_list, names_list):
    # print(grats_template.format(name=name, age=age))

people = [" ".join([names_list[i], str(ages_list[i])]) for i in range(len(names_list))]
print(people)

print("\nИменинники:", ", ".join(people))




********************************************************************************

# Часть 2. Модуль 5. Видео 4. Задача 1. Шифр Цезаря 2
#
# Каждая буква заменяется на следующую по алфавиту через K позиций по кругу.
#
# Напишите (модифицируйте) программу, которая реализует этот алгоритм шифрования.
# Не используйте конкатенацию и сделайте так, чтобы текст был в одном регистре.

text = input("Введите текст: ")
delta = int(input("Введите сдвиг: "))
alphabet = [chr(index) for index in range(ord("а"), ord("я") + 1)]  # заполняем список буквами алфавита
# Думаем над структурой алгоритма: [вариант_1 если условие_1 иначе вариант_2 for буква in текст]
new_text = [alphabet[(alphabet.index(letter) + delta) % len(alphabet)] if letter in alphabet else letter for letter in text.lower()]
print(''.join(new_text))


********************************************************************************

# Часть 2. Модуль 5. Видео 4. Задача 2. Путь к файлу
#
# Внутри проекта часто используются абсолютные пути файлов, которые необходимо проверять.
# Пользователь вводит абсолютный путь к текстовому файлу, а также проверяемые данные: диск и расширение файла.
# Напишите программу, которая проверяет корректность этого пути.
#
# Пример:
# Путь к файлу: C:/user/docs/folder/new_file.txt
# На каком диске должен лежать файл: C
# Требуемое расширение файла: .txt
# Путь корректен!

path = input("Введите аболютный путь к файлу: ")
disk = input("На каком диске должен лежать файл: ")
extension = input("Какое должно быть расширение файла: ")

# мое решение
if not path.startswith(disk):
    print('Ошибка имени диска')
elif not path.endswith(extension):
    print('Ошибка расширения файла.')
else:
    print("Путь корректен!")

# решение skillbox
if path.startswith(disk) and path.endswith(extension):
    print("Путь корректен!")
else:
    print("Путь некорректен!")


********************************************************************************

# Часть 2. Модуль 5. Видео 4. Задача 3. Удаление части
#
# На вход в программу подаётся строка, состоящая из прописных и заглавных букв кириллицы.
# Напишите код, который проверяет,
# каких букв в строке больше, прописных или заглавных. Если заглавных букв больше,
# то сделать все буквы строки заглавными, иначе сделать все прописными.
#
# Подсказка: используйте методы islower() и/или isupper().
#
# Пример:
# Введите строку: ПитоН - этО хорошО
# Результат: питон - это хорошо
#
# Пример 2:
# Введите строку: ПиТоН - ЭтО УДоБнО
# Результат: ПИТОН - ЭТО УДОБНО

text = input('Введите строку из прописных и заглавных букв: ')

lowers = len([letter for letter in text if letter.islower()])
uppers = len([letter for letter in text if letter.isupper()])

if lowers > uppers:
    print("Результат:", text.lower())
else:
    print("Результат:", text.upper())


********************************************************************************

# Часть 2. Модуль 6. Практическая работа. Задание 1. Песни — 2
#
# Песни хранятся в виде словаря. Каждая песня состоит из названия и продолжительности с точностью до долей минут.
# violator_songs = {
# 'World in My Eyes': 4.86,
# 'Sweetest Perfection': 4.43,
# 'Personal Jesus': 4.56,
# 'Halo': 4.9,
# 'Waiting for the Night': 6.07,
# 'Enjoy the Silence': 4.20,
# 'Policy of Truth': 4.76,
# 'Blue Dress': 4.29,
# 'Clean': 5.83
# }
# Напишите программу, которая запрашивает у пользователя количество песен из списка
# и их названия, а на экран выводит общее время их звучания.
#
# Пример
# Сколько песен выбрать? 3
# Название первой песни: Halo
# Название второй песни: Enjoy the Silence
# Название третьей песни: Clean
# Общее время звучания песен: 14,93 минуты
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

violator_songs = {
'World in My Eyes': 4.86,
'Sweetest Perfection': 4.43,
'Personal Jesus': 4.56,
'Halo': 4.9,
'Waiting for the Night': 6.07,
'Enjoy the Silence': 4.20,
'Policy of Truth': 4.76,
'Blue Dress': 4.29,
'Clean': 5.83
}

n = int(input('Сколько песен нужно? '))
time = 0
for i in range(n):
    song = input(f"Введите название {i}-й песни: ")
    time += violator_songs.get(song, 0)
print(f"Общее время звучания песен: {time:.2f} минуты.")


********************************************************************************

# Часть 2. Модуль 6. Практическая работа. Задание 2. Криптовалюта
#
# При работе с API (application programming interface) сайта биржи по криптовалюте
# вы получили такие данные в виде словаря:
#
# data = {
# "address": "0x544444444444",
# "ETH": {
# "balance": 444,
# "totalIn": 444,
# "totalOut": 4
# },
# "count_txs": 2,
# "tokens": [
# {
# "fst_token_info": {
# "address": "0x44444",
# "name": "fdf",
# "decimals": 0,
# "symbol": "dsfdsf",
# "total_supply": "3228562189",
# "owner": "0x44444",
# "last_updated": 1519022607901,
# "issuances_count": 0,
# "holders_count": 137528,
# "price": False
# },
# "balance": 5000,
# "totalIn": 0,
# "total_out": 0
# },
# {
# "sec_token_info": {
# "address": "0x44444",
# "name": "ggg",
# "decimals": "2",
# "symbol": "fff",
# "total_supply": "250000000000",
# "owner": "0x44444",
# "last_updated": 1520452201,
# "issuances_count": 0,
# "holders_count": 20707,
# "price": False
# },
# "balance": 500,
# "totalIn": 0,
# "total_out": 0
# }
# ]
# }
# Теперь необходимо обработать эти данные.
#
# Напишите программу, которая выполняет следующий алгоритм действий:
#
# Вывести списки ключей и значений словаря.
# В ETH добавить ключ total_diff со значением 100.
# Внутри fst_token_info значение ключа name поменять с fdf на doge.
# Удалить total_out из tokens и присвоить его значение в total_out внутри ETH.
# Внутри sec_token_info изменить название ключа price на total_price.
# После выполнения алгоритма выводить результат (словарь) не нужно.
#
# Советы и рекомендации
# Если вы достали из словаря список по ключу, то можете применять к нему методы списка.
# Например:
#
# словарь[“список”].append(123)
#
# Python возьмёт из словаря объект по ключу «список» и применит к нему метод append.
# Эта же логика работает с другими типами данных. Например, если вы достали из словаря словарь,
# то к нему можно применять методы словаря, а если достали строку — методы строк.
#
# Чтобы не запутаться, распечатывайте объект, который получаете в данный момент. Также можно распечатать тип объекта:
# print(data)
# print(data[‘ключ’], type(data[‘ключ’]))
# print(data[‘ключ’][0], type(data[‘ключ’][0]))
# и так далее.
#
# Так вы всегда будете понимать, над каким объектом работаете в данный момент.
#
# Что оценивается
# Результат вычислений корректен.
# В коде соблюдается порядок действий алгоритма.
# Не используется других переменных, кроме data.

data = {
    "address": "0x544444444444",
    "ETH": {
        "balance": 444,
        "totalIn": 444,
        "totalOut": 4
            },
    "count_txs": 2,
    "tokens": [
                {
            "fst_token_info":
                    {
                "address": "0x44444",
                "name": "fdf",
                "decimals": 0,
                "symbol": "dsfdsf",
                "total_supply": "3228562189",
                "owner": "0x44444",
                "last_updated": 1519022607901,
                "issuances_count": 0,
                "holders_count": 137528,
                "price": False
                    },
            "balance": 5000,
            "totalIn": 0,
            "total_out": 0
                },

                {
            "sec_token_info":
                    {
                "address": "0x44444",
                "name": "ggg",
                "decimals": "2",
                "symbol": "fff",
                "total_supply": "250000000000",
                "owner": "0x44444",
                "last_updated": 1520452201,
                "issuances_count": 0,
                "holders_count": 20707,
                "price": False
                    },
            "balance": 500,
            "totalIn": 0,
            "total_out": 0
                }
            ]
}

# Вывести списки ключей и значений словаря.
# В ETH добавить ключ total_diff со значением 100.
# Внутри fst_token_info значение ключа name поменять с fdf на doge.
# Удалить total_out из tokens и присвоить его значение в total_out внутри ETH.
# Внутри sec_token_info изменить название ключа price на total_price.
# После выполнения алгоритма выводить результат (словарь) не нужно.

# {"address": "0x544444444444",
# "ETH": {"balance": 444, "totalIn": 444, "totalOut": 4},
# "count_txs": 2,
# "tokens": [{"fst_token_info": {1*}, "balance": 5000, "totalIn": 0, "total_out": 0},
#            {"sec_token_info" : {2*}, "balance": 500, "totalIn": 0, "total_out": 0}]}
#
# {1*} "fst_token_info": {"address": "0x44444", "name": "fdf", "decimals": 0, "symbol": "dsfdsf", "total_supply": "3228562189",
#     "owner": "0x44444", "last_updated": 1519022607901, "issuances_count": 0, "holders_count": 137528, "price": False}
#
# {2*} "sec_token_info": { "address": "0x44444", "name": "ggg", "decimals": "2", "symbol": "fff", "total_supply": "250000000000",
#     "owner": "0x44444", "last_updated": 1520452201,  "issuances_count": 0, "holders_count": 20707, "price": False}

print(f"Вывести списки ключей и значений словаря data:")
for data_key, data_val in data.items():
    print(f"{data_key}: {data_val}")

    if data_key == 'ETH':
        data['ETH'].update({'total_diff': '100'})

    elif data_key == 'tokens':
        tokens_list = data['tokens']

        fst_token_info_dict = tokens_list[0]['fst_token_info']
        fst_token_info_dict['name'] = 'doge'

        token_list_0 = tokens_list[0]
        pop_0 = token_list_0.pop('total_out')
        token_list_1 = tokens_list[1]
        pop_1 = token_list_1.pop('total_out')
        data['ETH']['total_out'] = pop_1

        sec_token_info_dict = tokens_list[1]['sec_token_info']
        sec_token_info_dict['total_price'] = sec_token_info_dict.pop('price')

print(f"\nВ ETH добавить ключ total_diff со значением 100:\n"
      f"{data['ETH']}\n"
      f"\nВнутри fst_token_info значение ключа name поменять с fdf на doge\n"
      f"{data['tokens'][0]}\n"
      f"\nУдалить total_out из tokens:\n"
      f"{data['tokens']}\n"
      f"...и присвоить его значение в total_out внутри ETH:\n"
      f"{data['ETH']}\n"
      f"\nВнутри sec_token_info изменить название ключа price на total_price:\n"
      f"{data['tokens'][1]['sec_token_info']}\n")


********************************************************************************

# Часть 2. Модуль 6. Практическая работа. Задание 3. Товары
#
# В базе данных магазина вся необходимая информация по товарам делится на два словаря:
# первый отвечает за артикулы, второй — за списки количества товаров на складе:
#
# goods = {
# 'Лампа': '12345',
# 'Стол': '23456',
# 'Диван': '34567',
# 'Стул': '45678',
# }
# store = {
# '12345': [
# {'quantity': 27, 'price': 42},
# ],
# '23456': [
# {'quantity': 22, 'price': 510},
# {'quantity': 32, 'price': 520},
# ],
# '34567': [
# {'quantity': 2, 'price': 1200},
# {'quantity': 1, 'price': 1150},
# ],
# '45678': [
# {'quantity': 50, 'price': 100},
# {'quantity': 12, 'price': 95},
# {'quantity': 43, 'price': 97},
# ],
# }
# Каждая запись второго словаря отображает, сколько и по какой цене
# закупалось товаров. Цена указана за одну штуку.
#
# Напишите программу, которая рассчитывает общую стоимость позиций
# для каждого товара на складе и выводит эту информацию на экран.
#
# Результат работы программы:
# Лампа — 27 штук, стоимость 1134 рубля.
# Стол — 54 штуки, стоимость 27 860 рублей.
# Диван — 3 штуки, стоимость 3550 рублей.
# Стул — 105 штук, стоимость 10 311 рублей.
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует указанному в задаче.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

def get_key(val):
    for key, value in goods.items():
        if val == value:
            return key
    return "key doesn't exist"

goods = {
    'Лампа': '12345',
    'Стол': '23456',
    'Диван': '34567',
    'Стул': '45678',
}

store = {
    '12345': [
        {'quantity': 27, 'price': 42},
            ],
    '23456': [
        {'quantity': 22, 'price': 510},
        {'quantity': 32, 'price': 520},
            ],
    '34567': [
        {'quantity': 2, 'price': 1200},
        {'quantity': 1, 'price': 1150},
            ],
    '45678': [
        {'quantity': 50, 'price': 100},
        {'quantity': 12, 'price': 95},
        {'quantity': 43, 'price': 97},
            ],
}

quantity_sum, price_sum = 0, 0

for s_key, s_val in store.items():
    prod = get_key(s_key)
    for i_store in store[s_key]:
        quantity_sum += i_store['quantity']
        price_sum += i_store['price'] * i_store['quantity']

    if quantity_sum % 10 == 1:
        end_1 = 'а'
    elif quantity_sum % 10 == 2 or quantity_sum % 10 == 3 or quantity_sum % 10 == 4:
        end_1 = 'и'
    else:
        end_1 = ''

    if price_sum % 10 == 1:
        end_2 = 'ь'
    elif price_sum % 10 == 2 or price_sum % 10 == 3 or price_sum % 10 == 4:
        end_2 = 'я'
    else:
        end_2 = 'ей'

    print("{prod} -- {quantity_sum} штук{end_1}, стоимость {price_sum:,d} рубл{end_2}.".format(
        prod=prod,
        quantity_sum=quantity_sum,
        end_1=end_1,
        price_sum=price_sum,
        end_2=end_2
    ))
    num = 456767

    quantity_sum, price_sum = 0, 0


# Решение skillbox
#
# for i_title, i_code in goods.items():
#     total_quantity = 0
#     total_cost = 0
#     for i_good in store[i_code]:
#         total_quantity += i_good['quantity']
#         total_cost += i_good['price'] * i_good['quantity']
#     print('{title} - {quantity} шт., стоимость {cost} руб.'.format(
#         title=i_title,
#         quantity=total_quantity,
#         cost=total_cost
#     ))
#



********************************************************************************

# Часть 2. Модуль 6. Практическая работа. Задание 4. Гистограмма частоты — 2
#
# Написать функцию, которая будет инвертировать полученный словарь.
# В качестве ключа будет частота, а в качестве значения — список символов с этой частотой.
#
# По итогу нужно реализовать следующие подзадачи:
# получить текст и создать из него оригинальный словарь частот;
# создать новый словарь и заполнить его данными из оригинального словаря частот,
# используя количество повторов в качестве ключей, а буквы — в качестве значений,
# добавляя их в список для хранения.
#
# Пример
# Введите текст: здесь что-то написано
# Оригинальный словарь частот:
# : 2
# - : 1
# З : 1
# а : 2
# д : 1
# е : 1
# и : 1
# н : 2
# о : 3
# п : 1
# с : 2
# т : 2
# ч : 1
# ь : 1
#
# Инвертированный словарь частот:
# 1 : ['З', 'д', 'е', 'ь', 'ч', '-', 'п', 'и']
# 2 : ['с', ' ', 'т', 'н', 'а']
# 3 : ['о']
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Основной функционал описан в отдельных функциях.
# Переменные и функции имеют значимые имена, не только a, b, c, d.


def dict_frequencies(some_text):
    dict_rate = dict()
    some_text = sorted(some_text)
    for sym in some_text:
        dict_rate[sym] = some_text.count(sym)

    print("\nОригинальный словарь частот:")
    for i_rate in dict_rate:
        print(f"{i_rate} : {dict_rate[i_rate]}")

    return dict_rate


def inverted_dict(some_dict):

    inv_dict = dict()
    for el in set(some_dict.values()):
        inv_dict[el] = [key for key, val in some_dict.items() if val == el]

    print("\nИнвертированный словарь частот:")
    for i_inv in inv_dict:
        print(f"{i_inv}: {inv_dict[i_inv]}")

    return inv_dict



if __name__ == '__main__':
    text = input("Введите текст: ")
    inverted_dict(dict_frequencies(text))


********************************************************************************

# Часть 2. Модуль 6. Практическая работа. Задание 5. Словарь синонимов
#
# На вход в программу подаётся N пар слов. Каждое слово является синонимом для своего парного слова.
#
# Реализуйте код, который составляет словарь синонимов (все слова в словаре различны),
# затем запрашивает у пользователя слово и выводит на экран его синоним. Обеспечьте контроль ввода:
# если такого слова нет, выведите ошибку и запросите слово ещё раз.
# При этом проверка не должна зависеть от регистра символов.
#
# Пример
# Введите количество пар слов: 3
# Первая пара: Привет — Здравствуйте
# Вторая пара: Печально — Грустно
# Третья пара: Весело — Радостно
# Введите слово: интересно
# Такого слова в словаре нет.
# Введите слово: здравствуйте
# Синоним: Привет
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

n = int(input('Введите количество пар слов (слово1 — слово2): '))
words_dict = dict()
for i in range(n):
    too_words = input(f"{i+1}-я пара: ").lower().split(' - ')
    words_dict[too_words[0].title()] = too_words[1].title()
print(words_dict)

while True:
    user_word = input('Введите слово: ').lower().title()
    print(f"Синоним: {words_dict.get(user_word, 'Такого слова в словаре нет.')}")


********************************************************************************

# Часть 2. Модуль 6. Практическая работа. Задание 6. Пицца
#
# На вход в программу подаётся N заказов. Каждый заказ представляет собой
# строку вида «Покупатель — название пиццы — количество заказанных пицц». Реализуйте код,
# который выводит список покупателей и их заказов по алфавиту. Учитывайте, что один
# человек может заказать одну и ту же пиццу несколько раз.
#
# Пример
# Введите количество заказов: 6
# Первый заказ: Иванов Пепперони 1
# Второй заказ: Петров Де-Люкс 2
# Третий заказ: Иванов Мясная 3
# Четвёртый заказ: Иванов Мексиканская 2
# Пятый заказ: Иванов Пепперони 2
# Шестой заказ: Петров Интересная 5
# Иванов:
# Мексиканская: 2
# Мясная: 3
# Пепперони: 3
# Петров:
# Де-Люкс: 2
# Интересная: 5
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру (перед названием пиццы пять пробелов).
# Переменные и функции имеют значимые имена, не только a, b, c, d.

n = int(input("Введите количество заказов: "))
order_data = dict()

for i in range(n):
    order_input = input(f"{i+1}-й заказ: ").split()
    if order_input[0] in order_data:
        if order_input[1] in order_data[order_input[0]]:
            order_data[order_input[0]][order_input[1]] += int(order_input[2])
        else:
            #order_data[order_input[0]][order_input[1]] = int(order_input[2])
            order_data[order_input[0]].update({order_input[1]: int(order_input[2])})
    else:
        order_data[order_input[0]] = {order_input[1]: int(order_input[2])}

for key in sorted(order_data.keys()):
    print(f"{key}:")
    for key, val in sorted(order_data[key].items()):
        print(f"  {key}: {val}")





********************************************************************************

# Часть 2. Модуль 6. Практическая работа. Задание 7. Три списка
#
# array_1 = [1, 5, 10, 20, 40, 80, 100]
# array_2 = [6, 7, 20, 80, 100]
# array_3 = [3, 4, 15, 20, 30, 70, 80, 120]
#
# 1. Найти элементы, которые есть в каждом списке;
# 2. Найти элементы из первого списка, которых нет во втором и третьем списках.
# Каждую задачу нужно выполнить двумя способами:
# без использования множеств;
# с использованием множеств.
#
# Пример выполнения на других данных:
# array_1 = [1, 2, 3, 4]
# array_2 = [2, 4]
# array_3 = [2, 3]
# Вывод:
# Задача 1:
# Решение без множеств: 2
# Решение с множествами: 2
# Задача 2:
# Решение без множеств: 1
# Решение с множествами: 1
#
# Что оценивается
# Результат вычислений корректен.
# Обе задачи решены двумя предложенными способами. Один из способов —
# обязательно с использованием множеств и операций над множествами.
# Формат вывода соответствует примеру.
# Основной функционал описан в отдельной функции.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

array_1 = [1, 5, 10, 20, 40, 80, 100]
array_2 = [6, 7, 20, 80, 100]
array_3 = [3, 4, 15, 20, 30, 70, 80, 120]

print("Решение с множествами:")
set_1 = set(array_1)
set_2 = set(array_2)
set_3 = set(array_3)
print(f"1) Элементы, которые есть в каждом списке: {set_1 & set_2 & set_3}")
print(f"2) Элементы из первого списка, которых нет во втором и третьем списках: {set_1 - (set_2 | set_3)}")

print("Решение без множеств:")
result_1 = [el for el in array_1 if el in array_2 and el in array_3]
print(f"1) {result_1}")
result_2 = [el for el in array_1 if not(el in array_2 or el in array_3)]
print(f"2) {result_2}")


********************************************************************************

# Часть 2. Модуль 6. Практическая работа. Задание 8. Снова палиндром
#
# Пользователь вводит строку. Необходимо написать программу, которая определяет,
# существует ли у этой строки перестановка, при которой она станет палиндромом.
# Затем она должна выводить соответствующее сообщение.
#
# Пример 1
# Введите строку: aab
# Можно сделать палиндромом
#
# Пример 2
# Введите строку: aabc
# Нельзя сделать палиндромом
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Основной функционал описан в отдельной функции.
# Переменные и функции имеют значимые имена, не только a, b, c, d.
#

def is_palindrom(some_str):
    sym_dict = dict()

    for sym in some_str:
        sym_dict[sym] = some_str.count(sym)
        # sym_dict[sym] = sym_dict.get(sym, 0) + 1    # решение skillbox


    count = 0
    for val in sym_dict.values():
        if val % 2 != 0:
            count += 1

    if count > 1:
        return f"Строку {some_str} нельзя сделать палиндромом."
    else:
        return f"Строку {some_str} можно сделать палиндромом."


if __name__ == '__main__':
    test_cases = [
        'aab',
        'aabc',
        'somestr',
        'atbggba',
        ''
    ]
    for some_str in test_cases:
        print(is_palindrom(some_str))


********************************************************************************

par_list = ['Имя', 'Фамилия', 'Город', 'Место учебы', 'Оценки']
all_list = list()
grade_list = []
student_str = ''

while True:

    student_str = input(f"Введите информацию о студенте через пробел\n{par_list}:\n")

    if student_str == 'end':
        break

    student_info = student_str.split()
    student_dict = dict()
    n = len(par_list)

    for i in range(n - 1):
        student_dict[par_list[i]] = student_info[i]

    for i_grade in student_info[(n - 1):]:
        grade_list.append(int(i_grade))
    student_dict[par_list[n-1]] = grade_list

    all_list.append(student_dict)
    grade_list = []

for el in all_list:
    for key in el:
        print(f"{key} : {el[key]}")
    print()




********************************************************************************

# Часть 2. Модуль 6. Видео 1. Задача 1. Словарь квадратов чисел
#
# На вход программе поступает целое число num. Напишите программу создания словаря,
# который включает в себя ключи от 1 до num,
# а значениями соответствующего ключа будет значение ключа в квадрате.
#
# Пример:
# Введите целое число: 5
# Результат: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

num = int(input('Введите число: '))
square_dict = dict()

for i in range(1, num+1):
    square_dict[i] = i**2

for key in square_dict:
    print(f"{key} : {square_dict[key]}")


********************************************************************************

# Часть 2. Модуль 6. Видео 1. Задача 2. Студент
#
# Пользователь вводит фамилию, имя студента, город проживания, вуз, в котором он учится, и все его оценки.
# Всё вводится в одну строку через пробел. Напишите программу, которая по этой информации составит словарь и выведет его на экран.
#
# Пример:
# Введите информацию о студенте через пробел (имя, фамилия, город, место учёбы, оценки): Илья Иванов Москва МГУ 5 4 4 4 5
#
# Результат:
# Имя - Илья
# Фамилия - Иванов
# Город - Москва
# Место учёбы - МГУ
# Оценки - [5, 4, 4, 4, 5]

user_info = input("Введите информацию о студенте через пробел (имя, фамилия, город, место учёбы, оценки): ").split()
user_info_in_dict = {
    "Имя": user_info[0],
    "Фамилия": user_info[1],
    "Город": user_info[2],
    "Место учёбы": user_info[3],
    "Оценки": [int(grade) for grade in list(user_info[4:])]  # срез 4+ даст нам строку с оценками, list превратит строку в список оценок
    # а с помощью генератора мы сможем превратить str числа в int числа, чтобы с ними можно было при желании работать как с числами
}

for key in user_info_in_dict:
    print(f"{key} - {user_info_in_dict[key]}")

********************************************************************************

# Часть 2. Модуль 6. Видео 1. Задача 3. Контакты
#
# Напишите программу, которая запрашивает у пользователя имя контакта и номер телефона,
# добавляет их в словарь и выводит на экран текущий словарь контактов. Запрос на добавление идёт бесконечно
# (но можно задать своё условие для завершения программы).
# Обеспечьте контроль ввода: если это имя уже есть в словаре, то выведите соответствующее сообщение.
#
# Пример:
# Текущие контакты на телефоне:
# <Пусто>
# Введите имя: Иван
# Введите номер телефона: 100200300
# Текущие контакты на телефоне:
# Иван  100200300
# Введите имя: Лена
# Введите номер телефона: 8005555522
# Текущие контакты на телефоне:
# Иван  100200300
# Лена  8005555522
# Введите имя: Иван
# Ошибка: такое имя уже существует.


telboock_dict = dict()

while True:
    name = input("Введите имя: ")
    if name == 'end':
        print()
        break
    tel = input("Введите номер телефона: ")

    telboock_dict[name] = tel
    print("Текущие контакты на телефоне:")
    print(telboock_dict)
    print()

for key in telboock_dict:
    print(f"{key} : {telboock_dict[key]}\t")


********************************************************************************

# Часть 2. Модуль 6. Видео 2. Задача 1. Склады (слияние словарей)
#
# У мебельного магазина есть два склада, на которых хранятся разные категории товаров по парам «название — количество»:
#
# small_storage = {
#     'гвозди': 5000,
#     'шурупы': 3040,
#     'саморезы': 2000
# }
#
# big_storage = {
#     'доски': 1000,
#     'балки': 150,
#     'рейки': 600
# }
#
# Магазин решил сократить аренду и скинуть все товары в большой склад (big_storage).
# После этого нас попросили реализовать поиск по товарам.
#
# Напишите программу, которая объединяет оба словаря в один (в big_storage),
# затем запрашивает у пользователя название товара и выводит на экран его количество.
# Если такого товара нет, то выводит об этом ошибку.
# Для получения значения используйте метод get.

small_storage = {
    'гвозди': 5000,
    'шурупы': 3040,
    'балки': 1500,    # вставила дл теста
    'саморезы': 2000
}
big_storage = {
    'доски': 1000,
    'балки': 150,
    'рейки': 600
}

big_storage.update(small_storage)
searching_product = input('Введите название искомого товара: ')
print(big_storage.get(searching_product, 'Такого товара нет!'))
print(big_storage)

# ренешие skillbox
# if big_storage.get(user_item, None):
#     print(big_storage[user_item])
# else:
#     print("Такого товара нет!")


********************************************************************************

# Часть 2. Модуль 6. Видео 2. Задача 2. Кризис фруктов
#
# Есть словарь «название фрукта — доход»:
# incomes = {
#     'apple': 5600.20,
#     'orange': 3500.45,
#     'banana': 5000.00,
#     'bergamot': 3700.56,
#     'durian': 5987.23,
#     'grapefruit': 300.40,
#     'peach': 10000.50,
#     'pear': 1020.00,
#     'persimmon': 310.00,
# }
# Напишите программу, которая находит общий доход, затем выводит фрукт с минимальным доходом и удаляет его из словаря.
# Выведите итоговый словарь на экран.
#
# Результат работы программы:
# Общий доход за год составил 35419.34 рублей
# Самый маленький доход у grapefruit. Он составляет 300.4 рублей
#
# Итоговый словарь:
# {'apple': 5600.2, 'orange': 3500.45, 'banana': 5000.0, 'bergamot': 3700.56,
# 'durian': 5987.23, 'peach': 10000.5, 'pear': 1020.0, 'persimmon': 310.0}

def get_key(some_dict, val):    # найти ключ по значению
    for key, value in some_dict.items():
        if val == value:
            return key
    return "key doesn't exist"

incomes = {
    'apple': 5600.20,
    'orange': 3500.45,
    'banana': 5000.00,
    'bergamot': 3700.56,
    'durian': 5987.23,
    'grapefruit': 300.40,
    'peach': 10000.50,
    'pear': 1020.00,
    'persimmon': 310.00,
}

# Моё решение
inc_sum = sum(incomes.values())
inc_min = min(incomes.values())
key_min = get_key(incomes, inc_min)
del incomes[key_min]

print(f"Общий доход за год составил {inc_sum} рублей.\n"
      f"Самый маленький доход у {key_min}. Он составляет {inc_min} рублей.\n"
      f"Итоговый словарь:\n{incomes}")



# Решение 1 skillbox
# result_sum = 0
# min_value = None
# min_name = ""
# for name, value in incomes.items():  # items() позволяет сразу обратиться и к ключам, и а к значениям словаря
#     result_sum += value
#     if min_value is None or min_value > value:
#         min_value = value
#         min_name = name
#
# incomes.pop(min_name)
#
# print(f"Общий доход за год составил {result_sum} рублей")
# print(f"Самый маленький доход у {min_name}. Он составляет {min_value} рублей")
# print("Итоговый словарь:", incomes)


# Решение 2 skillbox с магией
# def get_value(x):
#     return x[1]
#
# result_sum = sum(incomes.values())
# min_name, min_value = min(incomes.items(), key=get_value)
# # При помощи функции и параметра key мы говорим пайтону как именно надо сравнивать между собой элементы
# # Т.к. элементы записаны в таком виде - ('apple': 5600.20), а сравнивать мы хотим по значениям -
# # то нам проосто надо брать для сравнения
# # элементы под индексом 1 (если бы сравнивали по ключам, то индекс надо было бы заменить на 0)
# print(result_sum, min_name, min_value)

********************************************************************************

# Часть 2. Модуль 6. Видео 2. Задача 3. Гистограмма частоты
#
# Лингвистам нужно собрать данные о частоте букв в тексте, исходя из этих данных будет строиться гистограмма частоты букв.
#
# Напишите программу, которая получает сам текст и считает, сколько раз в строке встречается каждый символ.
# На экран нужно вывести содержимое в виде таблицы, отсортированное по алфавиту, а также максимальное значение частоты.
#
# Пример:
# Введите текст: Здесь что-то написано
#   : 2
# - : 1
# З : 1
# а : 2
# д : 1
# е : 1
# и : 1
# н : 2
# о : 3
# п : 1
# с : 2
# т : 2
# ч : 1
# ь : 1
# Максимальная частота: 3

text = input('Введите текст: ').lower()

sym_dict = dict()

for sym in text:
    sym_dict[sym] = text.count(sym)

for key in sorted(sym_dict.keys()):
    print(f"{key} : {sym_dict[key]}")

print(f"Максимальная частота: {max(sym_dict.values())}")


********************************************************************************

# Часть 2. Модуль 6. Видео 3. Задача 1. Заказ фруктов
#
# order = {'apple': 2,
#          'banana': 3,
#          'pear': 1,
#          'watermelon': 10,
#          'chocolate': 5}
# (ключи - названия товаров, значения - необходимое количество кг.)
#
# При помощи метода get и установки значения по умолчанию проверьте,
# есть ли товар на складе и получите его цену (если товара нет,
# то по умолчанию получите 0). Посчитайте итоговую выручку компании по имеющимся товарам.
#
# incomes = {
#     'apple': 5600.20,
#     'orange': 3500.45,
#     'banana': 5000.00,
#     'bergamot': 3700.56,
#     'durian': 5987.23,
#     'grapefruit': 300.40,
#     'peach': 10000.50,
#     'pear': 1020.00,
#     'persimmon': 310.00,
# }
# (ключи - названия товаров, значения - цена за 1 кг.)
#
# Напишите программу, которая суммирует стоимость (цена * количество)
# всех заказанных товаров и выведите итоговую сумму в консоль.
#
order = {'apple': 2,
         'banana': 3,
         'pear': 1,
         'watermelon': 10,
         'chocolate': 5}

incomes = {
    'apple': 5600.20,
    'orange': 3500.45,
    'banana': 5000.00,
    'bergamot': 3700.56,
    'durian': 5987.23,
    'grapefruit': 300.40,
    'peach': 10000.50,
    'pear': 1020.00,
    'persimmon': 310.00,
}

# решение skillbox:
result_sum = 0
for fruit_name in order:
    cost = incomes.get(fruit_name, 0) * order[fruit_name]
    result_sum += cost
print("Итоговая стоимость товаров из заказа составляет:", result_sum)

# Моё решение
# total = 0
# for key in order.keys():
#     if key in incomes.keys():
#         total += order[key] * incomes[key]
#         print(order[key] * incomes[key])
#     else:
#         print(0)
# print(f"Итого к оплате: {total}")




********************************************************************************

# Часть 2. Модуль 6. Видео 3. Задача 2. Игроки
#
# Есть готовый словарь игроков, у каждого игрока есть имя, команда, в которой он играет,
# а также его текущий статус: отдыхает, тренируется или путешествует:
#
# players_dict = {
#     1: {'name': 'Vanya', 'team': 'A', 'status': 'Rest'},
#     2: {'name': 'Lena', 'team': 'B', 'status': 'Training'},
#     3: {'name': 'Maxim', 'team': 'C', 'status': 'Travel'},
#     4: {'name': 'Egor', 'team': 'C', 'status': 'Rest'},
#     5: {'name': 'Andrei', 'team': 'A', 'status': 'Training'},
#     6: {'name': 'Sasha', 'team': 'A', 'status': 'Rest'},
#     7: {'name': 'Alina', 'team': 'B', 'status': 'Rest'},
#     8: {'name': 'Masha', 'team': 'C', 'status': 'Travel'}
# }
#
# Напишите программу, которая выводит на экран вот такие данные в разных строчках:
# Все члены команды из команды А, которые отдыхают.
# Все члены команды из группы B, которые тренируются.
# Все члены команды из команды C, которые путешествуют.

players_dict = {
    1: {'name': 'Vanya', 'team': 'A', 'status': 'Rest'},
    2: {'name': 'Lena', 'team': 'B', 'status': 'Training'},
    3: {'name': 'Maxim', 'team': 'C', 'status': 'Travel'},
    4: {'name': 'Egor', 'team': 'C', 'status': 'Rest'},
    5: {'name': 'Andrei', 'team': 'A', 'status': 'Training'},
    6: {'name': 'Sasha', 'team': 'A', 'status': 'Rest'},
    7: {'name': 'Alina', 'team': 'B', 'status': 'Rest'},
    8: {'name': 'Masha', 'team': 'C', 'status': 'Travel'}
}
# Мое решение
# conditions = {'A': 'Rest', 'B': 'Training', 'C': 'Travel'}
# team_members = [player['name'] for player in players_dict.values() for c_key in conditions
#                     if player['team'] == c_key and player['status'] == conditions[c_key]]
# print(team_members)

# Cформируем дополнительные словарь и список, чтобы автоматизировать процесс проверки условия:
help_dict = {"Rest": "отдыхают",
             "Training": "тренируются",
             "Travel": "путешествуют"}

team_order = ["A", "B", "C"]

# Запустим цикл по словарю состояний и одновременно будем вести счёт состояний,
# чтобы на каждой итерации выбирать одну из команд:
index = 0
for state in help_dict:
    print(f"Все члены команды из команды {team_order[index]}, которые {help_dict[state]}:")
    for _, player in players_dict.items():
        if player["status"] == state and player["team"] == team_order[index]:
            print(player["name"])
    index += 1




********************************************************************************

# Часть 2. Модуль 6. Видео 4. Задача 1. Пунктуация
#
# Напишите программу, которая считает количество уникальных знаков пунктуации в символьной строке.
# К знакам пунктуации относятся символы из набора ".,;:!?". Набор должен храниться в виде множества.
#
# Пример:
# Введите строку: Я! Есть. Грут?! Я, Грут и Есть.
# Количество знаков пунктуации: 4

symbols = set(".,;:!?")
text = set(input('Введите строку: '))
print(f"Количество знаков пунктуации: {len(text & symbols)}")




********************************************************************************

# Часть 2. Модуль 6. Видео 4. Задача 2. Семинар
#
# На одном семинаре по теории множеств нужно показать наглядный пример, как эти множества работают.
# Для начала было сгенерировано два набора чисел:
#
# nums_1 = [29, 17, 10, 15, 13, 22, 12, 22, 7, 24, 26, 3, 11, 2, 3, 16, 19, 21, 2, 3, 8, 27, 2, 17, 2, 20, 12, 21, 3, 1]
# nums_2 = [16, 21, 30, 24, 5, 7, 23, 13, 11, 5, 21, 5, 19, 9, 12, 9, 15, 16, 29, 8, 16, 1, 22, 15, 16, 9, 1, 13, 21, 21]
#
# Вас попросили написать программу, которая будет наглядно демонстрировать работу со множествами с помощью этих чисел.
#
# Напишите программу, которая преобразует списки во множества и убирает повторяющиеся элементы.
# Затем удаляет минимальный элемент из каждого множества и добавляет туда случайное число
# в диапазоне от 100 до 200. Затем выполните следующие действия со множествами:
# Вывести все элементы множеств (объединение).
# Вывести только общие элементы (пересечение).
# Вывести элементы, входящие в nums_2, но не входящие в nums_1.
#
# Пример результата:
# 1-е множество: {1, 2, 3, 7, 8, 10, 11, 12, 13, 15, 16, 17, 19, 20, 21, 22, 24, 26, 27, 29}
# 2-е множество: {1, 5, 7, 8, 9, 11, 12, 13, 15, 16, 19, 21, 22, 23, 24, 29, 30}
# Минимальный элемент 1-го множества: 1
# Минимальный элемент 2-го множества: 1
# Случайное число для 1-го множества: 126
# Случайное число для 2-го множества: 169
# Объединение множеств: {2, 3, 5, 7, 8, 9, 10, 11, 12, 13, 15, 16, 17, 19, 20, 21, 22, 23, 24, 26, 27, 29, 30, 169, 126}
# Пересечение множеств: {7, 8, 11, 12, 13, 15, 16, 19, 21, 22, 24, 29}
# Элементы, входящие в nums_2, но не входящие в nums_1: {5, 9, 169, 23, 30}

import random
nums_1 = set([random.randint(1, 30) for _ in range(30)])
nums_2 = set([random.randint(1, 30) for _ in range(20)])
print(f"{nums_1},\n{nums_2}\n"
      f"\nМинимальный элемент 1-го множества (удаляем): {min(nums_1)}"
      f"\nМинимальный элемент 2-го множества (удаляем): {min(nums_2)}")

nums_1.discard(min(nums_1))
nums_2.discard(min(nums_2))

a1 = random.randint(100, 200)
a2 = random.randint(100, 200)
print(f"{nums_1},\n{nums_2}\n"
      f"\nСлучайное число для 1-го множества: {a1}"
      f"\nСлучайное число для 2-го множества: {a2}")

nums_1.add(a1)
nums_2.add(a2)
print(f"{nums_1},\n{nums_2}\n"     
      f"\nОбъединение множеств: {nums_1 | nums_2}"
      f"\nПересечение множеств: {nums_1 & nums_2}"
      f"\nЭлементы, входящие в nums_2, но не входящие в nums_1: {nums_2 - nums_1}")




********************************************************************************

# Часть 2. Модуль 6. Видео 4. Задача 3. Различные цифры
#
# Напишите программу, которая находит все различные цифры в символьной строке. Для решения используйте множество
# (цифры будут различные, и поиск во множестве намного быстрее, чем в списке).
#
# Подсказка: можно использовать вот такое сравнение '0'<=x<='9'
#
# Пример:
# Введите строку: ab1n32kz2
# Различные цифры строки: 123


# Моё решение:
text = set(input("Введите строку: "))
text_int = [elem for elem in text if elem.isdigit()]
print(f"Различные цифры строки: {''.join(text_int)}")



# # Решение skillbox 1
# text_unique = set(text)
# result = text_unique & set("0123456789")
# print(''.join(result))
#
#
#
# # Решение через цикл и сравнение skillbox 2:
# new_result = set()
# for symbol in text:
#     if '0' <= symbol <= '9':
#         new_result.add(symbol)
# print(''.join(new_result))



********************************************************************************

# tuple = (1, 2, 3) # Есть неизменяемый объект (кстати, попробуйте потом повторить этот код с изменяемым объектом)
# hash_value = hash(tuple) # Применим к этому объекту функцию hash
# print(hash_value) # Проверим, что получилось (бессмысленный набор чисел)
# hash_value_2 = hash(tuple) # Попробуем ещё раз
# print(hash_value_2) # Опять набор чисел
# print(hash_value == hash_value_2) # И он в точности равен первому

tuple = (1, 2, 3)     # Возьмём тот же кортеж
print(hash(tuple))     # Его хеш при каждом запуске может отличаться
# При моём запуске хеш был равен числу 529344067295497451
hash_dict = {(1, 2, 3): 'hello'}     # Если я захочу создать словарь с этим кортежем,
# то «под капотом» будет создан массив, в котором по индексу 529344067295497451
# будет храниться пара (1, 2, 3) и 'hello'

********************************************************************************

goods = {
    'Лампа': '12345',
    'Стол': '23456',
    'Диван': '34567',
    'Стул': '45678',
}

store = {
    '12345': [
        {'quantity': 27, 'price': 42},
            ],
    '23456': [
        {'quantity': 22, 'price': 510},
        {'quantity': 32, 'price': 520},
            ],
    '34567': [
        {'quantity': 2, 'price': 1200},
        {'quantity': 1, 'price': 1150},
            ],
    '45678': [
        {'quantity': 50, 'price': 100},
        {'quantity': 12, 'price': 95},
        {'quantity': 43, 'price': 97},
            ],
}


for i_title, i_code in goods.items():
    total_quantity = 0
    total_cost = 0
    for i_good in store[i_code]:
        total_quantity += i_good['quantity']
        total_cost += i_good['price'] * i_good['quantity']
    print('{title} - {quantity} шт., стоимость {cost} руб.'.format(
        title=i_title,
        quantity=total_quantity,
        cost=total_cost
    ))

********************************************************************************

# Часть 2. Модуль 7. Практическая работа. Задача 1. Ревью кода
#
# В задании был словарь из трёх студентов. Необходимо:
#
# Вывести на экран список пар «ID студента — возраст».
# Написать функцию, которая принимает в качестве аргумента словарь и возвращает два значения:
# полный список интересов всех студентов и общую длину всех фамилий студентов.
# Далее в основном коде вызывается функция, значения присваиваются отдельным переменным и выводятся на экран.
#
# Код выдает верный результат:
#
# students = {
# 1: {
# 'name': 'Bob',
# 'surname': 'Vazovski',
# 'age': 23,
# 'interests': ['biology, swimming']
# },
# 2: {
# 'name': 'Rob',
# 'surname': 'Stepanov',
# 'age': 24,
# 'interests': ['math', 'computer games', 'running']
# },
# 3: {
# 'name': 'Alexander',
# 'surname': 'Krug',
# 'age': 22,
# 'interests': ['languages', 'health food']
# }
# }
#
# def f(dict):
# lst = []
# string = ''
# for i in dict:
# lst += (dict[i]['interests'])
# string += dict[i]['surname']
# cnt = 0
# for s in string:
# cnt += 1
# return lst, cnt
#
# pairs = []
# for i in students:
# pairs += (i, students[i]['age'])
#
# my_lst = f(students)[0]
# l = f(students)[1]
# print(my_lst, l)

# Перепишите этот код так, чтобы он был максимально pythonic. Убедитесь, что программа верно работает.
# Проверки на существование записей в словаре не обязательны, но приветствуются.
#
# Результат работы программы:
# Список пар «ID студента — возраст»: [(1, 23), (2, 24), (3, 22)]
# Полный список интересов всех студентов:
# {'running', 'computer games', 'math', 'languages', 'biology, swimming', 'health food'}
# Общая длина всех фамилий студентов: 20
#
# Советы и рекомендации
# Имена переменных и функций должны быть полезными и понятными
# (не стоит использовать одиночные буквы, непонятные сокращения).
# Названия не должны пересекаться с уже существующими в Python объектами
# (например, лучше не называть свою переменную print или list).
#
# Попробуйте найти лишние действия в коде. Если вы сможете получить нужный результат меньшим количеством действий,
# то не нужно заставлять Python выполнять лишние действия.
# Также нет необходимости заставлять Python выполнять одни и те же действия над одним и тем же объектом
# (например, вызывать функцию с одними и теми же входными данными несколько раз).
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d
# Новый код более оптимизирован и чист по стилю программирования (pythonic), чем старый.

students = {
    1: {'name': 'Bob', 'surname': 'Vazovski', 'age': 23, 'interests': ['biology, swimming']},
    2: {'name': 'Rob', 'surname': 'Stepanov', 'age': 24, 'interests': ['math', 'computer games', 'running']},
    3: {'name': 'Alexander', 'surname': 'Krug', 'age': 22, 'interests': ['languages', 'health food']}
}
def interests_and_length_surnames(some_dict):
    some_list = []
    length_surnames = 0

    for index in some_dict:
        some_list.append(some_dict[index]['interests'])
        length_surnames += len(some_dict[index]['surname'])

    return some_list, length_surnames


print("ID студента — возраст:")
for student in students.values():
    print(f"{student['name']} {student['surname']} - {student['age']}")

list_interests, length_surnames = interests_and_length_surnames(students)
print(f"\nПолный список интересов всех студентов:\n{list_interests}\n"
      f"\nОбщая длина всех фамилий студентов: {length_surnames}")


********************************************************************************

# Часть 2. Модуль 7. Практическая работа. Задача 2. Универсальная программа
#
# Напишите функцию, возвращающую список элементов итерируемого объекта (кортежа, строки, списка, словаря),
# у которых индекс — это простое число.
#
# Для проверки на простое число напишите отдельную функцию is_prime.
#
# Необязательное усложнение: сделайте так, чтобы основная функция состояла только из оператора return
# и так же возвращала список.
#
# Пример вызова функции:
# print(crypto([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))
# Ответ в консоли: [2, 3, 5, 7]
# Пример вызова функции:
# print(crypto('О Дивный Новый мир!'))
# Ответ в консоли: ['Д', 'и', 'н', 'й', 'в', 'й', 'р']
#
# Советы и рекомендации
# Для нумерации элементов используйте функцию enumerate. Это позволит работать одинаково со всеми структурами данных.
#
# Что оценивается
# Результат вычислений корректен.
# Весь функционал программы описан в функциях.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

import random
def is_prime(num):

    flag = False
    for k in range(2, num):
        if num % k == 0:
            flag = True

    if flag == True:
        return False
    else:
        return True

def elem_from_prime(some_object):
    if isinstance(some_object, dict):
        list_elem_from_prime = [val for key, val in some_object.items() if is_prime(key) and key >= 2]
    else:
        list_elem_from_prime = [el for i, el in enumerate(some_object) if is_prime(i) and i >= 2]
    return list_elem_from_prime

if __name__ == '__main__':
    test_cases = [
        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 'a', 'b', 'c', 'd', 'e', 'f'),
        'О Дивный Новый мир!',
        {0: 'О', 1: ' ', 2: 'Д', 3: 'и', 4: 'в', 5: 'н', 6: 'ы', 7: 'й', 8: ' ', 9: 'Н', 10: 'о'}
    ]

    for some_object in test_cases:
        result = elem_from_prime(some_object)
        print(result)







********************************************************************************

# Часть 2. Модуль 7. Практическая работа. Задача 3. Игроки
#
# У вас есть словарь игроков, которые участвовали в трёх видах спорта. В словаре хранятся пары «ФИ — очки»:
# players = {
# ("Ivan", "Volkin"): (10, 5, 13),
# ("Bob", "Robbin"): (7, 5, 14),
# ("Rob", "Bobbin"): (12, 8, 2)
# }
# Напишите программу, которая объединяет ключ словаря со значением в один кортеж, и выведите результат на экран.
# Постарайтесь использовать как можно более эффективное решение.
#
# Результат работы программы:
# [('Ivan', 'Volkin', 10, 5, 13), ('Bob', 'Robbin', 7, 5, 14), ('Rob', 'Bobbin', 12, 8, 2)]
#
# Советы и рекомендации
# Не забывайте, что кортежи можно складывать (а + б). Это приведёт к объединению всех элементов двух кортежей.
# Для упрощения кода хорошо подходят генераторы списка.
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует указанному в задаче.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

players = {
    ("Ivan", "Volkin"): (10, 5, 13),
    ("Bob", "Robbin"): (7, 5, 14),
    ("Rob", "Bobbin"): (12, 8, 2)
}
list_players = [(key + val) for key, val in players.items()]
print(list_players)


********************************************************************************

# Часть 2. Модуль 7. Практическая работа. Задача 4. По парам
#
# Напишите программу, которая инициализирует список из 10 случайных целых чисел,
# а затем делит эти числа на пары кортежей внутри списка. Выведите результат на экран.
# Дополнительно: решите задачу несколькими способами.
# Пример:
# Оригинальный список: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# Новый список: [(0, 1), (2, 3), (4, 5), (6, 7), (8, 9)]
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Переменные и функции имеют значимые имена, не только a, b, c, d.
# Для решения используются list comprehensions.

import random

numbers = [random.randint(0, 100) for _ in range(10)]
print(f"Оригинальный список: {numbers}")

list_tup = [tuple(numbers[i:i+2]) for i in range(0, 10, 2)]
print(f"Новый список 1: {list_tup}")

numbers2 = list(zip([el for i, el in enumerate(numbers) if i % 2 == 0], [el for i, el in enumerate(numbers) if i % 2 != 0]))
print(f"Новый список 2: {numbers2}")


********************************************************************************

# Часть 2. Модуль 7. Практическая работа. Задача 5. Функция сортировки
#
# Напишите функцию, которая сортирует по возрастанию кортеж, состоящий из целых чисел,
# и возвращает его отсортированным. Если хотя бы один элемент не является целым числом,
# то функция возвращает исходный кортеж.
# Основной код оставьте пустым или закомментированным (используйте его только для тестирования).
#
# Пример вызова функции:
# tpl = (6, 3, -1, 8, 4, 10, -5)
# print(tpl_sort(tpl))
# Ответ в консоли: (-5, -1, 3, 4, 6, 8, 10)
#
# Что оценивается
# Результат вычислений корректен.
# Весь функционал программы описан в виде функции.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

def tpl_sort(tpl):
    return tuple(sorted(list(tpl)))

if __name__ == '__main__':
    test_cases = [
        (6, 3, -1, 8, 4, 10, -5)
    ]

    for tpl in test_cases:
        print(tpl_sort(tpl))

********************************************************************************

# Часть 2. Модуль 7. Практическая работа. Задача 6. Контакты — 3
#
# Напишите программу, которая бесконечно запрашивает у пользователя действие,
# которое он хочет совершить: добавить контакт или найти человека в списке контактов по фамилии.
#
# Действие «добавить контакт»: программа запрашивает имя и фамилию контакта,
# затем номер телефона, добавляет их в словарь и выводит на экран текущий словарь контактов.
# Если этот человек уже есть в словаре, то выводится соответствующее сообщение.
#
# Действие «поиск человека по фамилии»: программа запрашивает фамилию
# и выводит все контакты с такой фамилией и их номера телефонов.
# Поиск не должен зависеть от регистра символов.
#
# Пример работы программы:
#
# Введите номер действия:
# Добавить контакт.
# Найти человека.
#     При выборе действия 1:
# Введите имя и фамилию нового контакта (через пробел): Иван Сидоров
# Введите номер телефона: 888
# Текущий словарь контактов: {('Иван', 'Сидоров'): 888}
# Введите номер действия:
# Добавить контакт
# Найти человека
#     При выборе действия 1:
# Введите имя и фамилию нового контакта (через пробел): Иван Сидоров
# Такой человек уже есть в контактах.
# Текущий словарь контактов: {('Иван', 'Сидоров'): 888}
# Введите номер действия:
# Добавить контакт
# Найти человека
#     При выборе действия 1:
# Введите имя и фамилию нового контакта (через пробел): Алиса Петрова
# Введите номер телефона: 999
# Текущий словарь контактов: {('Иван', 'Сидоров'): 888, ('Алиса', 'Петрова'): 999}
# Введите номер действия:
# Добавить контакт
# Найти человека
#     При выборе действия 2:
# Введите фамилию для поиска: Сидоров
# Иван Сидоров 888
# Введите номер действия:
# Добавить контакт
# Найти человек
# ...
#
# Что оценивается
# Результат вычислений корректен.
# Input содержит корректные приглашения для ввода.
# Формат вывода соответствует примеру.
# Основной функционал (действия) описан в отдельных функциях.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

def print_dict(some_dict):
    for key, val in some_dict.items():
        print(f"{key}: {val}")

phonebook = dict()
while True:
    print('\nВыберите действие: добавить контакт «add» или найти человека в списке контактов по фамилии «search»: ')
    user_action = input()
    if user_action == 'add':
        name = input('Введите имя: ').title()
        surname = input('Введите фамилию: ').title()
        contact = name + ' ' + surname
        if contact in phonebook:
            change = input('Этот человек уже есть в списке контактов. Заменить номер? «да» / «нет»: ')
            if change == 'да':
                tel = input('Введите номер телефона: ')
                phonebook[contact] = tel
            else:
                continue
        else:
            tel = input('Введите номер телефона: ')
            # добавляет их в словарь
            phonebook[contact] = tel
        # выводит на экран текущий словарь контактов
        print('\nВаши контакты:')
        for key, val in phonebook.items():
            print(f"{key}: {val}")
    elif user_action == 'search':
        search_surname = input('Введите фамилию: ').title()
        for key in phonebook.keys():
            if search_surname in key:
                print(f"{key}: {phonebook[key]}")
# и выводит все контакты с такой фамилией и их номера телефонов.')






********************************************************************************

# Часть 2. Модуль 7. Практическая работа. Задача 7. Своя функция zip
#
# Даны строка и кортеж из чисел. Напишите программу, которая создаёт генератор из пар кортежей «символ
# — число». Затем выведите на экран сам генератор и кортежи.
#
# Пример:
# Строка: abcd
# Кортеж чисел: (10, 20, 30, 40)
# Результат:
# <generator object <genexpr> at 0x00000204A4234048>
# ('a', 10)
# ('b', 20)
# ('c', 30)
# ('d', 40)
#
# Дополнительно: создайте полный аналог функции zip — сделайте так, чтобы программа
# работала с любыми итерируемыми типами данных.
#
# Подсказка
# Ранее мы проходили List comprehensions — по сути, генератор списка.
# В этом случае, чтобы создать генератор, попробуйте поэкспериментировать с генератором списка.
#
# Пример:
# print([i for i in range(10)])
# print((i for i in range(10)))
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Основной функционал описан в отдельной функции или функциях.
# Переменные и функции имеют значимые имена, не только a, b, c, d.

import random

some_string = "".join([random.choice([chr(x) for x in range(97, 122)]) for _ in range(random.randint(1, 10))])
some_tuple = tuple(random.randint(0, 100) for _ in range(random.randint(1, 10)))
# print(some_string, some_tuple)

n = min(len(some_string), len(some_tuple))
gen_tup = ((some_string[i], some_tuple[i]) for i in range(n))

print(gen_tup)
for el in gen_tup:
    print(el)


********************************************************************************

# Часть 2. Модуль 7. Видео 2. Задача 1. Создание кортежей
#
# Заполните один кортеж десятью случайными целыми числами от 0 до 5 включительно.
# Также заполните второй кортеж числами от −5 до 0.
# Объедините два кортежа, создав тем самым третий кортеж.
# С помощью метода кортежа определите в нём количество нулей.
# Выведите на экран третий кортеж и количество нулей в нём.

import random

def randint_tuple(a, b, n):
    return tuple(random.randint(a, b) for _ in range(n))

def unit_tuple(tup_1:tuple, tup_2:tuple):
    unit_tup = tup_1 + tup_2
    return unit_tup

def zero_tuple(tup: tuple):
    return tup.count(0)

if __name__ == '__main__':
    result_1 = randint_tuple(0, 5, 10)
    result_2 = randint_tuple(-5, 0, 10)
    result_3 = unit_tuple(result_1, result_2)
    result_4 = zero_tuple(result_3)

    print(f"Рандомный кортеж от 0 до 5: {result_1}\n"
          f"Рандомный кортеж от -5 до 0:{result_2}\n"
          f"Объединенные кортежи: {result_3}\n"
          f"Кол-во нулей в объединенном кортеже: {result_4}\n")


********************************************************************************

# Часть 2. Модуль 7. Видео 2. Задача 2. Цилиндр
#
# Пользователь вводит два значения: радиус и высоту.
# Напишите функцию для расчёта площади боковой поверхности цилиндра и его полной площади.
# Функция должна возвращать два эти значения.
# После этого в основной программе выводятся оба ответа в две строки.
#
# Площадь боковой поверхности (r — радиус, h — высота):
# side = 2*Pi * R * h
# Полная площадь (S — площадь круга):
# full = side + 2 * S
import math


def cylinder_surface_area(r: float, h: float) -> tuple:

    s_surface = 2 * math.pi * r * h
    s_circle = 2 * math.pi * r**2
    s_full = s_surface + 2 * s_circle

    return s_surface, s_full


if __name__ == '__main__':
    radius = float(input('Введите радиус: '))
    hight = float(input('Введите высоту: '))

    s_surface, s_full = cylinder_surface_area(radius, hight)

    print(f"Площадь боковой поверхности: {s_surface:.2f}, Площадь всей поверхности: {s_full:.2f}")


# Решение skillbox
# def cylinder_math(r, height):
#     side = 2 * math.pi * r * height
#     full = side + 2 * math.pi * r ** 2        #ошибка в формуле???
#     return side, full
#
#
# bot_area, full_area = cylinder_math(radius_in, height_in)
# print(bot_area, full_area)


********************************************************************************

# Часть 2. Модуль 7. Видео 2. Задача 3. Неправильный код
#
# Дан код, в котором должно происходить следующее: изначально есть кортеж из пяти чисел.
# Затем вызывается функция, которая получает на вход кортеж чисел, генерирует случайный индекс
# и случайное значение, а затем по этим индексу и значению меняет сам кортеж.
# Функция должна возвращать кортеж и случайное значение.
#
# В основном коде функция используется два раза, и на экран два раза выводится
# новый кортеж и случайное значение.
# Причём второй раз выводится сумма первого случайного значения и второго.
# Однако код, который вам дали, оказался нерабочим. Исправьте его в соответствии с описанием.
#
# import random
#
# def change(nums):
#     index = random.randint(0, 5)
#     value = random.randint(100, 1000)
#     nums[index] = value
#     return nums, value
#
# my_nums = 1, 2, 3, 4, 5
# new_nums, rand_val = change(my_nums)
# print(new_nums, rand_val)
# new_nums = change(new_nums)
# rand_val += change(new_nums)
# print(new_nums, rand_val)

import random

def modified_tuple(tup):
    ind = random.randint(0, len(tup) - 1)
    val = random.randint(100, 1000)
    tup = list(tup)
    tup[ind] = val
    return tuple(tup), val

some_tup = (1, 2, 3, 4, 5)
new_tup, val = modified_tuple(some_tup)
print(f"Измененный кортеж: {new_tup}\n"
      f"Новый элемент: {val}\n")

new_tup_2, val_2 = modified_tuple(new_tup)
val += val_2

print(f"Измененный кортеж 2: {new_tup_2}\n"
      f"Cумма первого случайного значения и второго: {val}\n")


********************************************************************************

# Часть 2. Модуль 7. Видео 3. Задача 1. Саботаж!
#
# Пользователь вводит строку. Напишите программу, которая проходит по строке и выводит в консоль индексы символа ~.
# Для решения этой задачи (и остальных тоже) используйте функцию enumerate.
#
# Пример:
# Строка: so~mec~od~e
# Ответ: 2 6 9
#
def search_sym(text, sym):
    return [str(i) for i, el in enumerate(text) if el == sym]

text = input('Введите строку: ')
answer = " ".join(search_sym(text, '~'))
print(f"Ответ: {answer}")


********************************************************************************

# Часть 2. Модуль 7. Видео 3. Задача 2. Словари из списков
#
# Создайте два списка, в каждом из которых лежит 10 случайных букв алфавита (могут повторяться).
# Затем для каждого списка создайте словарь из пар «индекс — значение» и выведите оба словаря на экран.
#
# Подсказка: random
#
# Пример:
# Первый список: ['й', 'р', 'с', 'г', 'а', 'а', 'т', 'ж', 'е', 'к']
# Второй список: ['д', 'а', 'а', 'в', 'т', 'ж', 'р', 'б', 'й', 'р']
# Первый словарь: {0: 'й', 1: 'р', 2: 'с', 3: 'г', 4: 'а', 5: 'а', 6: 'т', 7: 'ж', 8: 'е', 9: 'к'}
# Второй словарь: {0: 'д', 1: 'а', 2: 'а', 3: 'в', 4: 'т', 5: 'ж', 6: 'р', 7: 'б', 8: 'й', 9: 'р'}
#
# Так как у нас нет функции, которая генерирует случайную букву, то нам надо либо создаст список всех букв и выбирать из них случайные
# Либо нам нужно генерировать случайное число, которое можно преобразовать в букву по таблице Unicodе.

# Первый вариант проще, можете реализовать его самостоятельно, второй посложнее, реализуем его вместе:

import random
# alpha = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
# alpha_list_1 = [random.choice(alpha) for _ in range(10)]
# alpha_list_2 = [random.choice(alpha) for _ in range(10)]
# print(alpha_list_1, alpha_list_2)

print(ord("а"), ord("я"))  # посмотрим с какого числа начинаются русские буквы и где заканчиваются (ё искать не будем)


def gen_alpha_dict():
    alpha_list = [chr(random.randint(1072, 1103)) for _ in range(10)]
    alpha_dict = {}
    for i, el in enumerate(alpha_list):
        alpha_dict[i] = el
    return alpha_list, alpha_dict

alpha_list_1, alpha_dict_1 = gen_alpha_dict()
alpha_list_2, alpha_dict_2 = gen_alpha_dict()

print(f"Первый список: {alpha_list_1}\n"
      f"Второй список: {alpha_list_2}\n"
      f"Первый словарь: {alpha_dict_1}\n"
      f"Второй словарь: {alpha_dict_2}")


********************************************************************************

# Часть 2. Модуль 7. Видео 3. Задача 3. Универсальная программа
#
# Напишите функцию, которая возвращает список из элементов итерируемого объекта
# (кортежа, строки, списка, словаря), у которых индекс чётный.
#
# Пример 1:
# Допустим, есть такая строка: 'О Дивный Новый мир!'
# Результат: ['О', 'Д', 'в', 'ы', ' ', 'о', 'ы', ' ', 'и', '!']
#
# Пример 2:
# Допустим, есть такой список: [100, 200, 300, 'буква', 0, 2, 'а']
# Результат: [100, 300, 0, 'а']
#
# Примечание: для проверки типа можно использовать функцию isinstance(<элемент>, <тип данных>),
# которая возвращает True, если элемент принадлежит к этому типу данных, и возвращает False в противном случае.

def even_index(it_obj):
    if isinstance(it_obj, dict):
        it_obj = it_obj.values()
    return [el for i, el in enumerate(it_obj) if i % 2 == 0]



if __name__ == '__main__':
    test_cases = [
        'О Дивный Новый мир!',
        [100, 200, 300, 'буква', 0, 2, 'а'],
        {0: 'четный', 1: 'нечетный', 2: 'четный'},
        ('0', '1', '2', 'нечетный', 'четный')
    ]

    for it_elem in test_cases:
        result = even_index(it_elem)
        print(result)

# решение skillbox
# def return_even_elements(data):
#     result = []
#     if isinstance(data, dict):
#         data = data.values()
#     for index, value in enumerate(data):
#         if index % 2 == 0:
#             result.append(value)
#     return result
#
#
# print(return_even_elements('О Дивный Новый мир!'))
# print(return_even_elements([100, 200, 300, 'буква', 0, 2, 'а']))
# print(return_even_elements({0: 'е', 1: 'о', 2: 'ч', 3: 'ы', 4: 'в', 5: 'н', 6: 'д', 7: 'а', 8: 'ш', 9: 'ц'}))

********************************************************************************

# Часть 2. Модуль 7. Видео 4. Задача 1. Кризис миновал
#
# Закупки грейпфрутов прекратились, и кризис в торговой компании закончился.
# И теперь можно вернуться к обыденным делам.
# Однако внезапно вы обнаружили, что старый скрипт, который выводит данные о фруктах,
# куда-то потерялся. Необходимо его восстановить.
#
# Дан словарь с парами «название фрукта — цена»:
# incomes = {
#     'apple': 5600.20,
#     'orange': 3500.45,
#     'banana': 5000.00,
#     'bergamot': 3700.56,
#     'durian': 5987.23,
#     'peach': 10000.50,
#     'pear': 1020.00,
#     'persimmon': 310.00,
# }
#
# Вывести на экран словарь в следующем виде:
# apple -- 5600.2
# orange -- 3500.45
# banana -- 5000.0
# bergamot -- 3700.56
# durian -- 5987.23
# peach -- 10000.5
# pear -- 1020.0
# persimmon -- 310.0
# Не используйте обращение по ключу словаря.

incomes = {
    'apple': 5600.20,
    'orange': 3500.45,
    'banana': 5000.00,
    'bergamot': 3700.56,
    'durian': 5987.23,
    'peach': 10000.50,
    'pear': 1020.00,
    'persimmon': 310.00,
}

for prod, price in incomes.items():
    print(f"{prod} -- {price}")


********************************************************************************

# Часть 2. Модуль 7. Видео 4. Задача 2. Сервер
#
# У вас есть данные о сервере, которые хранятся в виде вот такого словаря:
#
# server_data = {
#     "server": {
#         "host": "127.0.0.1",
#         "port": "10"
#     },
#     "configuration": {
#         "access": "true",
#         "login": "Ivan",
#         "password": "qwerty"
#     }
# }
#
# Напишите программу, которая выводит для пользователя эти данные так же красиво и понятно, как они представлены в словаре.
#
# Результат работы программы:
# server:
#     host: 127.0.0.1
#     port: 10
# configuration:
#     access: true
#     login: Ivan
#     password: qwerty

server_data = {
    "server": {
        "host": "127.0.0.1",
        "port": "10"
    },
    "configuration": {
        "access": "true",
        "login": "Ivan",
        "password": "qwerty"
    }
}

for data_key, data_val in server_data.items():
    print(f"{data_key}:")
    for key_data_val, val_data_val in data_val.items():
        print(f"    {key_data_val}: {val_data_val}")


# решение skillbox
# for tag, info in server_data.items():
#     print(tag + ":", "\n")
#     for key, value in info.items():
#         print("\t" + key + ": " + value, "\n")

********************************************************************************

# Часть 2. Модуль 7. Видео 4. Задача 3. В одну строчку
#
# Нашему другу дали задачу: «Есть словарь, в котором ключи — это числа от 0 до 4, а значения ключей —
# числа 0, 100, 144, 20 и 19 соответственно. Нужно написать программу, которая выводит список тех значений,
# у которых ключ делится на 2. Причём программа должна быть в одну строчку.» Программа у друга работает,
# но её не приняли, так как в ней не используется правило «не повторяйся» — это когда части кода не повторяются.
# Помогите другу исправить решение задачи так, чтобы код в строчке не повторялся.
#
# Решение друга:
#
# print([{0: 0, 1: 100, 2: 144, 3: 20, 4: 19}[i_key] for i_key in {0: 0, 1: 100, 2: 144, 3: 20, 4: 19} if i_key % 2 == 0])

print([el_val for i_key, el_val in {0: 0, 1: 100, 2: 144, 3: 20, 4: 19}.items() if i_key % 2 == 0])

********************************************************************************

# Часть 2. Модуль 7. Видео 5. Задача 1. Паспортные данные
#
# В базе данных поликлиники хранятся паспортные данные людей.
# Хранение реализовано с помощью словаря, состоящего из пар «Серия и номер паспорта — фамилия и имя».
# Серия и номер — составной ключ, а фамилия и имя — составное значение.
#
# data = {
#     (5000, 123456): ('Иванов', 'Василий'),
#     (6000, 111111): ('Иванов', 'Петр'),
#     (7000, 222222): ('Медведев', 'Алексей'),
#     (8000, 333333): ('Алексеев', 'Георгий'),
#     (9000, 444444): ('Георгиева', 'Мария')
# }
#
# Реализуйте функцию, которая по номеру и серии паспорта выдаёт имя и фамилию человека.

data = {
    (5000, 123456): ('Иванов', 'Василий'),
    (6000, 111111): ('Иванов', 'Петр'),
    (7000, 222222): ('Медведев', 'Алексей'),
    (8000, 333333): ('Алексеев', 'Георгий'),
    (9000, 444444): ('Георгиева', 'Мария')
}

pasport_ser = int(input('Введите серию паспорта: '))
pasport_num = int(input('Введите серию паспорта: '))
pasport = (pasport_ser, pasport_num)

for key_data, val_data in data.items():
    if key_data == pasport:
        print(val_data)

# решение skillbox
# if pasport in data:
#     print(data[pasport])
# else:
#     print("Такого человека нет")
#

********************************************************************************

# Часть 2. Модуль 7. Видео 5. Задача 2. Контакты 2
#
# Напишите программу, которая запрашивает у пользователя имя контакта, фамилию и номер телефона, добавляет их в словарь
# и выводит на экран текущий словарь контактов. Словарь состоит из пар «Ф. И. — телефон», где Ф. И. — это составной ключ.
# Запрос на добавление идёт бесконечно (но можно задать своё условие для завершения программы).
# Обеспечьте контроль ввода: если этот человек уже есть в словаре, то выведите соответствующее сообщение.

phonebook = dict()
add_yeat = '+'

while add_yeat == '+':
    frs_name = input('Введите имя: ')
    sec_name = input('Введите фамилию: ')
    phonebook_key = (frs_name, sec_name)
    if phonebook_key not in phonebook:
        phonebook[phonebook_key] = input('Введите номер телефона: ')
    else:
        print("Такой контакт уже есть!")
    add_yeat = input('Введите +, чтобы добавить еще: ')

print(phonebook)


********************************************************************************

# tuple = (1, 2, 3) # Есть неизменяемый объект (кстати, попробуйте потом повторить этот код с изменяемым объектом)
# hash_value = hash(tuple) # Применим к этому объекту функцию hash
# print(hash_value) # Проверим, что получилось (бессмысленный набор чисел)
# hash_value_2 = hash(tuple) # Попробуем ещё раз
# print(hash_value_2) # Опять набор чисел
# print(hash_value == hash_value_2) # И он в точности равен первому

tuple = (1, 2, 3)     # Возьмём тот же кортеж
print(hash(tuple))     # Его хеш при каждом запуске может отличаться
# При моём запуске хеш был равен числу 529344067295497451
hash_dict = {(1, 2, 3): 'hello'}     # Если я захочу создать словарь с этим кортежем,
# то «под капотом» будет создан массив, в котором по индексу 529344067295497451
# будет храниться пара (1, 2, 3) и 'hello'

********************************************************************************

# Часть 2. Модуль 8. Практическая работа. Задача 1. Challenge-2
#
# Написать функцию, которая выводит все числа от 1 до num без использования циклов.
# Помогите другу реализовать такую функцию.
#
# Пример работы программы
# Введите num: 10
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9
# 10
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Input содержит корректные приглашения для ввода.
# Основной функционал описан в отдельной функции(-ях).
# Переменные и функции имеют значимые имена, не только a, b, c, d.

def print_num(num_start, num):
    if num_start == num + 1:
        return None
    else:
        print(num_start)
        return print_num(num_start + 1, num)

print_num(1, 10)

********************************************************************************

# Часть 2. Модуль 8. Практическая работа. Задача 2. Поиск элемента — 2
#
# Пользователь вводит искомый ключ. Если он хочет, то может ввести максимальную глубину —
# уровень, до которого будет просматриваться структура.
#
# Напишите функцию, которая находит заданный пользователем ключ в словаре
# и выдаёт значение этого ключа на экран.
# По умолчанию уровень не задан. В качестве примера можно использовать такой словарь:
# site = {
# 'html': {
# 'head': {
# 'title': 'Мой сайт'
# },
# 'body': {
# 'h2': 'Здесь будет мой заголовок',
# 'div': 'Тут, наверное, какой-то блок',
# 'p': 'А вот здесь новый абзац'
# }
# }
# }
# Пример 1
# Введите искомый ключ: head
# Хотите ввести максимальную глубину? Y/N: n
# Значение ключа: {'title': 'Мой сайт'}
# Пример 2
# Введите искомый ключ: head
# Хотите ввести максимальную глубину? Y/N: y
# Введите максимальную глубину: 1
# Значение ключа: None
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Input содержит корректные приглашения для ввода.
# Основной функционал описан в отдельной функции(-ях).
# Переменные и функции имеют значимые имена, не только a, b, c, d.

def key_search(struct, key, max_deep, deep=1):
    while deep <= max_deep:
        if key in struct:
            return struct[key]

        for sub_struct in struct.values():
            if isinstance(sub_struct, dict):
                result = key_search(sub_struct, key, max_deep, deep=deep+1)
                if result:
                    break
        else:
            result = None

        return result

site = {
    'html': {
        'head': {
            'title': 'Мой сайт'
        },
        'body': {
            'h2': 'Здесь будет мой заголовок',
            'div': 'Тут, наверное, какой-то блок',
            'p': 'А вот здесь новый абзац'
        }
    }
}

usr_key = input('Введите искомый ключ: ')
max_deep = 4
usr_question = input('Хотите ввести максимальную глубину? Y/N: ').lower()
if usr_question == 'y':
    usr_max_deep = int(input('Введите максимальную глубину: '))
    max_deep = usr_max_deep

result_value = key_search(site, usr_key, max_deep)
print(f"Значение ключа: {result_value}")


********************************************************************************

# Часть 2. Модуль 8. Практическая работа. Задача 3. Глубокое копирование
#
# site = {
# 'html': {
# 'head': {
# 'title': 'Куплю/продам телефон недорого'
# },
# 'body': {
# 'h2': 'У нас самая низкая цена на iPhone',
# 'div': 'Купить',
# 'p': ‘Продать'
# }
# }
# }
# Напишите программу, которая запрашивает у клиента количество сайтов,
# затем названия продуктов, а после каждого запроса выводит на экран активные сайты.
#
# Условия:
# учтите, что функция должна уметь работать с разными сайтами
# (иначе вам придётся переделывать программу под каждого заказчика заново);
# вы должны получить список, хранящий сайты для разных продуктов
# (а значит, для каждого продукта нужно будет первым делом выполнить глубокое копирование сайта).
# Подсказка
# Чтобы заменить элемент, его нужно найти.
# Для поиска можете использовать рекурсивный алгоритм из задачи по поиску элемента.
#
# Пример вывода
# Сколько сайтов: 2
# Введите название продукта для нового сайта: iPhone
# Сайт для iPhone:
# site = {
# 'html': {
# 'head': {
# 'title': 'Куплю/продам iPhone недорого'
# },
# 'body': {
# 'h2': 'У нас самая низкая цена на iPhone',
# 'div': 'Купить',
# 'p': ‘Продать'
# }
# }
# }
# Введите название продукта для нового сайта: Samsung
# Сайт для iPhone:
# site = {
# 'html': {
# 'head': {
# 'title': 'Куплю/продам iPhone недорого'
# },
# 'body': {
# 'h2': 'У нас самая низкая цена на iPhone',
# 'div': 'Купить',
# 'p': ‘Продать'
# }
# }
# }
# Сайт для Samsung:
# site = {
# 'html': {
# 'head': {
# 'title': 'Куплю/продам Samsung недорого'
# },
# 'body': {
# 'h2': 'У нас самая низкая цена на Samsung',
# 'div': 'Купить',
# 'p': ‘Продать'
# }
# }
# }
# Обратите внимание, что на первой итерации выводится только один сайт (для iPhone),
# а на второй итерации — оба сайта (и для iPhone и для Samsung).
# Чтобы это реализовать, нужно сохранять сайты в списке и каждый раз печатать все его элементы.
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Input содержит корректные приглашения для ввода.
# Основной функционал описан в отдельной функции(-ях).
# Переменные и функции имеют значимые имена, не только a, b, c, d.

import copy


def deep_copy(some_dict):
    if isinstance(some_dict, dict):
        return {key: deep_copy(value) for key, value in some_dict.items()}
    else:
        return copy.deepcopy(some_dict)


def create_site(site_code, site_name):
    site_copy = deep_copy(site_code)
    site_copy['html']['head']['title'] = f'Куплю/продам {site_name} недорого'
    site_copy['html']['body']['h2'] = f'У нас самая низкая цена на {site_name}'

    return site_copy


def print_dict(some_dict, indent=''):
    for key, value in some_dict.items():
        if isinstance(value, dict):
            print("{indent}{key}: ".format(indent=indent, key=key))
            print_dict(some_dict=value, indent=indent + '   ')
        else:
            print(indent + "{key}: {value}".format(key=key, value=value))


site = {
    'html': {
        'head': {
            'title': 'Куплю/продам телефон недорого'
        },
        'body': {
            'h2': 'У нас самая низкая цена на телефон',
            'div': 'Купить',
            'p': 'Продать'
        }
    }
}

num_sites = int(input('Сколько сайтов: '))
sites_list = []
for _ in range(num_sites):
    product = input('\nВведите название продукта для нового сайта: ')
    sites_list.append([f"Сайт для {product}:", create_site(site, product)])
    for el in sites_list:
        print(f"\n{el[0]}")
        print_dict(el[1])


********************************************************************************

# Часть 2. Модуль 8. Практическая работа. Задача 4. Продвинутая функция sum
#
# Напишите свою функцию sum, которая должна быть более гибкой, чем стандартная.
# Она должна уметь складывать числа: из списка списков, из набора параметров.
# Основной код оставьте пустым или закомментированным (используйте его только для тестирования).
#
# Примеры вызовов функции
# sum([[1, 2, [3]], [1], 3])
# Ответ в консоли: 10
# sum(1, 2, 3, 4, 5)
# Ответ в консоли: 15
#
# Что оценивается
# Результат вычислений корректен.
# Весь функционал описан в отдельной функции.
# Переменные и функции имеют значимые имена, не только a, b, c, d.


def sum_args(*args):
    summ = 0
    for i_num in args:
        summ += i_num
    return summ
def sum_in(structure):
    if isinstance(structure, tuple):
        structure = list(structure)
    if structure == [] or ():
        return 0
    if isinstance(structure[0], (list, tuple)):
        return sum_in(structure[0]) + sum_in(structure[1:])
    return structure[0] + sum_in(structure[1:])

def full_sum(structure, *args):
    return sum_in(structure) + sum_args(*args)



if __name__ == '__main__':
    test_sample = [
        [[1, 2, [3]], [1], 3],                         # Ответ в консоли: 10
        (1, 2, 3, 4, 5),                               # Ответ в консоли: 15
        [[1, 2, [3], (11, (12, 15, 16), 13)], [1], 3], # Ответ в консоли: 77
        (1, (10, 20, [400, 500, 600], 30), 3, 4, 5)   # Ответ в консоли: 1573
    ]

    for sample in test_sample:
        print(f"Сумма элементов конструкции {sample} = {sum_in(sample)}")
    print(f"\nСумма аргументов = {sum_args(1, 2, 3, 4, 5)}\n")     # Ответ в консоли: 15

    for sample in test_sample:
        print(f"Общая сумма элементов конструкции с аргументами f({sample}, 1, 2, 3, 4, 5) = {full_sum(sample, 1, 2, 3, 4, 5)}")

********************************************************************************

# Часть 2. Модуль 8. Практическая работа. Задача 5. Список списков — 2
#
# Вы уже работали с многомерными списками и решали задачи, где с помощью
# list comprehensions «выпрямляли» многомерные списки в один.
# Это не получится, если списков неограниченное количество и у элементов разные уровни вложенности.
#
# Дан такой список:
# nice_list = [1, 2, [3, 4], [[5, 6, 7], [8, 9, 10]], [[11, 12, 13], [14, 15], [16, 17, 18]]]
#
# Напишите рекурсивную функцию, которая раскрывает все вложенные списки, то есть оставляет только внешний список.
# Ответ: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
#
# Функция должна получать список и возвращать его раскрытую версию
# (не нужно добавлять элементы в список, записанный в глобальную переменную, созданную снаружи функции).
#
# Подсказка
# Можно возвращать списки и срезы списков.
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Основной функционал описан в отдельной функции(-ях).
# Переменные и функции имеют значимые имена, не только a, b, c, d.

def unpack(structure):
    if isinstance(structure, tuple):
        structure = list(structure)
    if structure == []:
        return structure
    if isinstance(structure[0], (list, tuple)):
        return unpack(structure[0]) + unpack(structure[1:])
    return structure[:1] + unpack(structure[1:])


if __name__ == '__main__':
    test_cases = [
        [[1, 2, [3]], [1], 3],                         # Ответ в консоли: 10
        (1, 2, 3, 4, 5),                               # Ответ в консоли: 15
        [[1, 2, [3], (11, (12, 15, 16), 13)], [1], 3], # Ответ в консоли: 77
        (1, (10, 20, [400, 500, 600], 30), 3, 4, 5)    # Ответ в консоли: 1573
    ]

    for sample in test_cases:
        print(f"Распакованная в список конструкция: {unpack(sample)}")




# Решение только для списков:
#
# def unpack(some_list: list):
#     if some_list == []:
#         return some_list
#     if isinstance(some_list[0], list):
#         return unpack(some_list[0]) + unpack(some_list[1:])
#     return some_list[:1] + unpack(some_list[1:])
#
# my_list = [1, 2, [3, 4], [[5, 6, 7], [8, 9, 10]], [[11, 12, 13], [14, 15], [16, 17, 18]]]
# print(unpack(my_list))

********************************************************************************

# Часть 2. Модуль 8. Практическая работа. Задача 6. Быстрая сортировка (сортировка Хоара)
#
# За один шаг алгоритма выполните следующие действия:
#
# 1. Выберите один элемент списка (его иногда называют опорным элементом).
# Сделать это можно разными способами, но важно придерживаться одного принципа.
# В нашем случае опорным элементом всегда будет крайний правый (например, в списке [1, 2, 3] это 3).
#
# 2. Разбейте текущий список на три части: элементы меньше опорного, равные опорному и больше опорного.
# В списке [5, 8, 9, 4, 2, 9, 1, 8] опорным элементом будет число 8 (крайнее правое), а получить надо три списка:
#     [5, 4, 2, 1];
#     [8, 8];
#     [9, 9].
#
# 3. Для списка с элементами меньше опорного ([5, 4, 2, 1])
# и списка с элементами больше опорного ([9, 9])
# выполните те же шаги заново — запустите рекурсию.
#     результат_1 = рекурсия([5, 4, 2, 1]).
#     результат_2 = [8, 8].
#     результат_3 = рекурсия([9, 9]).
#
# 4. Сложите результаты вызова рекурсий и получите отсортированный список:
#     отсортированный_список = результат_1 + результат_2 + результат_3.
#
#
# Пример с разбором алгоритма (как сработала рекурсия)
#
# С [9, 9] всё просто. Элементов меньше или больше опорного нет,
# поэтому рекурсия не пойдёт глубже, а вызов рекурсии по списку
# [9, 9] быстро завершится и вернёт этот же список (его и не нужно было сортировать).
#
# С [5, 4, 2, 1] рекурсия пойдёт вглубь:
#     Первый шаг— [5, 4, 2, 1]:
#         опорным элементом выбирается число 1;
#         меньше 1 элементов нет (значит, рекурсия по ним продолжаться не будет);
#         помимо опорного элемента, других равных нет, получаем список [1];
#         больше 1 все остальные элементы [5, 4, 2] — с этим списком будет вызвана рекурсия.
#     Второй шаг— [5, 4, 2]:
#         опорный элемент — 2;
#         меньше опорного — [];
#         равные опорному — [2];
#         больше опорного — [5, 4].
#     Третий шаг— [5, 4]:
#         опорный элемент — 4;
#         меньше — [];
#         равны — [4];
#         больше — [5].
#     Четвёртый шаг — [5]:
#         меньше — [];
#         равны — [5];
#         больше — [].
#
# Тут вызовы завершаются, мы соединяем списки и возвращаем список [5] на уровень выше (в вызов с числами [5, 4]).
#
# Там мы соединяем списки [] + [4] + [5] и получаем [4, 5].
# Этот список возвращаем ещё на уровень выше (в вызов с числами [5, 4, 2]).
#
# Опять складываем списки:
#     [ ] + [2] + [4, 5] = [2, 4, 5].
# Этот список возвращаем в вызов на уровень выше (тот, который был запущен с [5, 4, 2, 1]).
#
# Складываем списки:
#     [ ] + [1] + [2, 4, 5] = [1, 2, 4, 5].
# Возвращаем [1, 2, 4, 5] в самый первый вызов, где мы выполняли следующие вызовы:
#     результат_1 = рекурсия([5, 4, 2, 1]).
#     результат_2 = [8, 8].
#     результат_3 = рекурсия([9, 9]).
#
# В итоге после выполнения всех рекурсий получаем:
#     результат_1 = [1, 2, 4, 5].
#     результат_2 = [8, 8].
#     результат_3 = [9, 9].
#
# Складываем все списки:
#     [1, 2, 4, 5] + [8, 8] + [9, 9] = [1, 2, 4, 5, 8, 8, 9, 9].
# Этот полный список возвращается наружу — туда, где функция была вызвана изначально.
#
# Напишите функцию, которая реализует этот алгоритм.
# Для удобства добавьте вспомогательную функцию, пусть она принимает на вход список,
# а возвращает три списка (с элементами меньше, равными и больше опорного).
#
# Пример работы такой функции:
# числа = [4, 9, 2, 7, 5]
# вспомогательная_функция(числа) → [4, 2], [5], [9, 7]
# Эту функцию можно будет использовать в основной-рекурсивной, чтобы код основной функции стал проще и понятнее.
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Основной функционал описан в отдельной функции(-ях).
# Переменные и функции имеют значимые имена, не только a, b, c, d.


import random

def help_func(some_list: list):
    point = some_list[-1:][0]
    list_smaller, list_equal, list_bigger = [], [], []
    for el in some_list:
        if el < point:
            list_smaller.append(el)
        elif el == point:
            list_equal.append(el)
        else:
            list_bigger.append(el)
    return list_smaller, list_equal, list_bigger


def hoara_sort(some_list):
    list_smaller, list_equal, list_bigger = help_func(some_list)
    if len(list_smaller) > 1:
        res_1 = hoara_sort(list_smaller)
    else:
        res_1 = list_smaller
    res_2 = list_equal
    if len(list_bigger) > 1:
        res_3 = hoara_sort(list_bigger)
    else:
        res_3 = list_bigger
    return res_1 + res_2 + res_3


if __name__ == '__main__':
    test_cases = [
        [5, 8, 9, 4, 2, 9, 1, 8],
        [96, 75, -94, 74, 29, -68, 97, -3, -67, -7, 35, -91, 77, -75, -67, -11, -59, 59, -51, 93, -21, 74, -11],
        [random.randint(-100, 100) for _ in range(30)]
    ]

    for sample in test_cases:
        result = hoara_sort(sample)
        print(f"Отсортированный список: {result}")


********************************************************************************

# Часть 2. Модуль 8. Видео 2. Задача 1. Challenge
#
# Напишите функцию, которая считает факториал числа с помощью рекурсии.
#
# Кстати, в Python есть ограничение на количество рекурсивных вызовов.
# Попробуйте передать своей функции, например, число 1000 и посмотрите, что будет.

import math
def my_factorial(n):
    if n == 1:
        return 1
    fact_n = n * my_factorial(n-1)
    return fact_n

def test_my_factorial():
    # Тестовый случай 1:
    n = 5
    expected_fact = math.factorial(n)
    assert my_factorial(n) == expected_fact

    # Тестовый случай 2:
    n = 1
    expected_fact = math.factorial(n)
    assert my_factorial(n) == expected_fact

    # Тестовый случай 3:
    n = 998
    expected_fact = math.factorial(n)
    assert my_factorial(n) == expected_fact

    print("Все тестовые случаи успешно пройдены.")


if __name__ == '__main__':
    test_my_factorial()
    result = my_factorial(999)
    print(result)




********************************************************************************

# Часть 2. Модуль 8. Видео 2. Задача 2. Степень числа
#
# Код для расчёта степени числа без использования циклов, ** и функции math.pow():
#
# def power(a, n):
#     return a * power(a, n)
#
# float_num = float(input('Введите вещественное число: '))
# int_num = int(input('Введите степень числа: '))
# print(float_num, '**', int_num, '=', power(float_num, int_num))
#
# Другие пользователи отметили, что это решение нерабочее и в нём есть ошибки.
# Исправьте это решение, не используя циклы, возведение в степень через ** и функцию math.pow()
#
# Правильный результат:
# Введите вещественное число: 1.5
# Введите степень числа: 5
# 1.5 ** 5 = 7.59375

def power(a, n):
    if n <= 0:
        return 1
    return a * power(a, n - 1)

number = float(input('Введите вещественное число: '))
degree = float(input('Введите степень числа: '))

result = power(number, degree)

print(f"{number} ^ {degree} = {result}")


********************************************************************************

# Часть 2. Модуль 8. Видео 2. Задача 3. Поиск элемента
#
# Когда мы работаем с большой многоуровневой структурой, нам нередко необходимо пройтись по ней
# и найти нужный элемент. Для этого в программировании используются специальные алгоритмы поиска.
#
# Напишите функцию, которая находит заданный пользователем ключ в словаре и выдаёт значение этого
# ключа на экран. В качестве примера можно использовать такой словарь:
#
# site = {
#     'html': {
#         'head': {
#             'title': 'Мой сайт'
#         },
#         'body': {
#             'h2': 'Здесь будет мой заголовок',
#             'div': 'Тут, наверное, какой-то блок',
#             'p': 'А вот здесь новый абзац'
#         }
#     }
# }
#
# Пример 1:
# Искомый ключ: h2
# Значение: Здесь будет мой заголовок
# Пример 2:
# Искомый ключ: abc
# Такого ключа в структуре сайта нет.

def searching_val(some_dict: dict, tag):
    result = None
    if tag in some_dict:
        return some_dict[tag]

    for val in some_dict.values():
        if isinstance(val, dict):
            result = searching_val(val, tag)
            if result:
                return result
    return result

site = {
    'html': {
        'head': {
            'title': 'Мой сайт'
        },
        'body': {
            'h2': 'Здесь будет мой заголовок',
            'div': 'Тут, наверное, какой-то блок',
            'p': 'А вот здесь новый абзац'
        }
    }
}

search_key = input("Искомый ключ: ")

result_value = searching_val(site, search_key)

if result_value:
    print(f"Значение: {result_value}")
else:
    print("Такого ключа в структуре сайта нет.")


********************************************************************************

# Часть 2. Модуль 8. Видео 4. Задача 1. Ошибка
#
# Код с ошибкой:
#
# import random
#
# def change_dict(dct):
#     num = random.randint(1, 100)
#     for i_key, i_value in dct.items():
#         if isinstance(i_value, list):
#             i_value.append(num)
#         if isinstance(i_value, dict):
#             i_value[num] = i_key
#         if isinstance(i_value, set):
#             i_value.add(num)

# nums_list = [1, 2, 3]
# some_dict = {1: 'text', 2: 'another text'}
# uniq_nums = {1, 2, 3}
# common_dict = {1: nums_list, 2: some_dict, 3: uniq_nums, 4: (10, 20, 30)}
# change_dict(common_dict)
# print(common_dict)
#
# Суть кода в том, что у вас есть общий словарь из нескольких ключей, значения которых равны ранее объявленным переменным.
# Затем вызывается функция, которая должна изменять значения словаря, добавляя к значениям случайное число,
# в зависимости от типа данных.
# Но при этом меняются и ранее объявленные переменные. Исправьте эту ошибку
# и убедитесь, что nums_list, some_dict и uniq_nums не меняются.

import random

def change_dict(dct):
    num = random.randint(1, 100)
    for i_key, i_value in dct.items():
        if isinstance(i_value, list):
            i_value.append(num)
        if isinstance(i_value, dict):
            i_value[num] = i_key
        if isinstance(i_value, set):
            i_value.add(num)


nums_list = [1, 2, 3]
some_dict = {1: 'text', 2: 'another text'}
uniq_nums = {1, 2, 3}
# Решить это задание можно разными способами
# Мы можем вручную копировать каждый входящий элемент:
common_dict = {1: nums_list.copy(), 2: some_dict.copy(), 3: uniq_nums.copy(), 4: (10, 20, 30)}
change_dict(common_dict)
print(common_dict)
# Либо мы можем применить вспомогательную функцию, которая сделает это за нас:
import copy

common_dict = {1: nums_list, 2: some_dict, 3: uniq_nums, 4: (10, 20, 30)}
common_dict_2 = copy.deepcopy(common_dict)    # Она будет особенно полезна в структурах,
                                                  # в которых множество вложенных переменных
change_dict(common_dict_2)
print(common_dict_2)

print(nums_list, some_dict, uniq_nums)


# Моё решение:
#
# def change_dict(dct):
#     num = random.randint(1, 100)
#     for i_key, i_value in dct.items():
#         if isinstance(i_value, list):
#             i_value.append(num)
#         if isinstance(i_value, dict):
#             i_value[num] = i_key
#         if isinstance(i_value, set):
#             i_value.add(num)
#
# nums_list = [1, 2, 3]    # список
# some_dict = {1: 'text', 2: 'another text'}    # словарь
# uniq_nums = {1, 2, 3}    # множество
#
# print(f"\nnums_list = {nums_list}\nsome_dict = {some_dict}\nuniq_nums = {uniq_nums}")
# print(f"\nid(nums_list) = {id(nums_list)}\nid(some_dict) = {id(some_dict)}\nid(uniq_nums) = {id(uniq_nums)}\n")
#
# common_dict = {1: nums_list[::], 2: some_dict.copy(), 3: uniq_nums.copy(), 4: (10, 20, 30)}
# print("Исходный словарь:")
# for key, val in common_dict.items():
#     print(f"{key}: {val}")
#
# change_dict(common_dict)
#
# # print(f"\n{common_dict}")
# print("\nНовый словарь с измененными значениями:")
# for key, val in common_dict.items():
#     print(f"{key}: {val}")
#
# print(f"\nnums_list = {nums_list}\nsome_dict = {some_dict}\nuniq_nums = {uniq_nums}")
# print(f"\nid(nums_list) = {id(nums_list)}\nid(some_dict) = {id(some_dict)}\nid(uniq_nums) = {id(uniq_nums)}\n")

********************************************************************************

# Часть 2. Модуль 8. Видео 4. Задача 2. Непонятно!
#
# Пользователь вводит любой объект. Напишите программу, которая выводит на экран тип введённых данных,
# информацию о его изменяемости, а также id этого объекта.
#
# Пример 1:
# Введите данные: привет
# Тип данных: str (строка)
# Неизменяемый (immutable)
# Id объекта: 1705156583984
#
# Пример 2:
# Введите данные: {‘a’: 10, ‘b’: 20}
# Тип данных: dict (словарь)
# Изменяемый (mutable)
# Id объекта: 1705205308536


# РЕШЕНИЕ SKILLBOX
# Ввод объекта осуществляется не через инпут (решение с инпутом можно реализовать,
# но для этого придётся прописывать множество проверок введенной строки,
# чтобы можно было преобразовать её потом в нужный тип данных)
# Добавим вспомогательные словари для работы
# (в них можно будет по необходимости добавлять типы, которых сейчас нет)
data_names_dict = {
    "<class 'int'>": "целочисленный тип",
    "<class 'float'>": "числа с плавающей точкой",
    "<class 'str'>": "строковый тип",
    "<class 'tuple'>": "кортеж",
    "<class 'bool'>": "логический тип",
    "<class 'list'>": "список",
    "<class 'dict'>": "словарь",
    "<class 'set'>": "множество"
}

mutable_check_helper = {
    "mutable": ("словарь", "список", "множество")
}


def check_info(data):
    type_of_data = type(data)
    name_of_data = ""

    if str(type_of_data) in data_names_dict:
        name_of_data = data_names_dict[str(type_of_data)]

    if name_of_data in mutable_check_helper["mutable"]:
        property_of_data = "Изменяемый (mutable)"
    else:
        property_of_data = "Неизменяемый (immutable)"

    print(f"Тип данных: {type_of_data} ({name_of_data})\n"
          f"{property_of_data}\n"
          f"Id объекта: {id(data)}\n")


if __name__ == '__main__':
    test_cases = [
        1,
        1.5,
        'abcd',
        (1, 2, 3, 4, 5),
        True,
        [1, 2, 3, 4, 5, 6, 7],
        {1: '1111', 2: '2222', 3: '333'},
        {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    ]

    for data_in in test_cases:
        print(data_in)
        check_info(data_in)


# МОЕ РЕШЕНИЕ
# types_dict = {
#     "<class 'int'>": "целочисленный тип",
#     "<class 'float'>": "числа с плавающей точкой",
#     "<class 'str'>": "строковый тип",
#     "<class 'tuple'>": "кортеж",
#     "<class 'bool'>": "логический тип",
#     "<class 'list'>": "список",
#     "<class 'dict'>": "словарь",
#     "<class 'set'>": "множество"
# }
# mutable = {"список", "словарь", "множество"}
# ordered = {"целочисленный тип", "числа с плавающей точкой", "строковый тип", "кортеж", "список", "логический тип"}
#
#
# if __name__ == '__main__':
#     test_cases = [
#         1,
#         1.5,
#         'abcd',
#         (1, 2, 3, 4, 5),
#         True,
#         [1, 2, 3, 4, 5, 6, 7],
#         {1: '1111', 2: '2222', 3: '333'},
#         {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
#     ]
#
#     for usr_obj in test_cases:
#
#         if str(type(usr_obj)) in types_dict:
#             if types_dict[str(type(usr_obj))] in mutable:
#                 if types_dict[str(type(usr_obj))] in ordered:
#                     print(f"{usr_obj} - "
#                           f"{types_dict[str(type(usr_obj))]}, изменяемый, упорядоченный, id = {id(usr_obj)}")
#                 else:
#                     print(f"{usr_obj} - "
#                           f"{types_dict[str(type(usr_obj))]}, изменяемый, неупорядоченный, id = {id(usr_obj)}")
#             else:
#                 if types_dict[str(type(usr_obj))] in ordered:
#                     print(f"{usr_obj} - "
#                           f"{types_dict[str(type(usr_obj))]}, неизменяемый, упорядоченный, id = {id(usr_obj)}")
#                 else:
#                     print(f"{usr_obj} - "
#                           f"{types_dict[str(type(usr_obj))]}, неизменяемый, неупорядоченный, id = {id(usr_obj)}")



# Мои словари
# types_dict = {
#     "<class 'int'>": "целочисленный тип",
#     "<class 'float'>": "числа с плавающей точкой",
#     "<class 'str'>": "строковый тип",
#     "<class 'tuple'>": "кортеж",
#     "<class 'bool'>": "логический тип",
#     "<class 'list'>": "список",
#     "<class 'dict'>": "словарь",
#     "<class 'set'>": "множество"
# }
# values_dict = {
#     'immutable': 'неизменяемый (immutable)',
#     'mutable': 'изменяемый (mutable)',
#     'ordered': 'упорядоченный',
#     'unordered': 'неупорядоченный',
#     'unordered_dict': 'неупорядоченный до версии p.3.7',
# }
#
# obj_dict = {
#     "<class 'int'>": {types_dict["<class 'int'>"], values_dict['immutable'], values_dict['ordered']},
#     "<class 'float'>": {types_dict["<class 'float'>"], values_dict['immutable'], values_dict['ordered']},
#     "<class 'str'>": {types_dict["<class 'str'>"], values_dict['immutable'], values_dict['ordered']},
#     "<class 'tuple'>": {types_dict["<class 'tuple'>"], values_dict['immutable'], values_dict['ordered']},
#     "<class 'bool'>": {types_dict["<class 'bool'>"], values_dict['immutable']},
#     "<class 'list'>": {types_dict["<class 'list'>"], values_dict['mutable'], values_dict['ordered']},
#     "<class 'dict'>": {types_dict["<class 'dict'>"], values_dict['mutable'], values_dict['unordered_dict']},
#     "<class 'set'>": {types_dict["<class 'set'>"], values_dict['mutable'], values_dict['unordered']}

********************************************************************************

# Часть 2. Модуль 8. Видео 6. Задача 1. Работа с файлом
#
# Вы пишете небольшое приложение для работы с файлами. Реализуйте функцию, которая может принимать на вход три аргумента:
# вопрос пользователю (на который нужно ответить да или нет), сообщение о неправильном вводе и количество попыток.
# Вопрос — обязательный позиционный аргумент, остальные — со значениями по умолчанию.
# При корректном ответе функция может возвращать что угодно — например, число 1 при ответе «да» или 0 при ответе «нет».
#
# В основной программе вызовите функцию минимум три раза: только с вопросом, с вопросом и сообщением об ошибке,
# с вопросом и количеством попыток.
#
# Пример работы программы:
# Вы действительно хотите выйти? что
# Неверный ввод. Пожалуйста, введите 'да' или 'нет'.
# Осталось попыток: 3
# Вы действительно хотите выйти? да
# Удалить файл? не знаю
# Так удалить или нет?
# Осталось попыток: 3
# Удалить файл? нет
# Записать файл? ага
# Неверный ввод. Пожалуйста, введите 'да' или 'нет'.
# Осталось попыток: 1
# Записать файл? да

def ask_quations(question_to_user,
                 message_incorrect_input="Неверный ввод. Пожалуйста, введите 'да' или 'нет': ",
                 number_attempts=3):
    while True:
        answer_question = input(question_to_user).lower()
        if answer_question == 'да' or answer_question == 'yes':
            return 1
        elif answer_question == 'нет' or answer_question == 'no':
            return 0
        number_attempts -= 1
        if number_attempts == 0:
            print('Кол-во попыток истекло.')
            break
        print(message_incorrect_input)
        print(f"Осталось {number_attempts} попытки.")

ask_quations("Вы действительно хотите выйти? ")     # только с вопросом
ask_quations("Удалить файл? ", "Так удалить или нет?")     # с вопросом и сообщением об ошибке,
ask_quations("Записать файл? ", number_attempts=2)    # с вопросом и количеством попыток.

# Решение Skillbox
# def checker(question,
#             error_message="Неверный ввод. Пожалуйста, введите 'да' или 'нет'.",
#             count_of_errors=3):
#     while count_of_errors:
#         user_input = input(question)
#         if user_input.lower() == "да":
#             return 1
#         elif user_input.lower() == "нет":
#             return 0
#         else:
#             print(error_message)
#         count_of_errors -= 1
#         print("Осталось попыток:", count_of_errors)
# checker("да?")
# checker("да?", "ДА ил НЕТ?!")
# checker("да?", count_of_errors=3)

********************************************************************************

# Часть 2. Модуль 8. Видео 6. Задача 2. Накопление значений
#
# Напишите функцию с двумя аргументами: первый — число num,
# позиционный аргумент; второй — список lst, по умолчанию он пустой.
# В теле функции в список добавляется число num и сам список выводится на экран.
#
# В основной программе вызовите функции три раза только с одним аргументом (числом), например так:
# add_num(5)
# add_num(10)
# add_num(15)
#
# И посмотрите, что произойдёт.
#
# После этого сделайте значение lst по умолчанию None и поправьте функцию, чтобы она работала правильно.

def add_num(num, lst=None):
    lst = lst or []
    lst.append(num)
    print(lst)

add_num(5)
add_num(10)
add_num(15)


# Решение Skillbox
# def add_num(num, nums=[]):
#     nums.append(num)
#     print(nums)
#
# add_num(5)
# add_num(10)
# add_num(15)
# def add_num(num, nums=None):
#     nums = nums or []
#     # хитрая конструкция, которая позволит упростить ввод:
#     # if not nums:
#     #    nums = []
#     # Первый вариант будет выбран, если nums не равен None, иначе будет создан и записан пустой список
#     nums.append(num)
#     print(nums)
#
# add_num(5)
# add_num(10)
# add_num(15)

********************************************************************************

# Часть 2. Модуль 8. Видео 6. Задача 3. Помощь другу
#
# Нашего друга попросили написать функцию, которая на вход принимает список всякого мусора.
# Ему нужно подготовить из этого списка список словарей, чтобы его коллеги смогли дальше продолжить обработку данных.
# Вот список правил, что нужно сделать с изначальным списком:
# Если в списке встретился словарь, то оставляем его.
# Если в списке встретилась строка, то из неё нужно сделать словарь
# и положить его в итоговый список, например  “abc” → {“abc”: “abc”}.
# С числами нужно сделать то же самое, что и со строками.
# Всё остальное выкидываем из нашего списка.
# Друг написал программу, но в ней ошибка, так как она что-то не то выводит :( Нужна ваша помощь, вот сама программа:
#
# def create_dict(data, template=dict()):
#     if isinstance(data, dict):
#         return data
#     if isinstance(data, int) or isinstance(data, float) or isinstance(data, str):
#         return template[data] = data
#
# def data_preparation(old_list):
#     new_list = []
#     for i_element in old_list:
#         new_list.append(create_dict(i_element))
#     return new_list
#
# data = [“sad”, {“sds”: 23}, {43}, [12, 42, 1], 2323]
# data = data_preparation(data)
# print(data)
#
# Исправьте программу и убедитесь, что всё работает верно.

def create_dict(element):
    if isinstance(element, dict):
        return element
    else:
        return dict({element: element})

def data_preparation(old_list):
    new_list = [create_dict(el) for el in old_list if isinstance(el, (dict, str, int, float))]
    return new_list


data = ["sad", {"sds": 23}, {43}, [12, 42, 1], 2323]
list_result = data_preparation(data)
print(list_result)



# Решение Skillbox
# def create_dict(data, template=None):
#     if isinstance(data, dict):
#         return data
#     elif isinstance(data, (int, float, str)):
#         template = template or dict()
#         template[data] = data
#         return template
#     else:
#         return None
#
# def data_preparation(old_list):
#     new_list = []
#     for i_element in old_list:
#         new_elem = create_dict(i_element)
#         if new_elem:
#             new_list.append(new_elem)
#     return new_list
#
#
# data = ["sad", {"sds": 23}, {43}, [12, 42, 1], 2323]
# data = data_preparation(data)
# print(data)

********************************************************************************

# Часть 2. Модуль 9. Практическая работа. Задача 1. Сумма чисел 2
#
# Во входном файле numbers.txt записано N целых чисел, которые могут быть разделены пробелами и
# концами строк. Напишите программу, которая выводит сумму чисел во выходной файл answer.txt.
#
# Пример:
# Содержимое файла numbers.txt
#      2
# 2
#   2
#         2
#
# Содержимое файла answer.txt
# 8
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Основной функционал описан в отдельных функциях.
# Переменные и функции имеют значащие имена, а не только a, b, c, d (подробнее об этом в видео 2.3).
# Входные и выходные файлы названы так, как указано в задании.

import os

path = os.path.join('numbers.txt')
abs_path = os.path.abspath(path)

numbers_file = open(abs_path, 'r')
summ = 0
for line in numbers_file:
    summ += int(line.lstrip())
numbers_file.close()

answer_file = open('answer.txt', 'w')
answer_file.write(str(summ))
answer_file.close()


********************************************************************************

# Часть 2. Модуль 9. Практическая работа. Задача 2. Дзен Пайтона
#
# В файле zen.txt хранится так называемый Дзен Пайтона — текст философии
# программирования на языке Python. Выглядит он так:
#
# Beautiful is better than ugly.
# Explicit is better than implicit.
# Simple is better than complex.
# Complex is better than complicated.
# Flat is better than nested.
# Sparse is better than dense.
# Readability counts.
# Special cases aren't special enough to break the rules.
# Although practicality beats purity.
# Errors should never pass silently.
# Unless explicitly silenced.
# In the face of ambiguity, refuse the temptation to guess.
# There should be one-- and preferably only one --obvious way to do it.
# Although that way may not be obvious at first unless you're Dutch.
# Now is better than never.
# Although never is often better than *right* now.
# If the implementation is hard to explain, it's a bad idea.
# If the implementation is easy to explain, it may be a good idea.
# Namespaces are one honking great idea -- let's do more of those!
#
# Напишите программу, которая выводит на экран все строки этого файла в обратном порядке.
# Кстати, попробуйте открыть консоль Python и ввести команду import this.
#
# Результат работы программы:
# Namespaces are one honking great idea -- let's do more of those!
# If the implementation is easy to explain, it may be a good idea.
# If the implementation is hard to explain, it's a bad idea.
# Although never is often better than *right* now.
# …
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Основной функционал описан в отдельных функциях.
# Переменные и функции имеют значащие имена, а не только a, b, c, d (подробнее об этом в видео 2.3).
# Входной файл назван так, как указано в задании.

import os

path = os.path.join('zen.txt')
abs_path = os.path.abspath(path)
print(abs_path)

zen_file = open(abs_path, 'r')
temp_list = [line for line in zen_file]
zen_file.close()

print(temp_list)
print(temp_list[::-1])

reversed_zen_file = open('reversed_zen.txt', 'w')
for i_temp in temp_list[::-1]:
    reversed_zen_file.write(i_temp)
reversed_zen_file.close()

********************************************************************************

# Часть 2. Модуль 9. Практическая работа. Задача 3. Файлы и папки
#
# Напишите программу, которая получает на вход путь до каталога
# (в том числе это может быть просто корень диска) и
# выводит общее количество файлов и подкаталогов в нём.
# Также выведите на экран размер каталога в килобайтах (1 килобайт = 1024 байт).
#
# Важный момент: чтобы посчитать, сколько весит каталог,
# нужно найти сумму размеров всех вложенных в него файлов.
# Результат работы программы на примере python_basic\Module14:
#
# E:\PycharmProjects\python_basic\Module14
# Размер каталога (в Кбайтах): 8.373046875
# Количество подкаталогов: 7
# Количество файлов: 15
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Input содержит корректные приглашения для ввода.
# Основной функционал описан в отдельных функциях.
# Переменные и функции имеют значащие имена, а не только a, b, c, d (подробнее об этом в видео 2.3).

import os

top_dir = input('Введите путь: ') # top_dir = os.path.abspath(os.path.join(os.sep))

def dir_info(path):
    count_dirs, count_files, full_files_size = 0, 0, 0
    for dir_path, dir_list, file_list in os.walk(path):
        for i_file in file_list:
            file_path = os.path.join(dir_path, i_file)
            full_files_size = os.path.getsize(file_path)
            count_files += 1
        count_dirs += 1

    # result_list = [(len(dirs), len(files), sum(getsize(join(root, name)) for name in files))
    #                for root, dirs, files in os.walk(path)]
    return count_dirs, count_files, full_files_size


dirs, files, full_size = dir_info(top_dir)

print(f"Кол-во подкаталогов: {dirs}\n"
      f"Кол-во файлов: {files}\n"
      f"Размер каталога, кБ: {(full_size / 1024):.2f}")


********************************************************************************

# Часть 2. Модуль 9. Практическая работа. Задача 4. Турнир
#
# В файле first_tour.txt записано число K и данные об участниках:
# фамилии, имена и количество баллов, набранных в первом туре.
# Во второй тур проходят участники, которые набрали более K баллов в первом туре.
#
# Напишите программу, которая выводит в файл second_tour.txt данные всех участников,
# прошедших во второй тур, с нумерацией.
#
# В первой строке нужно вывести в файл second_tour.txt количество участников второго тура.
# Затем программа должна вывести фамилии, инициалы и количество баллов всех участников,
# прошедших во второй тур, с нумерацией. Имя нужно сократить до одной буквы.
# Список должен быть отсортирован по убыванию набранных баллов.
#
# Пример:
# Содержимое файла first_tour.txt:
# 80
# Ivanov Serg 80
# Sergeev Petr 92
# Petrov Vasiliy 98
# Vasiliev Maxim 78
#
# Содержимое файла second_tour.txt:
# 2
# 1) V. Petrov 98
# 2) P. Sergeev 92
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Основной функционал описан в отдельных функциях.
# Переменные и функции имеют значащие имена, а не только a, b, c, d (подробнее об этом в видео 2.3).
# Входные и выходные файлы названы так, как указано в задании.

with open('first_tour.txt', 'r') as first_tour:
    k = int(first_tour.readline())
    gamers_list = [line.split() for line in first_tour if int(line.split()[2]) > k]

points_list = [el[2] for el in gamers_list]
points_list.sort(reverse=True)
gamers_count = len(gamers_list)

with open('second_tour.txt', 'w') as second_tour:
    second_tour.write(str(gamers_count)+'\n')
    for i in range(gamers_count):
        for j, el in enumerate(gamers_list):
            if points_list[i] == gamers_list[j][2]:
                second_tour.write(f"{i+1}) {el[0]} {el[1][0]}. {el[2]}\n")

********************************************************************************

# Часть 2. Модуль 9. Практическая работа. Задача 5. Частотный анализ
#
# Есть файл text.txt, который содержит текст.
# Напишите программу, которая выполняет частотный анализ, определяя долю каждой буквы английского алфавита
# в общем количестве английских букв в тексте, и выводит результат в файл analysis.txt.
# Символы, не являющиеся буквами английского алфавита, учитывать не нужно.
#
# В файл analysis.txt выводится доля каждой буквы, встречающейся в тексте,
# с тремя знаками в дробной части. Буквы должны быть отсортированы по убыванию их доли.
# Буквы с равной долей должны следовать в алфавитном порядке.
#
# Пример:
# Содержимое файла text.txt:
# Mama myla ramu.
# Содержимое файла analysis.txt:
# a 0.333
# m 0.333
# l 0.083
# r 0.083
# u 0.083
# y 0.083
#
# Что оценивается
# Результат вычислений корректен.
# Формат вывода соответствует примеру.
# Основной функционал описан в отдельных функциях.
# Переменные и функции имеют значащие имена, а не только a, b, c, d (подробнее об этом в видео 2.3).
# Входные и выходные файлы названы так, как указано в задании.

def dictionary_creation(some_str):                 # формируем словарь из букв латиницы и их кол-ва
    sym_dict = dict()
    count = 0
    for sym in some_str:                           # проходим по символам в строке
        if ord("a") <= ord(sym) <= ord('z'):       # если символ - это буква латинского алфавита
            count += 1                             # считаем все буквы латинского алфавита в тексте
            sym_dict[sym] = some_str.count(sym)    # то считаем кол-во таких символов в строке и создаем запись в словаре
    return sym_dict, count

def dictionary_reverse_key_val(some_dict: dict):     # создаем обратный словарь из ключей и списков значений, где
    sym_sort_dict = dict()                               # ключ - это значение исходнного словаря, а значения - это ключи исходного словаря
    for key, val in some_dict.items():               # идем по ключам и значениям исходного словаря
        if val not in sym_sort_dict:                 # если элемента еще нет в создаваемом словаре
            sym_sort_dict[val] = list(key)           # создаем ключ нового словаря по значению исходного словаря,
        else:                                            # а значением будет список ключей исходного словаря
            sym_sort_dict[val].append(key)           # иначе добавляем в список ключей еще один ключ
    return sym_sort_dict

def dictionary_sorting(some_dict: dict, counter, file_name='analysis.txt'):    # сортируем словарь и записываем результат в файл
    with open(file_name, 'w') as analysis:
        for key in sorted(some_dict.keys(), reverse=True):            # сортируем ключи в обратном порядке и идем по ним
            for val in sorted(some_dict[key]):                        # для значений в отсортированном списке значений конкретного ключа
                print(f'{val} {key/counter:.3f}', file=analysis)


if __name__ == '__main__':

    with open('text.txt', 'r') as text:
        text_str = text.read().lower()

    sym_dict, count_alpha = dictionary_creation(text_str)
    reverse_dict = dictionary_reverse_key_val(sym_dict)
    sort_dict = dictionary_sorting(reverse_dict, count_alpha)


********************************************************************************

# Часть 2. Модуль 9. Практическая работа. Задача 6. «Война и мир»
#
# «Война и мир» лежит в архиве voina-i-mir.zip.
# Напишите программу, которая подсчитывает статистику по буквам (не только русского алфавита)
# в этом романе и выводит результат на экран (или в файл).
# Результат должен быть отсортирован по частоте встречаемости букв (по возрастанию или убыванию).
# Регистр символов имеет значение.
#
# Архив можно распаковать вручную, но, если хотите, можете изучить документацию по модулю zipfile
# (можно использовать и другой модуль) и попробовать написать код, который будет распаковывать архив за вас.
#
# Что оценивается
# Результат вычислений корректен.
# Основной функционал описан в отдельных функциях.
# Переменные и функции имеют значащие имена, а не только a, b, c, d (подробнее об этом в видео 2.3).
# Входной файл назван так, как указано в задании, выходной файл имеет значащее имя.

import os
import zipfile
import time

def zip_extract(zip_file_path):    # Процедура извлечения файлов из архива в текущую директорию
    with zipfile.ZipFile(zip_file_path, 'r') as zip_file:
        zip_file.extractall()

def dict_creation(some_str):                 # формируем словарь из букв всех типов и их кол-ва
    start1 = time.perf_counter()
    sym_dict = dict()
    count = 0
    for sym in some_str:                           # проходим по символам в строке
        if ord("a") <= ord(sym) <= ord('z') \
                or ord("A") <= ord(sym) <= ord('Z') \
                or ord("а") <= ord(sym) <= ord('я') \
                or ord("А") <= ord(sym) <= ord('Я'):       # если символ - это буква алфавита
            count += 1                             # считаем все буквы латинского алфавита в тексте
            sym_dict[sym] = some_str.count(sym)    # то считаем кол-во таких символов в строке и создаем запись в словаре
    print(f"Time dict_creation: {time.perf_counter() - start1}")
    return sym_dict, count

def merge_dicts(special_list):    # Слияние словарей разных файлов
    start2 = time.perf_counter()
    full_sum = 0
    merge_dict = dict()
    for i, elem in enumerate(special_list):
        full_sum += special_list[i][1]
        for key, val in elem[0].items():
            if key not in merge_dict:
                merge_dict[key] = val
            else:
                merge_dict[key] += val
    print(f"Time merge_dicts: {time.perf_counter() - start2}")
    return merge_dict, full_sum

def reverse_key_val(some_dict: dict):     # Создаем обратный словарь из ключей и списков значений, где
    start3 = time.perf_counter()
    sym_sort_dict = dict()                               # ключ - это значение исходнного словаря, а значения - это ключи исходного словаря
    for key, val in some_dict.items():               # идем по ключам и значениям исходного словаря
        if val not in sym_sort_dict:                 # если элемента еще нет в создаваемом словаре
            sym_sort_dict[val] = list(key)           # создаем ключ нового словаря по значению исходного словаря,
        else:                                            # а значением будет список ключей исходного словаря
            sym_sort_dict[val].append(key)           # иначе добавляем в список ключей еще один ключ
    print(f"Time reverse_key_val: {time.perf_counter() - start3}")
    return sym_sort_dict

def dict_sorting(some_dict: dict, counter, file_name='vim_analysis.txt'): # Процедура сортировки словаря и записи результата в файл
    start4 = time.perf_counter()
    with open(file_name, 'w', encoding='cp1251') as analysis:
        for key in sorted(some_dict.keys(), reverse=True):                # сортируем ключи в обратном порядке и идем по ним
            for val in sorted(some_dict[key]):                   # для значений в отсортированном списке значений конкретного ключа
                print(f'{val} {key/counter:.3f}', file=analysis)
    print(f"Time dict_sorting: {time.perf_counter() - start4}")

if __name__ == '__main__':
    archive_name = 'voyna_i_mir'
    zip_extract(archive_name + '.zip')
    sym_dict = dict()
    path_list = [os.path.join(os.path.abspath(archive_name), path) for path in os.listdir(archive_name)]

    dictionary_list = []
    for i, i_path in enumerate(path_list):
        with open(i_path, 'r', encoding='cp1251') as text:
            temp_dict, count_sym = dict_creation(text.read(200000))   # кортеж из словаря и кол-ва букв в словаре
            dictionary_list.append((temp_dict, count_sym))    # список кортежей из словаря и кол-ва букв в словаре

    merge_dict, full_count_sym = merge_dicts(dictionary_list)
    reverse_merge_dict = reverse_key_val(merge_dict)
    sort_merge_dict = dict_sorting(reverse_merge_dict, full_count_sym, file_name = 'vim_analysis.txt')

********************************************************************************

# Часть 2. Модуль 9. Видео 1. Задача 1. Сисадмин
#
# Напишите программу, которая выводит на экран относительный и абсолютный пути до файла admin.bat.
#
# Пример результата:
# Абсолютный путь до файла: C:\Users\Roman\PycharmProjects\Skillbox\access\admin.bat
# Относительный путь до файла: Skillbox\access\admin.bat

import os

file_name = 'admin.bat'
folder1_name = 'Skillbox'
folder2_name = 'access'

rel_path = os.path.join(folder1_name, folder2_name, file_name)
print(f"Относительный путь до файла: {rel_path}")

abs_path =os.path.abspath(rel_path)    # abs_path = os.path.abspath(os.path.join(folder1_name, folder2_name, file_name))
print(f"Абсолютный путь до файла: {abs_path}")


********************************************************************************

# Часть 2. Модуль 9. Видео 1. Задача 2. Содержимое
#
# Выберите любую директорию на своём диске и затем напишите программу,
# выводящую на экран абсолютные пути к файлам и папкам, которые находятся внутри этой директории.
#
# Результат программы на примере директории проекта python_basic:
# Содержимое каталога G:\PycharmProjects\python_basic
#     G:\PycharmProjects\python_basic\.git
#     G:\PycharmProjects\python_basic\.idea
#     G:\PycharmProjects\python_basic\Module14
#     G:\PycharmProjects\python_basic\Module15
#     G:\PycharmProjects\python_basic\Module16
#     G:\PycharmProjects\python_basic\Module17
#     G:\PycharmProjects\python_basic\Module18
#     G:\PycharmProjects\python_basic\Module19
#     G:\PycharmProjects\python_basic\Module20
#     G:\PycharmProjects\python_basic\Module21
#     G:\PycharmProjects\python_basic\Module22

import os

for path in os.listdir('..'):
    print(os.path.join(os.path.abspath('..'), path))


********************************************************************************

# Часть 2. Модуль 9. Видео 1. Задача 3. Корень диска
# Напишите программу, которая выводит на экран только корень диска, на котором запущен скрипт.
# Учтите, что скрипт может быть запущен где угодно и при любой вложенности папок.
#
# Результат программы на примере диска G:
# Корень диска: G:\\

import os

print(f"Корень диска: {os.path.abspath(os.path.join(os.sep))}")

# Решение для Windows:
print("Корень диска:", os.path.abspath(os.sep).split(os.sep)[0])

# Решение для UNIX:
print("Корень диска:", os.sep)


********************************************************************************

# Часть 2. Модуль 9. Видео 2. Задача 1. Иконки
#
# Напишите программу, которая по заданному абсолютному пути определяет, на что указывает этот путь
# (на директорию, файл, или же путь является ссылкой), и выведите соответствующее сообщение.
# Если путь указывает на файл, то также выведите его размер (сколько он весит в байтах).
# Обеспечьте контроль ввода: проверка пути на существование.
# Подсказка: для вывода размера файла поищите соответствующий метод.
#
# Пример 1:
# Путь: C:\Users\Roman\PycharmProjects\Skillbox\Module17\lesson2.py
# Это файл
# Размер файла: 605 байт
#
# Пример 2:
# Путь: C:\Users\Roman\PycharmProjects\Skillbox\Module17\lesson2.py
# Указанного пути не существует

import os

# Решение Skillbox ---------------------

path_to = input("Путь: ")

if os.path.isdir(path_to):
    print("Это папка!")
elif os.path.isfile(path_to):
    print("Это файл!")
    print("Размер файла:", os.path.getsize(path_to), "байт")
else:
    print("Указанного пути не существует")

# Мое решение ---------------------
#
# def define_type(some_path):
#     if os.path.exists(some_path):
#         if os.path.isdir(some_path):
#             return "Это директория"
#         elif os.path.isfile(some_path):
#             return f"Это файл размером {os.path.getsize(some_path)} байт."
#         elif os.path.islink(some_path):
#             return "Это ссылка"
#     else:
#         return None
#
# if __name__ == '__main__':
#     test_cases = [
#         os.path.abspath(os.path.join(('..'), ('..'), "part_2")),
#         os.path.abspath(os.path.join(('..'), ('..'), ".idea")),
#         os.path.abspath(os.path.join(('..'), ('..'), ".gitignore")),
#         os.path.abspath(os.path.join(('..'), ('..'), "profiles_settings.xml"))
#     ]
#
#     for my_path in test_cases:
#         result = define_type(my_path)
#         if result:
#             print(f"Путь {my_path} - {result}")
#         else:
#             print("Такого пути не существует.")


********************************************************************************

# Часть 2. Модуль 9. Видео 2. Задача 2. Поиск файла
#
# Напишите функцию, которая принимает на вход абсолютный путь до директории и имя файла,
# проходит по всем вложенным файлам и папкам и выводит на экран все абсолютные пути с этим именем.
#
# Пример:
# Ищем в: C:/Users/Roman/PycharmProjects/Skillbox
# Имя файла: lesson2
# Найдены следующие пути:
# C:/Users/Roman/PycharmProjects/Skillbox\Module15\lesson2.py
# C:/Users/Roman/PycharmProjects/Skillbox\Module16\lesson2.py
# C:/Users/Roman/PycharmProjects/Skillbox\Module17\lesson2.py
# C:/Users/Roman/PycharmProjects/Skillbox\Module18\lesson2.py
# C:/Users/Roman/PycharmProjects/Skillbox\Module19\lesson2.py
# C:/Users/Roman/PycharmProjects/Skillbox\Module20\lesson2.py
# C:/Users/Roman/PycharmProjects/Skillbox\Module21\lesson2.py
# C:/Users/Roman/PycharmProjects/Skillbox\Module22\lesson2.py

import os

# def find_files(cur_path, file_name):
#
#     for i_elem in os.listdir(cur_path):     # проходим по всем элементам в текущей директории
#         path = os.path.join(cur_path, i_elem)    # сгенерируем новый путь из текущего пути и элемента списка
#                                                       # (формируем относительный путь из текущей директории и ТЕКУЩЕГО имени файла)
#         if i_elem == file_name:     # проверяем на совпадение текущего имени файла с искомым
#             print(os.path.abspath(path))  # формируем абсолютный путь от относительного к искомому файлу и выводим его
#         elif os.path.isdir(path):    # если сформированный относительный путь оказывается директорией
#             result = find_files(path, file_name)    # ищем снова, но на один уровень вложенности больше
#             if result:
#                 break
#         else:
#             result = None
#
#     return result


def find_files(cur_path, file_name):    # ПРОЦЕДУРА
    for i_elem in os.listdir(cur_path):
        path = os.path.join(cur_path, i_elem)    # генерируем новый относительный путь из текущего пути и текущего элемента списка
        if file_name == i_elem:    # если имена файлов совпадают, то
            print(os.path.abspath(path))    # выводим абсолютный путь от сгенерированного относительного
        elif os.path.isdir(path):
            find_files(path, file_name)

my_dir = '..'
my_abs_path = os.path.join(os.path.abspath(my_dir))     # сгенерировали абсолютный путь для текущей директории
print(f"Ищем в {my_abs_path}")
file_name = 'hash-semple.py'
print(f"Имя файла: {file_name}")
print(f"Найденные пути:")
result = find_files(my_dir, file_name)


********************************************************************************

# Часть 2. Модуль 9. Видео 3. Задача 1. Результаты
#
# Файл первой группы (group_1.txt) находится в папке task,
# файл второй группы (group_2.txt) — в папке Additional_info.
#
# Содержимое файла group_1.txt
# Бобровский Игорь 10
# Дронов Александр 20
# Жуков Виктор 30
#
# Содержимое файла group_2.txt
# Павленко Геннадий 20
# Щербаков Владимир 35
# Marley Bob 15
#
# На экран нужно вывести:
# сумму очков первой группы,
# разность очков первой группы,
# произведение очков второй группы.
#
# Вот код:
#
# file = open('E:\task\group_1.txt', 'read')
# summa = 0
# for i_line in file:
#     info = i_line.split()
#     summa += info[2]
# file = open('E:\task\group_1.txt', 'read')
# diff = 0
# for i_line in file:
#     info = i_line.split()
#     diff -= info[2]
# file_2 = open('E:\task\group_2.txt', 'read')
# compose = 0
# for i_line in file:
#     info = i_line.split()
#     compose *= info[2]
# print(summa)
# print(diff)
# print(compose)
#
# Исправьте код для решения поставленной задачи. Для проверки результата
# создайте необходимые папки (task, Additional_info, Dont touch me) на своём диске
# в соответствии с картинкой и также добавьте файлы group_1.txt и group_2.txt.

import os

file_1 = open(os.path.join(os.path.abspath('task'), 'group_1.txt'), 'r', encoding='utf-8')
file_2 = open(os.path.join(os.path.abspath('Additional_info'), 'group_2.txt'), 'r', encoding='utf-8')

summa, diff, compose = 0, 0, 1

print("\nСодержимое файла 1:")
for i_line in file_1:
    print('    ', i_line, end='')
    info = i_line.split()
    if info:
        summa += int(info[2])
        diff -= int(info[2])

print("\n\nСодержимое файла 2:")
for i_line in file_2:
    print('    ', i_line, end='')
    info = i_line.split()
    if info:
        compose *= int(info[2])

print(f"\n\nИз файла 1: сумма очков = {summa}, разность очков = {diff}.\n"
      f"Из файла 2: произведение очков = {compose}".format(summa=summa, diff=diff, compose=compose))

file_1.close()
file_2.close()


# file_1 = open(os.path.join(os.path.abspath('task'), 'group_1.txt'), 'r', encoding='utf-8')
# file_2 = open(os.path.join(os.path.abspath('Additional_info'), 'group_2.txt'), 'r', encoding='utf-8')
#
# summ = 0
# difference = 0
#
# for i_line in file_1:
#     summ += int(i_line.split()[2])
#     difference -= int(i_line.split()[2])
# print(summ)
# print(difference)
#
# composition = 1
# for i_line in file_2:
#    composition = composition * int(i_line.split()[2])
# print(composition)
#
# file_1.close()
# file_2.close()


********************************************************************************

# Часть 2. Модуль 9. Видео 3. Задача 2. Поиск файла 2
#
# Cкрипты — это тот же текст, с ними можно работать, как с текстовыми файлами.
#
# Реализуйте программу, которая находит внутри указанного пути все файлы
# с искомым названием и выводит на экран текст одного из них (выбор можно сгенерировать случайно).
#
# Подсказка: можно использовать, например, список для сохранения найденного пути.

import os
import random

def find_files(cur_path, file_name, path_list=[],):    # ПРОЦЕДУРА
    for i_elem in os.listdir(cur_path):
        path = os.path.join(cur_path, i_elem)    # генерируем новый относительный путь из текущего пути и текущего элемента списка
        if file_name == i_elem:    # если имена файлов совпадают, то
            path_list.append(os.path.abspath(path))     # сохраняем в список абсолютный путь от сгенерированного относительного
            return path_list
        elif os.path.isdir(path):
            find_files(path, file_name)
    return path_list

my_abs_path = os.path.join(os.path.abspath('..'))     # сгенерировали абсолютный путь для текущей директории
file_name = 'hash-semple.py'
result = find_files('..', file_name)
k = random.randint(0, len(result)-1)
print(f"Содержимое файла: {result[k]}:\n")
rand_file = open(result[k], 'r', encoding='utf-8')
for i_string in rand_file:
    print(i_string, end='')
rand_file.close()


********************************************************************************

# Часть 2. Модуль 9. Видео 4. Задача 1. Сумма чисел
#
# Во входном файле numbers.txt записано N целых чисел, каждое в отдельной строке.
# Напишите программу, которая выводит их сумму в выходной файл answer.txt.
#
# Пример:
# Содержимое файла numbers.txt:
# 1
# 2
# 3
# 4
# 10
#
# Содержимое файла answer.txt
# 20

import os
abs_path = os.path.abspath(os.path.join('numbers1.txt'))
print(abs_path)
num_file = open(abs_path, 'r')
summ = 0
for i_line in num_file:
    summ += int(i_line)
print(summ)
num_file.close()

sum_file = open('summ.txt', 'w')
sum_file.write(str(summ))
sum_file.close()


********************************************************************************

# Часть 2. Модуль 9. Видео 4. Задача 2. Всё в одном
#
# Напишите программу, которая копирует код каждого скрипта в папке проекта python_basic
# в файл scripts.txt, разделяя код строкой из 40 символов *.
#
# Пример содержимого файла scripts.txt:
# import platform
# import sys
# info = 'OS info is \n{}\n\nPython version is {} {}'.format(
#     platform.uname(),
#     sys.version,
#     platform.architecture(),
# )
# print(info)
# with open('os_info.txt', 'w', encoding='utf8') as file:
#     file.write(info)
#
# ****************************************
#
# print("Введите первую точку")
# x1 = float(input('X: '))
# y1 = float(input('Y: '))
# print("\nВведите вторую точку")
# x2 = float(input('X: '))
# y2 = float(input('Y: '))
# print("Уравнение прямой, проходящей через эти точки:")
# x_diff = x1 - x2
# y_diff = y1 - y2
# if x_diff == 0:
#     print("x = ", x1)
# elif y_diff == 0:
#     print("y = ", y1)
# else:
#     k = y_diff / x_diff
#     b = y2 - k * x2
#     print("y = ", k, " * x + ", b)
#
# ****************************************
#
# …….
#
#
# АЛГОРИТМ:
# Функция 1 (формируем список из файлов в нужной директории с нужным окончанием):
# - создаем список для сохранения промежуточных результатов
# - проходим по всем элементам в директории
# - формируем относительный путь к элементу в директории
# - если элемент директории - это питоновский файл
# - то генерируем абсолютный путь к этому файлу и добавляем его в список
# - если сформированный ранее относительный путь окажется директорией
# - то запускаем рекурсию на 1 уровень вложенности глубже
# - если получаем результат,
# - то дополняем им список
# - возвращаем список, заполненный питоновскими файлами
#
# Функция 2 (обращаемся к файлу через его путь и считываем контент):
# - открываем для чтения по нужному пути файл
# - создаем переменную строкового типа
# - проходим по каждой строке файла
# - формируем переменную строкового типа (добавляем туда каждую строку)
# - возвращаем сформированную строку
#
# Мой путь:
# - записываю в переменную относительный путь на две ветки выше от моего положения
# - генерирую абсолютный путь на две ветки выше от моего положения
#
# Основная часть скрипта:
# - формируется список из всех питоновских файлов в моей директории
# - создаем файловый объект для записи
# - для каждого файла в списке питоновских фалов
# - записываем в файловый объект контент, полученный из каждого файла в списке
# - и разделитель

import os

def find_files(cur_path, ending): # формируем список из файлов в нужной директории с нужным окончанием
    files_list = []    # создаем список для сохранения промежуточных результатов
    for i_elem in os.listdir(cur_path):    # проходим по всем элементам в директории
        path = os.path.join(cur_path, i_elem)     # формируем относительный путь к элементу в директории
        if i_elem.endswith(ending):    # если элемент директории - это питоновский файл
            files_list.append(os.path.abspath(path))    # то генерируем абсолютный путь к этому файлу и добавляем его в список
        elif os.path.isdir(path):    # если сформированный ранее относительный путь окажется директорией
            result = find_files(path, ending)    # то запускаем рекурсию на 1 уровень вложенности глубже
            if result:    # если получаем результат,
                files_list.extend(result)    # дополняем список
    return files_list    # возвращаем список, заполненный питоновскими файлами

def get_files_content(path_to_file):    # обращаемся к файлу через его путь и считываем контент
    file = open(path_to_file, "r", encoding="utf8")     # открываем для чтения по нужному пути файл
    result = ""          # создаем переменную строкового типа
    for line in file:    # проходим по каждой строке файла
        result += line    # формируем переменную строкового типа (добавляем туда каждую строку)
    return result    # возвращаем сформированную строку

# мои пути (я делаю)
path = os.path.join('..', '..', '')    # относительный путь на две ветки выше от моего положения
abs_path = os.path.abspath(path)    # генерирую абсолютный путь на две ветки выше от моего положения
print(abs_path)

all_py_files = find_files(abs_path, '.py')    # формируется список из всех питоновских файлов в моей директории
file_result = open("scripts.txt", "w", encoding="utf8")    # создаем файловый объект для записи
for file_path in all_py_files:    # для каждого файла в списке питоновских фалов
    file_result.write(get_files_content(file_path))    # записываем в файловый объект контент, полученный из каждого файла в списке
    file_result.write("\n" * 2 + "*" * 80 + "\n" * 2)    # и разделитель


********************************************************************************

# tuple = (1, 2, 3) # Есть неизменяемый объект (кстати, попробуйте потом повторить этот код с изменяемым объектом)
# hash_value = hash(tuple) # Применим к этому объекту функцию hash
# print(hash_value) # Проверим, что получилось (бессмысленный набор чисел)
# hash_value_2 = hash(tuple) # Попробуем ещё раз
# print(hash_value_2) # Опять набор чисел
# print(hash_value == hash_value_2) # И он в точности равен первому

tuple = (1, 2, 3)     # Возьмём тот же кортеж
print(hash(tuple))     # Его хеш при каждом запуске может отличаться
# При моём запуске хеш был равен числу 529344067295497451
hash_dict = {(1, 2, 3): 'hello'}     # Если я захочу создать словарь с этим кортежем,
# то «под капотом» будет создан массив, в котором по индексу 529344067295497451
# будет храниться пара (1, 2, 3) и 'hello'

********************************************************************************

# import os
#
# folder_name = 'project'
# file_name = 'my_file.txt'
# rel_path = os.path.join('docs', folder_name, file_name)    # формируем относительный путь
# print(rel_path)

# модуль os позволяет взаимодействовать с системой
# path и abspath позволяют работать с путями в файловой системе, с их помощью генерируют пути
# join формирует путь к файлу, пригодится для объединения заранее известных частей пути в один путь

# abs_path = os.path.abspath(file_name)  # формируем абсолютный путь
# print(abs_path)
#
# abs_path2 = os.path.abspath(os.path.join('..', 'new_folder'))    # если папка находится на уровень выше
# # подойдет для любой системы
#
# abs_path3 = os.path.abspath('/new_folder')    # если папка находится в корневом каталоге
#
# os.path.abspath(os.path.join(os.path.sep, 'new_folder'))    # если папка находится в корневом каталоге
# # подойдет для любой системы
# метод abspath отвечает за генерацию абсолютного пути
#
# Вывести корень диска:
# print(f"Корень диска: {os.path.abspath(os.path.join(os.sep))}") - моё решение
#
# Решение для Windows:
# print("Корень диска:", os.path.abspath(os.sep).split(os.sep)[0])
#
# # Решение для UNIX:
# print("Корень диска:", os.sep)

import os

def print_dirs(project):    # получение и вывод содержимого заданной директории
    print(f"\nСодержимое дирректории {project}:")
    if os.path.exists(project):
        for i_elem in os.listdir(project):
# метод listdir модуля os - возвращает список из названий файлов и папок, которые находятся по пути, указанному в скобках
            path = os.path.join(project, i_elem)    # формируем пути к нашим проектам
            print('    ', path)
    else:
        print('Такого каталога не существует.\n')

projects_list = ['part_1', 'part_2', 'path_3']

for i_project in projects_list:
    path_to_project = os.path.abspath(os.path.join('..', '..', i_project))
    print_dirs(path_to_project)

# Почти тоже самое, но только локальный вывод директории текущей папки:
# for path in os.listdir('..'):
#     print(os.path.join(os.path.abspath('..'), path))

# -------------------------------------------------------------------------

# Ищем файл в директории:
def find_file(cur_path, file_name):
    print(f"Переходим в {cur_path}")

    for i_elem in os.listdir(cur_path):    # проходим по всей директории
        path = os.path.join(cur_path, i_elem)    # сгенерируем новый путь из текущего пути и элемента списка
        print(f"    смотрим {path}")
        if file_name == i_elem:
            return path
        if os.path.isdir(path):
            print('это директория')
            result = find_file(path, file_name)
            if result:
                break
    else:
        result = None

    return result

file_path = find_file(os.path.abspath(os.path.join('..', '..', 'part_2')), '2_08_task_1.py')
if file_path:
    print(f"Абсолютный путь к файлу {file_path}")
else:
    print('Файл не найден.')


# Работа с файлами: чтение:

speakers_file = open('speakers.txt', 'r', encoding='utf-8')
# data = speakers_file.read()    # первый способ - считывает сразу весь файл
# print(data)
for i_line in speakers_file:  # способ 2 - считывает файл построчно, т.к. файл - итерируемый объект
    print(i_line, end='')
speakers_file.close()


# Работа с файлами: запись (записывать в файл можно только строковые переменные):

speakers_file = open('speakers.txt', 'r', encoding='utf-8')
sym_count = []
for i_line in speakers_file:
    print(i_line, end='')
    sym_count.append(str(len(i_line)))
sym_count_str = '\n'.join(sym_count)
speakers_file.close()

counts_file = open('sym_count.txt', 'w')
counts_file.write(sym_count_str)
counts_file.close()


# Запись истории поиска в файл:
def find_file(cur_path, file_name):
    print(f"Переходим в {cur_path}")

    for i_elem in os.listdir(cur_path):    # проходим по всей директории
        path = os.path.join(cur_path, i_elem)    # сгенерируем новый путь из текущего пути и элемента списка
        print(f"    смотрим {path}")
        if file_name == i_elem:
            return path
        if os.path.isdir(path):
            print('это директория')
            result = find_file(path, file_name)
            if result:
                break
    else:
        result = None

    return result

file_path = find_file(os.path.abspath(os.path.join('..', '..', 'part_2')), '2_08_task_1.py')
# history_file = open('search_history.txt', 'w', encoding='utf-8')    # режим записи 'w' полностью перезаписывает файл.
history_file = open('search_history.txt', 'a', encoding='utf-8')    # режим записи 'a' дозаписывает в файл.
if file_path:
    print(f"Абсолютный путь к файлу {file_path}")
    history_file.write(file_path)
else:
    print('Файл не найден.')
history_file.close()


********************************************************************************

